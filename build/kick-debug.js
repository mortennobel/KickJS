/*!
 * KickJS 0.5.4 - New BSD License
 * http://www.kickjs.org/
 * License: https://raw.github.com/mortennobel/KickJS/master/license.txt
 *
 * KickJS Uses
 * - glMatrix.js (New BSD License) (https://raw.github.com/toji/gl-matrix/master/LICENSE.md)
 * - WebGL DebugContext (debug mode only - New BSD License like) (https://www.khronos.org/registry/webgl/sdk/debug/webgl-debug.js)
 */

define('kick/core/Constants',[],function () {
    
    /**
     * This class contains references to WebGL constants.<br>
     * Constants will be replace with actual values to increase performance when the file is compile by the postprocessor.<br>
     * Note that I have intentionally named the WebGL constants with a prefix 'GL\_'. This allows use of normal WebGL
     * constants that will not be replaced by the preprocessor.
     * @class Constants
     * @namespace kick.core
     */
    var constants = {};

    Object.defineProperties(constants, {
        /**
         * The current version of the library
         * @property _VERSION
         * @type String
         * @static
         * @final
         */
        _VERSION: { value: "0.5.5", configurable: true, enumerable: true },

        /**
         * Allows usage of assertions in the code. The assertions will be set to false in the "compiled" code (this
         * will remove dead code in the minify-stage).<br>
         * Example usage:
         * @example
         *     var constants = kick.core.Constants;
         *     if (constants._ASSERT){
         *         if (!Number.isNumber(x)){
         *             kick.core.Util.fail("x should be a number");
         *         }
         *     }
         * @property _ASSERT_EDITOR
         * @type Boolean
         * @static
         * @final
         */
        _ASSERT: { value: true, enumerable: true, configurable: true},
        /**
         * Allows usage of debugging in the script code. The flag can be set to false in the "compiled" code (this
         * will remove dead code in the minify-stage).<br>
         * Example usage:<br>
         * @example
         *     var constants = kick.core.Constants;
         *     if (constants._DEBUG){
         *         console.log("X is now "+x);
         *     }
         * </pre>
         * @property _DEBUG
         * @type Boolean
         * @static
         * @final
         */
        _DEBUG: { value: true, enumerable: true, configurable: true},
        /**
         * Value 0.01745329251994
         * @property _DEGREE_TO_RADIAN
         * @type Number
         * @static
         * @final
         */
        _DEGREE_TO_RADIAN : { value: 0.01745329251994, enumerable: true},
        /**
         * Value 57.2957795130824
         * @property _RADIAN_TO_DEGREE
         * @type Number
         * @static
         * @final
         */
        _RADIAN_TO_DEGREE : {value: 57.2957795130824, enumerable: true},
        /**
         * Value 0.00001
         * @property _EPSILON
         * @type Number
         * @static
         * @final
         */
        _EPSILON : {value: 0.00001, enumerable: true},


        // ---- autogenerated from expose_webgl_constants
        /**
        * Value 256
        * @property GL_DEPTH_BUFFER_BIT
        * @type Number
        * @static
        * @final
        */
        GL_DEPTH_BUFFER_BIT: { value: 256, enumerable: true},
        /**
        * Value 1024
        * @property GL_STENCIL_BUFFER_BIT
        * @type Number
        * @static
        * @final
        */
        GL_STENCIL_BUFFER_BIT: { value: 1024, enumerable: true},
        /**
        * Value 16384
        * @property GL_COLOR_BUFFER_BIT
        * @type Number
        * @static
        * @final
        */
        GL_COLOR_BUFFER_BIT: { value: 16384, enumerable: true},
        /**
        * Value 0
        * @property GL_POINTS
        * @type Number
        * @static
        * @final
        */
        GL_POINTS: { value: 0, enumerable: true},
        /**
        * Value 1
        * @property GL_LINES
        * @type Number
        * @static
        * @final
        */
        GL_LINES: { value: 1, enumerable: true},
        /**
        * Value 2
        * @property GL_LINE_LOOP
        * @type Number
        * @static
        * @final
        */
        GL_LINE_LOOP: { value: 2, enumerable: true},
        /**
        * Value 3
        * @property GL_LINE_STRIP
        * @type Number
        * @static
        * @final
        */
        GL_LINE_STRIP: { value: 3, enumerable: true},
        /**
        * Value 4
        * @property GL_TRIANGLES
        * @type Number
        * @static
        * @final
        */
        GL_TRIANGLES: { value: 4, enumerable: true},
        /**
        * Value 5
        * @property GL_TRIANGLE_STRIP
        * @type Number
        * @static
        * @final
        */
        GL_TRIANGLE_STRIP: { value: 5, enumerable: true},
        /**
        * Value 6
        * @property GL_TRIANGLE_FAN
        * @type Number
        * @static
        * @final
        */
        GL_TRIANGLE_FAN: { value: 6, enumerable: true},
        /**
        * Value 0
        * @property GL_ZERO
        * @type Number
        * @static
        * @final
        */
        GL_ZERO: { value: 0, enumerable: true},
        /**
        * Value 1
        * @property GL_ONE
        * @type Number
        * @static
        * @final
        */
        GL_ONE: { value: 1, enumerable: true},
        /**
        * Value 768
        * @property GL_SRC_COLOR
        * @type Number
        * @static
        * @final
        */
        GL_SRC_COLOR: { value: 768, enumerable: true},
        /**
        * Value 769
        * @property GL_ONE_MINUS_SRC_COLOR
        * @type Number
        * @static
        * @final
        */
        GL_ONE_MINUS_SRC_COLOR: { value: 769, enumerable: true},
        /**
        * Value 770
        * @property GL_SRC_ALPHA
        * @type Number
        * @static
        * @final
        */
        GL_SRC_ALPHA: { value: 770, enumerable: true},
        /**
        * Value 771
        * @property GL_ONE_MINUS_SRC_ALPHA
        * @type Number
        * @static
        * @final
        */
        GL_ONE_MINUS_SRC_ALPHA: { value: 771, enumerable: true},
        /**
        * Value 772
        * @property GL_DST_ALPHA
        * @type Number
        * @static
        * @final
        */
        GL_DST_ALPHA: { value: 772, enumerable: true},
        /**
        * Value 773
        * @property GL_ONE_MINUS_DST_ALPHA
        * @type Number
        * @static
        * @final
        */
        GL_ONE_MINUS_DST_ALPHA: { value: 773, enumerable: true},
        /**
        * Value 774
        * @property GL_DST_COLOR
        * @type Number
        * @static
        * @final
        */
        GL_DST_COLOR: { value: 774, enumerable: true},
        /**
        * Value 775
        * @property GL_ONE_MINUS_DST_COLOR
        * @type Number
        * @static
        * @final
        */
        GL_ONE_MINUS_DST_COLOR: { value: 775, enumerable: true},
        /**
        * Value 776
        * @property GL_SRC_ALPHA_SATURATE
        * @type Number
        * @static
        * @final
        */
        GL_SRC_ALPHA_SATURATE: { value: 776, enumerable: true},
        /**
        * Value 32774
        * @property GL_FUNC_ADD
        * @type Number
        * @static
        * @final
        */
        GL_FUNC_ADD: { value: 32774, enumerable: true},
        /**
        * Value 32777
        * @property GL_BLEND_EQUATION
        * @type Number
        * @static
        * @final
        */
        GL_BLEND_EQUATION: { value: 32777, enumerable: true},
        /**
        * Value 32777
        * @property GL_BLEND_EQUATION_RGB
        * @type Number
        * @static
        * @final
        */
        GL_BLEND_EQUATION_RGB: { value: 32777, enumerable: true},
        /**
        * Value 34877
        * @property GL_BLEND_EQUATION_ALPHA
        * @type Number
        * @static
        * @final
        */
        GL_BLEND_EQUATION_ALPHA: { value: 34877, enumerable: true},
        /**
        * Value 32778
        * @property GL_FUNC_SUBTRACT
        * @type Number
        * @static
        * @final
        */
        GL_FUNC_SUBTRACT: { value: 32778, enumerable: true},
        /**
        * Value 32779
        * @property GL_FUNC_REVERSE_SUBTRACT
        * @type Number
        * @static
        * @final
        */
        GL_FUNC_REVERSE_SUBTRACT: { value: 32779, enumerable: true},
        /**
        * Value 32968
        * @property GL_BLEND_DST_RGB
        * @type Number
        * @static
        * @final
        */
        GL_BLEND_DST_RGB: { value: 32968, enumerable: true},
        /**
        * Value 32969
        * @property GL_BLEND_SRC_RGB
        * @type Number
        * @static
        * @final
        */
        GL_BLEND_SRC_RGB: { value: 32969, enumerable: true},
        /**
        * Value 32970
        * @property GL_BLEND_DST_ALPHA
        * @type Number
        * @static
        * @final
        */
        GL_BLEND_DST_ALPHA: { value: 32970, enumerable: true},
        /**
        * Value 32971
        * @property GL_BLEND_SRC_ALPHA
        * @type Number
        * @static
        * @final
        */
        GL_BLEND_SRC_ALPHA: { value: 32971, enumerable: true},
        /**
        * Value 32769
        * @property GL_CONSTANT_COLOR
        * @type Number
        * @static
        * @final
        */
        GL_CONSTANT_COLOR: { value: 32769, enumerable: true},
        /**
        * Value 32770
        * @property GL_ONE_MINUS_CONSTANT_COLOR
        * @type Number
        * @static
        * @final
        */
        GL_ONE_MINUS_CONSTANT_COLOR: { value: 32770, enumerable: true},
        /**
        * Value 32771
        * @property GL_CONSTANT_ALPHA
        * @type Number
        * @static
        * @final
        */
        GL_CONSTANT_ALPHA: { value: 32771, enumerable: true},
        /**
        * Value 32772
        * @property GL_ONE_MINUS_CONSTANT_ALPHA
        * @type Number
        * @static
        * @final
        */
        GL_ONE_MINUS_CONSTANT_ALPHA: { value: 32772, enumerable: true},
        /**
        * Value 32773
        * @property GL_BLEND_COLOR
        * @type Number
        * @static
        * @final
        */
        GL_BLEND_COLOR: { value: 32773, enumerable: true},
        /**
        * Value 34962
        * @property GL_ARRAY_BUFFER
        * @type Number
        * @static
        * @final
        */
        GL_ARRAY_BUFFER: { value: 34962, enumerable: true},
        /**
        * Value 34963
        * @property GL_ELEMENT_ARRAY_BUFFER
        * @type Number
        * @static
        * @final
        */
        GL_ELEMENT_ARRAY_BUFFER: { value: 34963, enumerable: true},
        /**
        * Value 34964
        * @property GL_ARRAY_BUFFER_BINDING
        * @type Number
        * @static
        * @final
        */
        GL_ARRAY_BUFFER_BINDING: { value: 34964, enumerable: true},
        /**
        * Value 34965
        * @property GL_ELEMENT_ARRAY_BUFFER_BINDING
        * @type Number
        * @static
        * @final
        */
        GL_ELEMENT_ARRAY_BUFFER_BINDING: { value: 34965, enumerable: true},
        /**
        * Value 35040
        * @property GL_STREAM_DRAW
        * @type Number
        * @static
        * @final
        */
        GL_STREAM_DRAW: { value: 35040, enumerable: true},
        /**
        * Value 35044
        * @property GL_STATIC_DRAW
        * @type Number
        * @static
        * @final
        */
        GL_STATIC_DRAW: { value: 35044, enumerable: true},
        /**
        * Value 35048
        * @property GL_DYNAMIC_DRAW
        * @type Number
        * @static
        * @final
        */
        GL_DYNAMIC_DRAW: { value: 35048, enumerable: true},
        /**
        * Value 34660
        * @property GL_BUFFER_SIZE
        * @type Number
        * @static
        * @final
        */
        GL_BUFFER_SIZE: { value: 34660, enumerable: true},
        /**
        * Value 34661
        * @property GL_BUFFER_USAGE
        * @type Number
        * @static
        * @final
        */
        GL_BUFFER_USAGE: { value: 34661, enumerable: true},
        /**
        * Value 34342
        * @property GL_CURRENT_VERTEX_ATTRIB
        * @type Number
        * @static
        * @final
        */
        GL_CURRENT_VERTEX_ATTRIB: { value: 34342, enumerable: true},
        /**
        * Value 1028
        * @property GL_FRONT
        * @type Number
        * @static
        * @final
        */
        GL_FRONT: { value: 1028, enumerable: true},
        /**
        * Value 1029
        * @property GL_BACK
        * @type Number
        * @static
        * @final
        */
        GL_BACK: { value: 1029, enumerable: true},
        /**
        * Value 1032
        * @property GL_FRONT_AND_BACK
        * @type Number
        * @static
        * @final
        */
        GL_FRONT_AND_BACK: { value: 1032, enumerable: true},
        /**
        * Value 3553
        * @property GL_TEXTURE_2D
        * @type Number
        * @static
        * @final
        */
        GL_TEXTURE_2D: { value: 3553, enumerable: true},
        /**
        * Value 2884
        * @property GL_CULL_FACE
        * @type Number
        * @static
        * @final
        */
        GL_CULL_FACE: { value: 2884, enumerable: true},
        /**
        * Value 3042
        * @property GL_BLEND
        * @type Number
        * @static
        * @final
        */
        GL_BLEND: { value: 3042, enumerable: true},
        /**
        * Value 3024
        * @property GL_DITHER
        * @type Number
        * @static
        * @final
        */
        GL_DITHER: { value: 3024, enumerable: true},
        /**
        * Value 2960
        * @property GL_STENCIL_TEST
        * @type Number
        * @static
        * @final
        */
        GL_STENCIL_TEST: { value: 2960, enumerable: true},
        /**
        * Value 2929
        * @property GL_DEPTH_TEST
        * @type Number
        * @static
        * @final
        */
        GL_DEPTH_TEST: { value: 2929, enumerable: true},
        /**
        * Value 3089
        * @property GL_SCISSOR_TEST
        * @type Number
        * @static
        * @final
        */
        GL_SCISSOR_TEST: { value: 3089, enumerable: true},
        /**
        * Value 32823
        * @property GL_POLYGON_OFFSET_FILL
        * @type Number
        * @static
        * @final
        */
        GL_POLYGON_OFFSET_FILL: { value: 32823, enumerable: true},
        /**
        * Value 32926
        * @property GL_SAMPLE_ALPHA_TO_COVERAGE
        * @type Number
        * @static
        * @final
        */
        GL_SAMPLE_ALPHA_TO_COVERAGE: { value: 32926, enumerable: true},
        /**
        * Value 32928
        * @property GL_SAMPLE_COVERAGE
        * @type Number
        * @static
        * @final
        */
        GL_SAMPLE_COVERAGE: { value: 32928, enumerable: true},
        /**
        * Value 0
        * @property GL_NO_ERROR
        * @type Number
        * @static
        * @final
        */
        GL_NO_ERROR: { value: 0, enumerable: true},
        /**
        * Value 1280
        * @property GL_INVALID_ENUM
        * @type Number
        * @static
        * @final
        */
        GL_INVALID_ENUM: { value: 1280, enumerable: true},
        /**
        * Value 1281
        * @property GL_INVALID_VALUE
        * @type Number
        * @static
        * @final
        */
        GL_INVALID_VALUE: { value: 1281, enumerable: true},
        /**
        * Value 1282
        * @property GL_INVALID_OPERATION
        * @type Number
        * @static
        * @final
        */
        GL_INVALID_OPERATION: { value: 1282, enumerable: true},
        /**
        * Value 1285
        * @property GL_OUT_OF_MEMORY
        * @type Number
        * @static
        * @final
        */
        GL_OUT_OF_MEMORY: { value: 1285, enumerable: true},
        /**
        * Value 2304
        * @property GL_CW
        * @type Number
        * @static
        * @final
        */
        GL_CW: { value: 2304, enumerable: true},
        /**
        * Value 2305
        * @property GL_CCW
        * @type Number
        * @static
        * @final
        */
        GL_CCW: { value: 2305, enumerable: true},
        /**
        * Value 2849
        * @property GL_LINE_WIDTH
        * @type Number
        * @static
        * @final
        */
        GL_LINE_WIDTH: { value: 2849, enumerable: true},
        /**
        * Value 33901
        * @property GL_ALIASED_POINT_SIZE_RANGE
        * @type Number
        * @static
        * @final
        */
        GL_ALIASED_POINT_SIZE_RANGE: { value: 33901, enumerable: true},
        /**
        * Value 33902
        * @property GL_ALIASED_LINE_WIDTH_RANGE
        * @type Number
        * @static
        * @final
        */
        GL_ALIASED_LINE_WIDTH_RANGE: { value: 33902, enumerable: true},
        /**
        * Value 2885
        * @property GL_CULL_FACE_MODE
        * @type Number
        * @static
        * @final
        */
        GL_CULL_FACE_MODE: { value: 2885, enumerable: true},
        /**
        * Value 2886
        * @property GL_FRONT_FACE
        * @type Number
        * @static
        * @final
        */
        GL_FRONT_FACE: { value: 2886, enumerable: true},
        /**
        * Value 2928
        * @property GL_DEPTH_RANGE
        * @type Number
        * @static
        * @final
        */
        GL_DEPTH_RANGE: { value: 2928, enumerable: true},
        /**
        * Value 2930
        * @property GL_DEPTH_WRITEMASK
        * @type Number
        * @static
        * @final
        */
        GL_DEPTH_WRITEMASK: { value: 2930, enumerable: true},
        /**
        * Value 2931
        * @property GL_DEPTH_CLEAR_VALUE
        * @type Number
        * @static
        * @final
        */
        GL_DEPTH_CLEAR_VALUE: { value: 2931, enumerable: true},
        /**
        * Value 2932
        * @property GL_DEPTH_FUNC
        * @type Number
        * @static
        * @final
        */
        GL_DEPTH_FUNC: { value: 2932, enumerable: true},
        /**
        * Value 2961
        * @property GL_STENCIL_CLEAR_VALUE
        * @type Number
        * @static
        * @final
        */
        GL_STENCIL_CLEAR_VALUE: { value: 2961, enumerable: true},
        /**
        * Value 2962
        * @property GL_STENCIL_FUNC
        * @type Number
        * @static
        * @final
        */
        GL_STENCIL_FUNC: { value: 2962, enumerable: true},
        /**
        * Value 2964
        * @property GL_STENCIL_FAIL
        * @type Number
        * @static
        * @final
        */
        GL_STENCIL_FAIL: { value: 2964, enumerable: true},
        /**
        * Value 2965
        * @property GL_STENCIL_PASS_DEPTH_FAIL
        * @type Number
        * @static
        * @final
        */
        GL_STENCIL_PASS_DEPTH_FAIL: { value: 2965, enumerable: true},
        /**
        * Value 2966
        * @property GL_STENCIL_PASS_DEPTH_PASS
        * @type Number
        * @static
        * @final
        */
        GL_STENCIL_PASS_DEPTH_PASS: { value: 2966, enumerable: true},
        /**
        * Value 2967
        * @property GL_STENCIL_REF
        * @type Number
        * @static
        * @final
        */
        GL_STENCIL_REF: { value: 2967, enumerable: true},
        /**
        * Value 2963
        * @property GL_STENCIL_VALUE_MASK
        * @type Number
        * @static
        * @final
        */
        GL_STENCIL_VALUE_MASK: { value: 2963, enumerable: true},
        /**
        * Value 2968
        * @property GL_STENCIL_WRITEMASK
        * @type Number
        * @static
        * @final
        */
        GL_STENCIL_WRITEMASK: { value: 2968, enumerable: true},
        /**
        * Value 34816
        * @property GL_STENCIL_BACK_FUNC
        * @type Number
        * @static
        * @final
        */
        GL_STENCIL_BACK_FUNC: { value: 34816, enumerable: true},
        /**
        * Value 34817
        * @property GL_STENCIL_BACK_FAIL
        * @type Number
        * @static
        * @final
        */
        GL_STENCIL_BACK_FAIL: { value: 34817, enumerable: true},
        /**
        * Value 34818
        * @property GL_STENCIL_BACK_PASS_DEPTH_FAIL
        * @type Number
        * @static
        * @final
        */
        GL_STENCIL_BACK_PASS_DEPTH_FAIL: { value: 34818, enumerable: true},
        /**
        * Value 34819
        * @property GL_STENCIL_BACK_PASS_DEPTH_PASS
        * @type Number
        * @static
        * @final
        */
        GL_STENCIL_BACK_PASS_DEPTH_PASS: { value: 34819, enumerable: true},
        /**
        * Value 36003
        * @property GL_STENCIL_BACK_REF
        * @type Number
        * @static
        * @final
        */
        GL_STENCIL_BACK_REF: { value: 36003, enumerable: true},
        /**
        * Value 36004
        * @property GL_STENCIL_BACK_VALUE_MASK
        * @type Number
        * @static
        * @final
        */
        GL_STENCIL_BACK_VALUE_MASK: { value: 36004, enumerable: true},
        /**
        * Value 36005
        * @property GL_STENCIL_BACK_WRITEMASK
        * @type Number
        * @static
        * @final
        */
        GL_STENCIL_BACK_WRITEMASK: { value: 36005, enumerable: true},
        /**
        * Value 2978
        * @property GL_VIEWPORT
        * @type Number
        * @static
        * @final
        */
        GL_VIEWPORT: { value: 2978, enumerable: true},
        /**
        * Value 3088
        * @property GL_SCISSOR_BOX
        * @type Number
        * @static
        * @final
        */
        GL_SCISSOR_BOX: { value: 3088, enumerable: true},
        /**
        * Value 3106
        * @property GL_COLOR_CLEAR_VALUE
        * @type Number
        * @static
        * @final
        */
        GL_COLOR_CLEAR_VALUE: { value: 3106, enumerable: true},
        /**
        * Value 3107
        * @property GL_COLOR_WRITEMASK
        * @type Number
        * @static
        * @final
        */
        GL_COLOR_WRITEMASK: { value: 3107, enumerable: true},
        /**
        * Value 3317
        * @property GL_UNPACK_ALIGNMENT
        * @type Number
        * @static
        * @final
        */
        GL_UNPACK_ALIGNMENT: { value: 3317, enumerable: true},
        /**
        * Value 3333
        * @property GL_PACK_ALIGNMENT
        * @type Number
        * @static
        * @final
        */
        GL_PACK_ALIGNMENT: { value: 3333, enumerable: true},
        /**
        * Value 3379
        * @property GL_MAX_TEXTURE_SIZE
        * @type Number
        * @static
        * @final
        */
        GL_MAX_TEXTURE_SIZE: { value: 3379, enumerable: true},
        /**
        * Value 3386
        * @property GL_MAX_VIEWPORT_DIMS
        * @type Number
        * @static
        * @final
        */
        GL_MAX_VIEWPORT_DIMS: { value: 3386, enumerable: true},
        /**
        * Value 3408
        * @property GL_SUBPIXEL_BITS
        * @type Number
        * @static
        * @final
        */
        GL_SUBPIXEL_BITS: { value: 3408, enumerable: true},
        /**
        * Value 3410
        * @property GL_RED_BITS
        * @type Number
        * @static
        * @final
        */
        GL_RED_BITS: { value: 3410, enumerable: true},
        /**
        * Value 3411
        * @property GL_GREEN_BITS
        * @type Number
        * @static
        * @final
        */
        GL_GREEN_BITS: { value: 3411, enumerable: true},
        /**
        * Value 3412
        * @property GL_BLUE_BITS
        * @type Number
        * @static
        * @final
        */
        GL_BLUE_BITS: { value: 3412, enumerable: true},
        /**
        * Value 3413
        * @property GL_ALPHA_BITS
        * @type Number
        * @static
        * @final
        */
        GL_ALPHA_BITS: { value: 3413, enumerable: true},
        /**
        * Value 3414
        * @property GL_DEPTH_BITS
        * @type Number
        * @static
        * @final
        */
        GL_DEPTH_BITS: { value: 3414, enumerable: true},
        /**
        * Value 3415
        * @property GL_STENCIL_BITS
        * @type Number
        * @static
        * @final
        */
        GL_STENCIL_BITS: { value: 3415, enumerable: true},
        /**
        * Value 10752
        * @property GL_POLYGON_OFFSET_UNITS
        * @type Number
        * @static
        * @final
        */
        GL_POLYGON_OFFSET_UNITS: { value: 10752, enumerable: true},
        /**
        * Value 32824
        * @property GL_POLYGON_OFFSET_FACTOR
        * @type Number
        * @static
        * @final
        */
        GL_POLYGON_OFFSET_FACTOR: { value: 32824, enumerable: true},
        /**
        * Value 32873
        * @property GL_TEXTURE_BINDING_2D
        * @type Number
        * @static
        * @final
        */
        GL_TEXTURE_BINDING_2D: { value: 32873, enumerable: true},
        /**
        * Value 32936
        * @property GL_SAMPLE_BUFFERS
        * @type Number
        * @static
        * @final
        */
        GL_SAMPLE_BUFFERS: { value: 32936, enumerable: true},
        /**
        * Value 32937
        * @property GL_SAMPLES
        * @type Number
        * @static
        * @final
        */
        GL_SAMPLES: { value: 32937, enumerable: true},
        /**
        * Value 32938
        * @property GL_SAMPLE_COVERAGE_VALUE
        * @type Number
        * @static
        * @final
        */
        GL_SAMPLE_COVERAGE_VALUE: { value: 32938, enumerable: true},
        /**
        * Value 32939
        * @property GL_SAMPLE_COVERAGE_INVERT
        * @type Number
        * @static
        * @final
        */
        GL_SAMPLE_COVERAGE_INVERT: { value: 32939, enumerable: true},
        /**
        * Value 34467
        * @property GL_COMPRESSED_TEXTURE_FORMATS
        * @type Number
        * @static
        * @final
        */
        GL_COMPRESSED_TEXTURE_FORMATS: { value: 34467, enumerable: true},
        /**
        * Value 4352
        * @property GL_DONT_CARE
        * @type Number
        * @static
        * @final
        */
        GL_DONT_CARE: { value: 4352, enumerable: true},
        /**
        * Value 4353
        * @property GL_FASTEST
        * @type Number
        * @static
        * @final
        */
        GL_FASTEST: { value: 4353, enumerable: true},
        /**
        * Value 4354
        * @property GL_NICEST
        * @type Number
        * @static
        * @final
        */
        GL_NICEST: { value: 4354, enumerable: true},
        /**
        * Value 33170
        * @property GL_GENERATE_MIPMAP_HINT
        * @type Number
        * @static
        * @final
        */
        GL_GENERATE_MIPMAP_HINT: { value: 33170, enumerable: true},
        /**
        * Value 5120
        * @property GL_BYTE
        * @type Number
        * @static
        * @final
        */
        GL_BYTE: { value: 5120, enumerable: true},
        /**
        * Value 5121
        * @property GL_UNSIGNED_BYTE
        * @type Number
        * @static
        * @final
        */
        GL_UNSIGNED_BYTE: { value: 5121, enumerable: true},
        /**
        * Value 5122
        * @property GL_SHORT
        * @type Number
        * @static
        * @final
        */
        GL_SHORT: { value: 5122, enumerable: true},
        /**
        * Value 5123
        * @property GL_UNSIGNED_SHORT
        * @type Number
        * @static
        * @final
        */
        GL_UNSIGNED_SHORT: { value: 5123, enumerable: true},
        /**
        * Value 5124
        * @property GL_INT
        * @type Number
        * @static
        * @final
        */
        GL_INT: { value: 5124, enumerable: true},
        /**
        * Value 5125
        * @property GL_UNSIGNED_INT
        * @type Number
        * @static
        * @final
        */
        GL_UNSIGNED_INT: { value: 5125, enumerable: true},
        /**
        * Value 5126
        * @property GL_FLOAT
        * @type Number
        * @static
        * @final
        */
        GL_FLOAT: { value: 5126, enumerable: true},
        /**
        * Value 6402
        * @property GL_DEPTH_COMPONENT
        * @type Number
        * @static
        * @final
        */
        GL_DEPTH_COMPONENT: { value: 6402, enumerable: true},
        /**
        * Value 6406
        * @property GL_ALPHA
        * @type Number
        * @static
        * @final
        */
        GL_ALPHA: { value: 6406, enumerable: true},
        /**
        * Value 6407
        * @property GL_RGB
        * @type Number
        * @static
        * @final
        */
        GL_RGB: { value: 6407, enumerable: true},
        /**
        * Value 6408
        * @property GL_RGBA
        * @type Number
        * @static
        * @final
        */
        GL_RGBA: { value: 6408, enumerable: true},
        /**
        * Value 6409
        * @property GL_LUMINANCE
        * @type Number
        * @static
        * @final
        */
        GL_LUMINANCE: { value: 6409, enumerable: true},
        /**
        * Value 6410
        * @property GL_LUMINANCE_ALPHA
        * @type Number
        * @static
        * @final
        */
        GL_LUMINANCE_ALPHA: { value: 6410, enumerable: true},
        /**
        * Value 32819
        * @property GL_UNSIGNED_SHORT_4_4_4_4
        * @type Number
        * @static
        * @final
        */
        GL_UNSIGNED_SHORT_4_4_4_4: { value: 32819, enumerable: true},
        /**
        * Value 32820
        * @property GL_UNSIGNED_SHORT_5_5_5_1
        * @type Number
        * @static
        * @final
        */
        GL_UNSIGNED_SHORT_5_5_5_1: { value: 32820, enumerable: true},
        /**
        * Value 33635
        * @property GL_UNSIGNED_SHORT_5_6_5
        * @type Number
        * @static
        * @final
        */
        GL_UNSIGNED_SHORT_5_6_5: { value: 33635, enumerable: true},
        /**
        * Value 35632
        * @property GL_FRAGMENT_SHADER
        * @type Number
        * @static
        * @final
        */
        GL_FRAGMENT_SHADER: { value: 35632, enumerable: true},
        /**
        * Value 35633
        * @property GL_VERTEX_SHADER
        * @type Number
        * @static
        * @final
        */
        GL_VERTEX_SHADER: { value: 35633, enumerable: true},
        /**
        * Value 34921
        * @property GL_MAX_VERTEX_ATTRIBS
        * @type Number
        * @static
        * @final
        */
        GL_MAX_VERTEX_ATTRIBS: { value: 34921, enumerable: true},
        /**
        * Value 36347
        * @property GL_MAX_VERTEX_UNIFORM_VECTORS
        * @type Number
        * @static
        * @final
        */
        GL_MAX_VERTEX_UNIFORM_VECTORS: { value: 36347, enumerable: true},
        /**
        * Value 36348
        * @property GL_MAX_VARYING_VECTORS
        * @type Number
        * @static
        * @final
        */
        GL_MAX_VARYING_VECTORS: { value: 36348, enumerable: true},
        /**
        * Value 35661
        * @property GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS
        * @type Number
        * @static
        * @final
        */
        GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS: { value: 35661, enumerable: true},
        /**
        * Value 35660
        * @property GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS
        * @type Number
        * @static
        * @final
        */
        GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS: { value: 35660, enumerable: true},
        /**
        * Value 34930
        * @property GL_MAX_TEXTURE_IMAGE_UNITS
        * @type Number
        * @static
        * @final
        */
        GL_MAX_TEXTURE_IMAGE_UNITS: { value: 34930, enumerable: true},
        /**
        * Value 36349
        * @property GL_MAX_FRAGMENT_UNIFORM_VECTORS
        * @type Number
        * @static
        * @final
        */
        GL_MAX_FRAGMENT_UNIFORM_VECTORS: { value: 36349, enumerable: true},
        /**
        * Value 35663
        * @property GL_SHADER_TYPE
        * @type Number
        * @static
        * @final
        */
        GL_SHADER_TYPE: { value: 35663, enumerable: true},
        /**
        * Value 35712
        * @property GL_DELETE_STATUS
        * @type Number
        * @static
        * @final
        */
        GL_DELETE_STATUS: { value: 35712, enumerable: true},
        /**
        * Value 35714
        * @property GL_LINK_STATUS
        * @type Number
        * @static
        * @final
        */
        GL_LINK_STATUS: { value: 35714, enumerable: true},
        /**
        * Value 35715
        * @property GL_VALIDATE_STATUS
        * @type Number
        * @static
        * @final
        */
        GL_VALIDATE_STATUS: { value: 35715, enumerable: true},
        /**
        * Value 35717
        * @property GL_ATTACHED_SHADERS
        * @type Number
        * @static
        * @final
        */
        GL_ATTACHED_SHADERS: { value: 35717, enumerable: true},
        /**
        * Value 35718
        * @property GL_ACTIVE_UNIFORMS
        * @type Number
        * @static
        * @final
        */
        GL_ACTIVE_UNIFORMS: { value: 35718, enumerable: true},
        /**
        * Value 35721
        * @property GL_ACTIVE_ATTRIBUTES
        * @type Number
        * @static
        * @final
        */
        GL_ACTIVE_ATTRIBUTES: { value: 35721, enumerable: true},
        /**
        * Value 35724
        * @property GL_SHADING_LANGUAGE_VERSION
        * @type Number
        * @static
        * @final
        */
        GL_SHADING_LANGUAGE_VERSION: { value: 35724, enumerable: true},
        /**
        * Value 35725
        * @property GL_CURRENT_PROGRAM
        * @type Number
        * @static
        * @final
        */
        GL_CURRENT_PROGRAM: { value: 35725, enumerable: true},
        /**
        * Value 512
        * @property GL_NEVER
        * @type Number
        * @static
        * @final
        */
        GL_NEVER: { value: 512, enumerable: true},
        /**
        * Value 513
        * @property GL_LESS
        * @type Number
        * @static
        * @final
        */
        GL_LESS: { value: 513, enumerable: true},
        /**
        * Value 514
        * @property GL_EQUAL
        * @type Number
        * @static
        * @final
        */
        GL_EQUAL: { value: 514, enumerable: true},
        /**
        * Value 515
        * @property GL_LEQUAL
        * @type Number
        * @static
        * @final
        */
        GL_LEQUAL: { value: 515, enumerable: true},
        /**
        * Value 516
        * @property GL_GREATER
        * @type Number
        * @static
        * @final
        */
        GL_GREATER: { value: 516, enumerable: true},
        /**
        * Value 517
        * @property GL_NOTEQUAL
        * @type Number
        * @static
        * @final
        */
        GL_NOTEQUAL: { value: 517, enumerable: true},
        /**
        * Value 518
        * @property GL_GEQUAL
        * @type Number
        * @static
        * @final
        */
        GL_GEQUAL: { value: 518, enumerable: true},
        /**
        * Value 519
        * @property GL_ALWAYS
        * @type Number
        * @static
        * @final
        */
        GL_ALWAYS: { value: 519, enumerable: true},
        /**
        * Value 7680
        * @property GL_KEEP
        * @type Number
        * @static
        * @final
        */
        GL_KEEP: { value: 7680, enumerable: true},
        /**
        * Value 7681
        * @property GL_REPLACE
        * @type Number
        * @static
        * @final
        */
        GL_REPLACE: { value: 7681, enumerable: true},
        /**
        * Value 7682
        * @property GL_INCR
        * @type Number
        * @static
        * @final
        */
        GL_INCR: { value: 7682, enumerable: true},
        /**
        * Value 7683
        * @property GL_DECR
        * @type Number
        * @static
        * @final
        */
        GL_DECR: { value: 7683, enumerable: true},
        /**
        * Value 5386
        * @property GL_INVERT
        * @type Number
        * @static
        * @final
        */
        GL_INVERT: { value: 5386, enumerable: true},
        /**
        * Value 34055
        * @property GL_INCR_WRAP
        * @type Number
        * @static
        * @final
        */
        GL_INCR_WRAP: { value: 34055, enumerable: true},
        /**
        * Value 34056
        * @property GL_DECR_WRAP
        * @type Number
        * @static
        * @final
        */
        GL_DECR_WRAP: { value: 34056, enumerable: true},
        /**
        * Value 7936
        * @property GL_VENDOR
        * @type Number
        * @static
        * @final
        */
        GL_VENDOR: { value: 7936, enumerable: true},
        /**
        * Value 7937
        * @property GL_RENDERER
        * @type Number
        * @static
        * @final
        */
        GL_RENDERER: { value: 7937, enumerable: true},
        /**
        * Value 7938
        * @property GL_VERSION
        * @type Number
        * @static
        * @final
        */
        GL_VERSION: { value: 7938, enumerable: true},
        /**
        * Value 9728
        * @property GL_NEAREST
        * @type Number
        * @static
        * @final
        */
        GL_NEAREST: { value: 9728, enumerable: true},
        /**
        * Value 9729
        * @property GL_LINEAR
        * @type Number
        * @static
        * @final
        */
        GL_LINEAR: { value: 9729, enumerable: true},
        /**
        * Value 9984
        * @property GL_NEAREST_MIPMAP_NEAREST
        * @type Number
        * @static
        * @final
        */
        GL_NEAREST_MIPMAP_NEAREST: { value: 9984, enumerable: true},
        /**
        * Value 9985
        * @property GL_LINEAR_MIPMAP_NEAREST
        * @type Number
        * @static
        * @final
        */
        GL_LINEAR_MIPMAP_NEAREST: { value: 9985, enumerable: true},
        /**
        * Value 9986
        * @property GL_NEAREST_MIPMAP_LINEAR
        * @type Number
        * @static
        * @final
        */
        GL_NEAREST_MIPMAP_LINEAR: { value: 9986, enumerable: true},
        /**
        * Value 9987
        * @property GL_LINEAR_MIPMAP_LINEAR
        * @type Number
        * @static
        * @final
        */
        GL_LINEAR_MIPMAP_LINEAR: { value: 9987, enumerable: true},
        /**
        * Value 10240
        * @property GL_TEXTURE_MAG_FILTER
        * @type Number
        * @static
        * @final
        */
        GL_TEXTURE_MAG_FILTER: { value: 10240, enumerable: true},
        /**
        * Value 10241
        * @property GL_TEXTURE_MIN_FILTER
        * @type Number
        * @static
        * @final
        */
        GL_TEXTURE_MIN_FILTER: { value: 10241, enumerable: true},
        /**
        * Value 10242
        * @property GL_TEXTURE_WRAP_S
        * @type Number
        * @static
        * @final
        */
        GL_TEXTURE_WRAP_S: { value: 10242, enumerable: true},
        /**
        * Value 10243
        * @property GL_TEXTURE_WRAP_T
        * @type Number
        * @static
        * @final
        */
        GL_TEXTURE_WRAP_T: { value: 10243, enumerable: true},
        /**
        * Value 5890
        * @property GL_TEXTURE
        * @type Number
        * @static
        * @final
        */
        GL_TEXTURE: { value: 5890, enumerable: true},
        /**
        * Value 34067
        * @property GL_TEXTURE_CUBE_MAP
        * @type Number
        * @static
        * @final
        */
        GL_TEXTURE_CUBE_MAP: { value: 34067, enumerable: true},
        /**
        * Value 34068
        * @property GL_TEXTURE_BINDING_CUBE_MAP
        * @type Number
        * @static
        * @final
        */
        GL_TEXTURE_BINDING_CUBE_MAP: { value: 34068, enumerable: true},
        /**
        * Value 34069
        * @property GL_TEXTURE_CUBE_MAP_POSITIVE_X
        * @type Number
        * @static
        * @final
        */
        GL_TEXTURE_CUBE_MAP_POSITIVE_X: { value: 34069, enumerable: true},
        /**
        * Value 34070
        * @property GL_TEXTURE_CUBE_MAP_NEGATIVE_X
        * @type Number
        * @static
        * @final
        */
        GL_TEXTURE_CUBE_MAP_NEGATIVE_X: { value: 34070, enumerable: true},
        /**
        * Value 34071
        * @property GL_TEXTURE_CUBE_MAP_POSITIVE_Y
        * @type Number
        * @static
        * @final
        */
        GL_TEXTURE_CUBE_MAP_POSITIVE_Y: { value: 34071, enumerable: true},
        /**
        * Value 34072
        * @property GL_TEXTURE_CUBE_MAP_NEGATIVE_Y
        * @type Number
        * @static
        * @final
        */
        GL_TEXTURE_CUBE_MAP_NEGATIVE_Y: { value: 34072, enumerable: true},
        /**
        * Value 34073
        * @property GL_TEXTURE_CUBE_MAP_POSITIVE_Z
        * @type Number
        * @static
        * @final
        */
        GL_TEXTURE_CUBE_MAP_POSITIVE_Z: { value: 34073, enumerable: true},
        /**
        * Value 34074
        * @property GL_TEXTURE_CUBE_MAP_NEGATIVE_Z
        * @type Number
        * @static
        * @final
        */
        GL_TEXTURE_CUBE_MAP_NEGATIVE_Z: { value: 34074, enumerable: true},
        /**
        * Value 34076
        * @property GL_MAX_CUBE_MAP_TEXTURE_SIZE
        * @type Number
        * @static
        * @final
        */
        GL_MAX_CUBE_MAP_TEXTURE_SIZE: { value: 34076, enumerable: true},
        /**
        * Value 33984
        * @property GL_TEXTURE0
        * @type Number
        * @static
        * @final
        */
        GL_TEXTURE0: { value: 33984, enumerable: true},
        /**
        * Value 33985
        * @property GL_TEXTURE1
        * @type Number
        * @static
        * @final
        */
        GL_TEXTURE1: { value: 33985, enumerable: true},
        /**
        * Value 33986
        * @property GL_TEXTURE2
        * @type Number
        * @static
        * @final
        */
        GL_TEXTURE2: { value: 33986, enumerable: true},
        /**
        * Value 33987
        * @property GL_TEXTURE3
        * @type Number
        * @static
        * @final
        */
        GL_TEXTURE3: { value: 33987, enumerable: true},
        /**
        * Value 33988
        * @property GL_TEXTURE4
        * @type Number
        * @static
        * @final
        */
        GL_TEXTURE4: { value: 33988, enumerable: true},
        /**
        * Value 33989
        * @property GL_TEXTURE5
        * @type Number
        * @static
        * @final
        */
        GL_TEXTURE5: { value: 33989, enumerable: true},
        /**
        * Value 33990
        * @property GL_TEXTURE6
        * @type Number
        * @static
        * @final
        */
        GL_TEXTURE6: { value: 33990, enumerable: true},
        /**
        * Value 33991
        * @property GL_TEXTURE7
        * @type Number
        * @static
        * @final
        */
        GL_TEXTURE7: { value: 33991, enumerable: true},
        /**
        * Value 33992
        * @property GL_TEXTURE8
        * @type Number
        * @static
        * @final
        */
        GL_TEXTURE8: { value: 33992, enumerable: true},
        /**
        * Value 33993
        * @property GL_TEXTURE9
        * @type Number
        * @static
        * @final
        */
        GL_TEXTURE9: { value: 33993, enumerable: true},
        /**
        * Value 33994
        * @property GL_TEXTURE10
        * @type Number
        * @static
        * @final
        */
        GL_TEXTURE10: { value: 33994, enumerable: true},
        /**
        * Value 33995
        * @property GL_TEXTURE11
        * @type Number
        * @static
        * @final
        */
        GL_TEXTURE11: { value: 33995, enumerable: true},
        /**
        * Value 33996
        * @property GL_TEXTURE12
        * @type Number
        * @static
        * @final
        */
        GL_TEXTURE12: { value: 33996, enumerable: true},
        /**
        * Value 33997
        * @property GL_TEXTURE13
        * @type Number
        * @static
        * @final
        */
        GL_TEXTURE13: { value: 33997, enumerable: true},
        /**
        * Value 33998
        * @property GL_TEXTURE14
        * @type Number
        * @static
        * @final
        */
        GL_TEXTURE14: { value: 33998, enumerable: true},
        /**
        * Value 33999
        * @property GL_TEXTURE15
        * @type Number
        * @static
        * @final
        */
        GL_TEXTURE15: { value: 33999, enumerable: true},
        /**
        * Value 34000
        * @property GL_TEXTURE16
        * @type Number
        * @static
        * @final
        */
        GL_TEXTURE16: { value: 34000, enumerable: true},
        /**
        * Value 34001
        * @property GL_TEXTURE17
        * @type Number
        * @static
        * @final
        */
        GL_TEXTURE17: { value: 34001, enumerable: true},
        /**
        * Value 34002
        * @property GL_TEXTURE18
        * @type Number
        * @static
        * @final
        */
        GL_TEXTURE18: { value: 34002, enumerable: true},
        /**
        * Value 34003
        * @property GL_TEXTURE19
        * @type Number
        * @static
        * @final
        */
        GL_TEXTURE19: { value: 34003, enumerable: true},
        /**
        * Value 34004
        * @property GL_TEXTURE20
        * @type Number
        * @static
        * @final
        */
        GL_TEXTURE20: { value: 34004, enumerable: true},
        /**
        * Value 34005
        * @property GL_TEXTURE21
        * @type Number
        * @static
        * @final
        */
        GL_TEXTURE21: { value: 34005, enumerable: true},
        /**
        * Value 34006
        * @property GL_TEXTURE22
        * @type Number
        * @static
        * @final
        */
        GL_TEXTURE22: { value: 34006, enumerable: true},
        /**
        * Value 34007
        * @property GL_TEXTURE23
        * @type Number
        * @static
        * @final
        */
        GL_TEXTURE23: { value: 34007, enumerable: true},
        /**
        * Value 34008
        * @property GL_TEXTURE24
        * @type Number
        * @static
        * @final
        */
        GL_TEXTURE24: { value: 34008, enumerable: true},
        /**
        * Value 34009
        * @property GL_TEXTURE25
        * @type Number
        * @static
        * @final
        */
        GL_TEXTURE25: { value: 34009, enumerable: true},
        /**
        * Value 34010
        * @property GL_TEXTURE26
        * @type Number
        * @static
        * @final
        */
        GL_TEXTURE26: { value: 34010, enumerable: true},
        /**
        * Value 34011
        * @property GL_TEXTURE27
        * @type Number
        * @static
        * @final
        */
        GL_TEXTURE27: { value: 34011, enumerable: true},
        /**
        * Value 34012
        * @property GL_TEXTURE28
        * @type Number
        * @static
        * @final
        */
        GL_TEXTURE28: { value: 34012, enumerable: true},
        /**
        * Value 34013
        * @property GL_TEXTURE29
        * @type Number
        * @static
        * @final
        */
        GL_TEXTURE29: { value: 34013, enumerable: true},
        /**
        * Value 34014
        * @property GL_TEXTURE30
        * @type Number
        * @static
        * @final
        */
        GL_TEXTURE30: { value: 34014, enumerable: true},
        /**
        * Value 34015
        * @property GL_TEXTURE31
        * @type Number
        * @static
        * @final
        */
        GL_TEXTURE31: { value: 34015, enumerable: true},
        /**
        * Value 34016
        * @property GL_ACTIVE_TEXTURE
        * @type Number
        * @static
        * @final
        */
        GL_ACTIVE_TEXTURE: { value: 34016, enumerable: true},
        /**
        * Value 10497
        * @property GL_REPEAT
        * @type Number
        * @static
        * @final
        */
        GL_REPEAT: { value: 10497, enumerable: true},
        /**
        * Value 33071
        * @property GL_CLAMP_TO_EDGE
        * @type Number
        * @static
        * @final
        */
        GL_CLAMP_TO_EDGE: { value: 33071, enumerable: true},
        /**
        * Value 33648
        * @property GL_MIRRORED_REPEAT
        * @type Number
        * @static
        * @final
        */
        GL_MIRRORED_REPEAT: { value: 33648, enumerable: true},
        /**
        * Value 35664
        * @property GL_FLOAT_VEC2
        * @type Number
        * @static
        * @final
        */
        GL_FLOAT_VEC2: { value: 35664, enumerable: true},
        /**
        * Value 35665
        * @property GL_FLOAT_VEC3
        * @type Number
        * @static
        * @final
        */
        GL_FLOAT_VEC3: { value: 35665, enumerable: true},
        /**
        * Value 35666
        * @property GL_FLOAT_VEC4
        * @type Number
        * @static
        * @final
        */
        GL_FLOAT_VEC4: { value: 35666, enumerable: true},
        /**
        * Value 35667
        * @property GL_INT_VEC2
        * @type Number
        * @static
        * @final
        */
        GL_INT_VEC2: { value: 35667, enumerable: true},
        /**
        * Value 35668
        * @property GL_INT_VEC3
        * @type Number
        * @static
        * @final
        */
        GL_INT_VEC3: { value: 35668, enumerable: true},
        /**
        * Value 35669
        * @property GL_INT_VEC4
        * @type Number
        * @static
        * @final
        */
        GL_INT_VEC4: { value: 35669, enumerable: true},
        /**
        * Value 35670
        * @property GL_BOOL
        * @type Number
        * @static
        * @final
        */
        GL_BOOL: { value: 35670, enumerable: true},
        /**
        * Value 35671
        * @property GL_BOOL_VEC2
        * @type Number
        * @static
        * @final
        */
        GL_BOOL_VEC2: { value: 35671, enumerable: true},
        /**
        * Value 35672
        * @property GL_BOOL_VEC3
        * @type Number
        * @static
        * @final
        */
        GL_BOOL_VEC3: { value: 35672, enumerable: true},
        /**
        * Value 35673
        * @property GL_BOOL_VEC4
        * @type Number
        * @static
        * @final
        */
        GL_BOOL_VEC4: { value: 35673, enumerable: true},
        /**
        * Value 35674
        * @property GL_FLOAT_MAT2
        * @type Number
        * @static
        * @final
        */
        GL_FLOAT_MAT2: { value: 35674, enumerable: true},
        /**
        * Value 35675
        * @property GL_FLOAT_MAT3
        * @type Number
        * @static
        * @final
        */
        GL_FLOAT_MAT3: { value: 35675, enumerable: true},
        /**
        * Value 35676
        * @property GL_FLOAT_MAT4
        * @type Number
        * @static
        * @final
        */
        GL_FLOAT_MAT4: { value: 35676, enumerable: true},
        /**
        * Value 35678
        * @property GL_SAMPLER_2D
        * @type Number
        * @static
        * @final
        */
        GL_SAMPLER_2D: { value: 35678, enumerable: true},
        /**
        * Value 35680
        * @property GL_SAMPLER_CUBE
        * @type Number
        * @static
        * @final
        */
        GL_SAMPLER_CUBE: { value: 35680, enumerable: true},
        /**
        * Value 34338
        * @property GL_VERTEX_ATTRIB_ARRAY_ENABLED
        * @type Number
        * @static
        * @final
        */
        GL_VERTEX_ATTRIB_ARRAY_ENABLED: { value: 34338, enumerable: true},
        /**
        * Value 34339
        * @property GL_VERTEX_ATTRIB_ARRAY_SIZE
        * @type Number
        * @static
        * @final
        */
        GL_VERTEX_ATTRIB_ARRAY_SIZE: { value: 34339, enumerable: true},
        /**
        * Value 34340
        * @property GL_VERTEX_ATTRIB_ARRAY_STRIDE
        * @type Number
        * @static
        * @final
        */
        GL_VERTEX_ATTRIB_ARRAY_STRIDE: { value: 34340, enumerable: true},
        /**
        * Value 34341
        * @property GL_VERTEX_ATTRIB_ARRAY_TYPE
        * @type Number
        * @static
        * @final
        */
        GL_VERTEX_ATTRIB_ARRAY_TYPE: { value: 34341, enumerable: true},
        /**
        * Value 34922
        * @property GL_VERTEX_ATTRIB_ARRAY_NORMALIZED
        * @type Number
        * @static
        * @final
        */
        GL_VERTEX_ATTRIB_ARRAY_NORMALIZED: { value: 34922, enumerable: true},
        /**
        * Value 34373
        * @property GL_VERTEX_ATTRIB_ARRAY_POINTER
        * @type Number
        * @static
        * @final
        */
        GL_VERTEX_ATTRIB_ARRAY_POINTER: { value: 34373, enumerable: true},
        /**
        * Value 34975
        * @property GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING
        * @type Number
        * @static
        * @final
        */
        GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING: { value: 34975, enumerable: true},
        /**
        * Value 35713
        * @property GL_COMPILE_STATUS
        * @type Number
        * @static
        * @final
        */
        GL_COMPILE_STATUS: { value: 35713, enumerable: true},
        /**
        * Value 36336
        * @property GL_LOW_FLOAT
        * @type Number
        * @static
        * @final
        */
        GL_LOW_FLOAT: { value: 36336, enumerable: true},
        /**
        * Value 36337
        * @property GL_MEDIUM_FLOAT
        * @type Number
        * @static
        * @final
        */
        GL_MEDIUM_FLOAT: { value: 36337, enumerable: true},
        /**
        * Value 36338
        * @property GL_HIGH_FLOAT
        * @type Number
        * @static
        * @final
        */
        GL_HIGH_FLOAT: { value: 36338, enumerable: true},
        /**
        * Value 36339
        * @property GL_LOW_INT
        * @type Number
        * @static
        * @final
        */
        GL_LOW_INT: { value: 36339, enumerable: true},
        /**
        * Value 36340
        * @property GL_MEDIUM_INT
        * @type Number
        * @static
        * @final
        */
        GL_MEDIUM_INT: { value: 36340, enumerable: true},
        /**
        * Value 36341
        * @property GL_HIGH_INT
        * @type Number
        * @static
        * @final
        */
        GL_HIGH_INT: { value: 36341, enumerable: true},
        /**
        * Value 36160
        * @property GL_FRAMEBUFFER
        * @type Number
        * @static
        * @final
        */
        GL_FRAMEBUFFER: { value: 36160, enumerable: true},
        /**
        * Value 36161
        * @property GL_RENDERBUFFER
        * @type Number
        * @static
        * @final
        */
        GL_RENDERBUFFER: { value: 36161, enumerable: true},
        /**
        * Value 32854
        * @property GL_RGBA4
        * @type Number
        * @static
        * @final
        */
        GL_RGBA4: { value: 32854, enumerable: true},
        /**
        * Value 32855
        * @property GL_RGB5_A1
        * @type Number
        * @static
        * @final
        */
        GL_RGB5_A1: { value: 32855, enumerable: true},
        /**
        * Value 36194
        * @property GL_RGB565
        * @type Number
        * @static
        * @final
        */
        GL_RGB565: { value: 36194, enumerable: true},
        /**
        * Value 33189
        * @property GL_DEPTH_COMPONENT16
        * @type Number
        * @static
        * @final
        */
        GL_DEPTH_COMPONENT16: { value: 33189, enumerable: true},
        /**
        * Value 6401
        * @property GL_STENCIL_INDEX
        * @type Number
        * @static
        * @final
        */
        GL_STENCIL_INDEX: { value: 6401, enumerable: true},
        /**
        * Value 36168
        * @property GL_STENCIL_INDEX8
        * @type Number
        * @static
        * @final
        */
        GL_STENCIL_INDEX8: { value: 36168, enumerable: true},
        /**
        * Value 34041
        * @property GL_DEPTH_STENCIL
        * @type Number
        * @static
        * @final
        */
        GL_DEPTH_STENCIL: { value: 34041, enumerable: true},
        /**
        * Value 36162
        * @property GL_RENDERBUFFER_WIDTH
        * @type Number
        * @static
        * @final
        */
        GL_RENDERBUFFER_WIDTH: { value: 36162, enumerable: true},
        /**
        * Value 36163
        * @property GL_RENDERBUFFER_HEIGHT
        * @type Number
        * @static
        * @final
        */
        GL_RENDERBUFFER_HEIGHT: { value: 36163, enumerable: true},
        /**
        * Value 36164
        * @property GL_RENDERBUFFER_INTERNAL_FORMAT
        * @type Number
        * @static
        * @final
        */
        GL_RENDERBUFFER_INTERNAL_FORMAT: { value: 36164, enumerable: true},
        /**
        * Value 36176
        * @property GL_RENDERBUFFER_RED_SIZE
        * @type Number
        * @static
        * @final
        */
        GL_RENDERBUFFER_RED_SIZE: { value: 36176, enumerable: true},
        /**
        * Value 36177
        * @property GL_RENDERBUFFER_GREEN_SIZE
        * @type Number
        * @static
        * @final
        */
        GL_RENDERBUFFER_GREEN_SIZE: { value: 36177, enumerable: true},
        /**
        * Value 36178
        * @property GL_RENDERBUFFER_BLUE_SIZE
        * @type Number
        * @static
        * @final
        */
        GL_RENDERBUFFER_BLUE_SIZE: { value: 36178, enumerable: true},
        /**
        * Value 36179
        * @property GL_RENDERBUFFER_ALPHA_SIZE
        * @type Number
        * @static
        * @final
        */
        GL_RENDERBUFFER_ALPHA_SIZE: { value: 36179, enumerable: true},
        /**
        * Value 36180
        * @property GL_RENDERBUFFER_DEPTH_SIZE
        * @type Number
        * @static
        * @final
        */
        GL_RENDERBUFFER_DEPTH_SIZE: { value: 36180, enumerable: true},
        /**
        * Value 36181
        * @property GL_RENDERBUFFER_STENCIL_SIZE
        * @type Number
        * @static
        * @final
        */
        GL_RENDERBUFFER_STENCIL_SIZE: { value: 36181, enumerable: true},
        /**
        * Value 36048
        * @property GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE
        * @type Number
        * @static
        * @final
        */
        GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE: { value: 36048, enumerable: true},
        /**
        * Value 36049
        * @property GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME
        * @type Number
        * @static
        * @final
        */
        GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME: { value: 36049, enumerable: true},
        /**
        * Value 36050
        * @property GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL
        * @type Number
        * @static
        * @final
        */
        GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL: { value: 36050, enumerable: true},
        /**
        * Value 36051
        * @property GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE
        * @type Number
        * @static
        * @final
        */
        GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE: { value: 36051, enumerable: true},
        /**
        * Value 36096
        * @property GL_DEPTH_ATTACHMENT
        * @type Number
        * @static
        * @final
        */
        GL_DEPTH_ATTACHMENT: { value: 36096, enumerable: true},
        /**
        * Value 36128
        * @property GL_STENCIL_ATTACHMENT
        * @type Number
        * @static
        * @final
        */
        GL_STENCIL_ATTACHMENT: { value: 36128, enumerable: true},
        /**
        * Value 33306
        * @property GL_DEPTH_STENCIL_ATTACHMENT
        * @type Number
        * @static
        * @final
        */
        GL_DEPTH_STENCIL_ATTACHMENT: { value: 33306, enumerable: true},
        /**
        * Value 0
        * @property GL_NONE
        * @type Number
        * @static
        * @final
        */
        GL_NONE: { value: 0, enumerable: true},
        /**
        * Value 36053
        * @property GL_FRAMEBUFFER_COMPLETE
        * @type Number
        * @static
        * @final
        */
        GL_FRAMEBUFFER_COMPLETE: { value: 36053, enumerable: true},
        /**
        * Value 36054
        * @property GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT
        * @type Number
        * @static
        * @final
        */
        GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT: { value: 36054, enumerable: true},
        /**
        * Value 36055
        * @property GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT
        * @type Number
        * @static
        * @final
        */
        GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT: { value: 36055, enumerable: true},
        /**
        * Value 36057
        * @property GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS
        * @type Number
        * @static
        * @final
        */
        GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS: { value: 36057, enumerable: true},
        /**
        * Value 36061
        * @property GL_FRAMEBUFFER_UNSUPPORTED
        * @type Number
        * @static
        * @final
        */
        GL_FRAMEBUFFER_UNSUPPORTED: { value: 36061, enumerable: true},
        /**
        * Value 36006
        * @property GL_FRAMEBUFFER_BINDING
        * @type Number
        * @static
        * @final
        */
        GL_FRAMEBUFFER_BINDING: { value: 36006, enumerable: true},
        /**
        * Value 36007
        * @property GL_RENDERBUFFER_BINDING
        * @type Number
        * @static
        * @final
        */
        GL_RENDERBUFFER_BINDING: { value: 36007, enumerable: true},
        /**
        * Value 34024
        * @property GL_MAX_RENDERBUFFER_SIZE
        * @type Number
        * @static
        * @final
        */
        GL_MAX_RENDERBUFFER_SIZE: { value: 34024, enumerable: true},
        /**
        * Value 1286
        * @property GL_INVALID_FRAMEBUFFER_OPERATION
        * @type Number
        * @static
        * @final
        */
        GL_INVALID_FRAMEBUFFER_OPERATION: { value: 1286, enumerable: true},
        /**
        * Value 37440
        * @property GL_UNPACK_FLIP_Y_WEBGL
        * @type Number
        * @static
        * @final
        */
        GL_UNPACK_FLIP_Y_WEBGL: { value: 37440, enumerable: true},
        /**
        * Value 37441
        * @property GL_UNPACK_PREMULTIPLY_ALPHA_WEBGL
        * @type Number
        * @static
        * @final
        */
        GL_UNPACK_PREMULTIPLY_ALPHA_WEBGL: { value: 37441, enumerable: true},
        /**
        * Value 37442
        * @property GL_CONTEXT_LOST_WEBGL
        * @type Number
        * @static
        * @final
        */
        GL_CONTEXT_LOST_WEBGL: { value: 37442, enumerable: true},
        /**
        * Value 37443
        * @property GL_UNPACK_COLORSPACE_CONVERSION_WEBGL
        * @type Number
        * @static
        * @final
        */
        GL_UNPACK_COLORSPACE_CONVERSION_WEBGL: { value: 37443, enumerable: true},
        /**
        * Value 37444
        * @property GL_BROWSER_DEFAULT_WEBGL
        * @type Number
        * @static
        * @final
        */
        GL_BROWSER_DEFAULT_WEBGL: { value: 37444, enumerable: true},
        /**
        * Value 34042
        * @property GL_UNSIGNED_INT_24_8_WEBGL
        * @type Number
        * @static
        * @final
        */
        GL_UNSIGNED_INT_24_8_WEBGL: { value: 34042, enumerable: true},
        /**
        * Value 34046
        * @property GL_TEXTURE_MAX_ANISOTROPY_EXT
        * @type Number
        * @static
        * @final
        */
        GL_TEXTURE_MAX_ANISOTROPY_EXT: { value: 34046, enumerable: true},
        /**
        * Value 34047
        * @property GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT
        * @type Number
        * @static
        * @final
        */
        GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT: { value: 34047, enumerable: true},
        /**
        * Value 34229
        * @property GL_VERTEX_ARRAY_BINDING_OES
        * @type Number
        * @static
        * @final
        */
        GL_VERTEX_ARRAY_BINDING_OES: { value: 34229, enumerable: true},
        /**
        * Value 35723
        * @property GL_FRAGMENT_SHADER_DERIVATIVE_HINT_OES
        * @type Number
        * @static
        * @final
        */
        GL_FRAGMENT_SHADER_DERIVATIVE_HINT_OES: { value: 35723, enumerable: true},
        /**
        * Value 36193
        * @property GL_HALF_FLOAT_OES
        * @type Number
        * @static
        * @final
        */
        GL_HALF_FLOAT_OES: { value: 36193, enumerable: true},
        /**
        * Value 36064
        * @property GL_COLOR_ATTACHMENT0
        * @type Number
        * @static
        * @final
        */
        GL_COLOR_ATTACHMENT0: { value: 36064, enumerable: true},
        /**
        * Value 36065
        * @property GL_COLOR_ATTACHMENT1
        * @type Number
        * @static
        * @final
        */
        GL_COLOR_ATTACHMENT1: { value: 36065, enumerable: true},
        /**
        * Value 36066
        * @property GL_COLOR_ATTACHMENT2
        * @type Number
        * @static
        * @final
        */
        GL_COLOR_ATTACHMENT2: { value: 36066, enumerable: true},
        /**
        * Value 36067
        * @property GL_COLOR_ATTACHMENT3
        * @type Number
        * @static
        * @final
        */
        GL_COLOR_ATTACHMENT3: { value: 36067, enumerable: true},
        /**
        * Value 36068
        * @property GL_COLOR_ATTACHMENT4
        * @type Number
        * @static
        * @final
        */
        GL_COLOR_ATTACHMENT4: { value: 36068, enumerable: true},
        /**
        * Value 36069
        * @property GL_COLOR_ATTACHMENT5
        * @type Number
        * @static
        * @final
        */
        GL_COLOR_ATTACHMENT5: { value: 36069, enumerable: true},
        /**
        * Value 36070
        * @property GL_COLOR_ATTACHMENT6
        * @type Number
        * @static
        * @final
        */
        GL_COLOR_ATTACHMENT6: { value: 36070, enumerable: true},
        /**
        * Value 36071
        * @property GL_COLOR_ATTACHMENT7
        * @type Number
        * @static
        * @final
        */
        GL_COLOR_ATTACHMENT7: { value: 36071, enumerable: true},
        /**
        * Value 36072
        * @property GL_COLOR_ATTACHMENT8
        * @type Number
        * @static
        * @final
        */
        GL_COLOR_ATTACHMENT8: { value: 36072, enumerable: true},
        /**
        * Value 36073
        * @property GL_COLOR_ATTACHMENT9
        * @type Number
        * @static
        * @final
        */
        GL_COLOR_ATTACHMENT9: { value: 36073, enumerable: true},
        /**
        * Value 36074
        * @property GL_COLOR_ATTACHMENT10
        * @type Number
        * @static
        * @final
        */
        GL_COLOR_ATTACHMENT10: { value: 36074, enumerable: true},
        /**
        * Value 36075
        * @property GL_COLOR_ATTACHMENT11
        * @type Number
        * @static
        * @final
        */
        GL_COLOR_ATTACHMENT11: { value: 36075, enumerable: true},
        /**
        * Value 36076
        * @property GL_COLOR_ATTACHMENT12
        * @type Number
        * @static
        * @final
        */
        GL_COLOR_ATTACHMENT12: { value: 36076, enumerable: true},
        /**
        * Value 36077
        * @property GL_COLOR_ATTACHMENT13
        * @type Number
        * @static
        * @final
        */
        GL_COLOR_ATTACHMENT13: { value: 36077, enumerable: true},
        /**
        * Value 36078
        * @property GL_COLOR_ATTACHMENT14
        * @type Number
        * @static
        * @final
        */
        GL_COLOR_ATTACHMENT14: { value: 36078, enumerable: true},
        /**
        * Value 36079
        * @property GL_COLOR_ATTACHMENT15
        * @type Number
        * @static
        * @final
        */
        GL_COLOR_ATTACHMENT15: { value: 36079, enumerable: true},
        /**
        * Value 34853
        * @property GL_DRAW_BUFFER0
        * @type Number
        * @static
        * @final
        */
        GL_DRAW_BUFFER0: { value: 34853, enumerable: true},
        /**
        * Value 34854
        * @property GL_DRAW_BUFFER1
        * @type Number
        * @static
        * @final
        */
        GL_DRAW_BUFFER1: { value: 34854, enumerable: true},
        /**
        * Value 34855
        * @property GL_DRAW_BUFFER2
        * @type Number
        * @static
        * @final
        */
        GL_DRAW_BUFFER2: { value: 34855, enumerable: true},
        /**
        * Value 34856
        * @property GL_DRAW_BUFFER3
        * @type Number
        * @static
        * @final
        */
        GL_DRAW_BUFFER3: { value: 34856, enumerable: true},
        /**
        * Value 34857
        * @property GL_DRAW_BUFFER4
        * @type Number
        * @static
        * @final
        */
        GL_DRAW_BUFFER4: { value: 34857, enumerable: true},
        /**
        * Value 34858
        * @property GL_DRAW_BUFFER5
        * @type Number
        * @static
        * @final
        */
        GL_DRAW_BUFFER5: { value: 34858, enumerable: true},
        /**
        * Value 34859
        * @property GL_DRAW_BUFFER6
        * @type Number
        * @static
        * @final
        */
        GL_DRAW_BUFFER6: { value: 34859, enumerable: true},
        /**
        * Value 34860
        * @property GL_DRAW_BUFFER7
        * @type Number
        * @static
        * @final
        */
        GL_DRAW_BUFFER7: { value: 34860, enumerable: true},
        /**
        * Value 34861
        * @property GL_DRAW_BUFFER8
        * @type Number
        * @static
        * @final
        */
        GL_DRAW_BUFFER8: { value: 34861, enumerable: true},
        /**
        * Value 34862
        * @property GL_DRAW_BUFFER9
        * @type Number
        * @static
        * @final
        */
        GL_DRAW_BUFFER9: { value: 34862, enumerable: true},
        /**
        * Value 34863
        * @property GL_DRAW_BUFFER10
        * @type Number
        * @static
        * @final
        */
        GL_DRAW_BUFFER10: { value: 34863, enumerable: true},
        /**
        * Value 34864
        * @property GL_DRAW_BUFFER11
        * @type Number
        * @static
        * @final
        */
        GL_DRAW_BUFFER11: { value: 34864, enumerable: true},
        /**
        * Value 34865
        * @property GL_DRAW_BUFFER12
        * @type Number
        * @static
        * @final
        */
        GL_DRAW_BUFFER12: { value: 34865, enumerable: true},
        /**
        * Value 34866
        * @property GL_DRAW_BUFFER13
        * @type Number
        * @static
        * @final
        */
        GL_DRAW_BUFFER13: { value: 34866, enumerable: true},
        /**
        * Value 34867
        * @property GL_DRAW_BUFFER14
        * @type Number
        * @static
        * @final
        */
        GL_DRAW_BUFFER14: { value: 34867, enumerable: true},
        /**
        * Value 34868
        * @property GL_DRAW_BUFFER15
        * @type Number
        * @static
        * @final
        */
        GL_DRAW_BUFFER15: { value: 34868, enumerable: true},
        /**
        * Value 36063
        * @property GL_MAX_COLOR_ATTACHMENTS
        * @type Number
        * @static
        * @final
        */
        GL_MAX_COLOR_ATTACHMENTS: { value: 36063, enumerable: true},
        /**
        * Value 34852
        * @property GL_MAX_DRAW_BUFFERS
        * @type Number
        * @static
        * @final
        */
        GL_MAX_DRAW_BUFFERS: { value: 34852, enumerable: true}
    });

    return constants;
});

define('kick/core/EngineSingleton',["./Constants"], function (Constants) {
    
    /* //////// no documentation to hide class /////////
     * Singleton - used to get a reference to the current engine.
     * The static engine property is set when an engine-instance is created.
     * The singleton object is needed to avoid cyclic-dependencies.
     * When used outside the engine, you can use the kick.core.Engine.instance instead.
     * @class EngineSingleton
     * @namespace kick.core
     * @private
     */
    var EngineSingleton = {},
        currentEngine = null;
    /* //////// no documentation to hide class /////////
     * Returns
     * @property engine
     * @type {kick.core.Engine}
     * @default null
     * @static
     */
    Object.defineProperty(EngineSingleton, "engine",
        {
            set: function (newEngine) {
                if (currentEngine !== null && true) {
                    console.log("Engine is created twice in same context.");
                }
                currentEngine = newEngine;
            },
            get: function(){
                if (currentEngine === null && true){
                    console.log("Engine is not initialized yet.");
                }
                return currentEngine;
            }

        });
    Object.freeze(EngineSingleton);

    return EngineSingleton;
});

define('kick/core/Util',["require", "./Constants", "./EngineSingleton"], function (require, Constants, EngineSingleton) {
    

    var ASSERT = true,
        DEBUG = true,
        packIntToFloatArrayBuffer = new ArrayBuffer(4),
        packIntToFloatInt32Buffer = new Uint32Array(packIntToFloatArrayBuffer),
        packIntToFloatUint8Buffer = new Uint8Array(packIntToFloatArrayBuffer),
        Util;


    /**
     * Utility class for miscellaneous functions. The class is static and is shared between multiple instances.
     * @class Util
     * @namespace kick.core
     */
    Util = {
        /**
         * Used for deserializing a configuration (replaces reference objects with actual references)
         * @method deserializeConfig
         * @param {Object} config
         * @param {kick.scene.Scene} scene used for looking up references to gameObjects and components
         */
        deserializeConfig: function (config, scene) {
            var i,
                engine = EngineSingleton.engine,
                destArray,
                ref,
                reftype;
            if (typeof config === 'number') {
                return config;
            }
            if (Array.isArray(config)) {
                destArray = new Array(config.length);
                for (i = 0; i < config.length; i++) {
                    destArray[i] = Util.deserializeConfig(config[i], scene);
                }
                config = destArray;
            } else if (config) {
                ref = config.ref;
                reftype = config.reftype;
                if (reftype) {
                    if (reftype === "project") {
                        config = engine.project.load(ref);
                    } else if (reftype === "gameobject" || reftype === "component") {
                        config = scene.getObjectByUID(ref);
                    } else if (DEBUG) {
                        Util.warn("Unsupported ref type. Expected 'project', 'gameobject' or 'component'");
                    }
                    if (DEBUG && !config){
                        Util.warn("Unable to find "+reftype+" ref "+ref);
                    }
                }
            }
            return config;
        },
        /**
         * @method deepCopy
         * @param {Object} src
         * @param {Array_Classes} passthroughClasses=null Don't attempt to clone object of these classes (uses instanceof operator)
         * @return Object
         */
        deepCopy : function (object, passthroughClasses) {
            var res,
                isPassthrough = false,
                i,
                typeOfValue,
                name;
            passthroughClasses = passthroughClasses || [];

            for (i = 0; i < passthroughClasses.length; i++) {
                if (object instanceof passthroughClasses[i]) {
                    isPassthrough = true;
                    break;
                }
            }

            typeOfValue = typeof object;
            if (isPassthrough) {
                res = object;
            } else if (object === null || typeof (object) === "undefined") {
                res = null;
            } else if (Array.isArray(object) || object.buffer instanceof ArrayBuffer) { // treat typed arrays as normal arrays
                res = [];
                for (i = 0; i < object.length; i++) {
                    res[i] = Util.deepCopy(object[i], passthroughClasses);
                }
            } else if (typeOfValue === "object") {
                res = {};
                for (name in object) {
                    if (object.hasOwnProperty(name)) {
                        res[name] = Util.deepCopy(object[name], passthroughClasses);
                    }
                }
            } else {
                res = object;
            }
            return res;
        },
        /**
         * @method copyStaticPropertiesToObject
         * @param {Object} object
         * @param {Function} type constructor function
         * @static
         */
        copyStaticPropertiesToObject : function (object, type) {
            var name;
            for (name in type) {
                if (type.hasOwnProperty(name)) {
                    Object.defineProperty(object, name, {
                        value: type[name]
                    });
                }
            }
        },
        /**
         * @method hasProperty
         * @param {Object} obj
         * @param {String} prop
         * @return {Boolean}
         * @static
         */
        hasProperty: function (obj, prop) {
            return Object.prototype.hasOwnProperty.call(obj, prop);
        },
        /**
         *
         * @method toCamelCase
         * @param {String} str
         * @param {String} [wordSeparator=""]
         */
        toCamelCase: function (str, wordSeparator) {
            if (!wordSeparator) {
                wordSeparator = "";
            }
            // skip initial underscore
            var i,
                wasLastCharSpace = true,
                charVal,
                resStr = "",
                isSpace;
            for (i = 0; i < str.length; i++) {
                charVal = str.charAt(i);
                if (charVal !== "_") {
                    break;
                }
                resStr += charVal;
            }

            for (; i < str.length; i++) {
                charVal = str.charAt(i);
                isSpace = charVal === '_';
                if (isSpace) {
                    charVal = wordSeparator;
                }
                resStr += wasLastCharSpace ? charVal.toUpperCase() : charVal.toLowerCase();
                wasLastCharSpace = isSpace;
            }
            return resStr;
        },
        /**
         * @method getJSONReference
         * @param {Object} object
         * @return {JSON}
         */
        getJSONReference: function (object) {
            var engine = EngineSingleton.engine;
            if (object === null){
                return null;
            }
            var isGameObject = object instanceof require("kick/scene/GameObject");
            var isComponent = !isGameObject && object.gameObject instanceof require("kick/scene/GameObject");
            if (isComponent || isGameObject) {
                return {
                    ref: engine.getUID(object),
                    name: typeof object.name === 'string'? object.name : "",
                    reftype: isGameObject?"gameobject":"component"
                };
            } else {
                // project type
                return {
                    ref: object.uid,
                    name: object.name,
                    reftype: "project"
                };
            }
        },
        /**
         * @method componentToJSON
         * @param {kick.scene.Component} component
         * @param {String} componentType=component.constructor.name
         * @return {JSON}
         */
        componentToJSON: function(component, componentType) {
            var name,
                engine = EngineSingleton.engine,
                config = {},
                functionReturnType = {},
                res = {
                    type: componentType || component.constructor.name,
                    uid: engine.getUID(component),
                    config:config
                },
                o,
                serializedObject;
            if (DEBUG){
                if (component === EngineSingleton.engine) {
                    Util.fail("Util.componentToJSON parameters has changed to Util.componentToJSON(kick.scene.Component, String)");
                }
            }
            if (res.type === "") {
                Util.fail("Cannot serialize object type. Either provide toJSON function or use explicit function name 'function SomeObject(){}' ");
            }
            var serializeObject = function(o) {
                var result, i, r, typeofO;
                if (Array.isArray(o)) {
                    result = [];
                    for (i=0;i<o.length;i++) {
                        r = serializeObject(o[i]);
                        result.push(r);
                    }
                    return result;
                }
                typeofO = typeof o;
                if (typeofO !== 'function') {
                    if (o && o.buffer instanceof ArrayBuffer) {
                        // is typed array
                        return Util.typedArrayToArray(o);
                    } else if (typeofO === 'object') {
                        return Util.getJSONReference(o);
                    } else {
                        return o;
                    }
                }
                return functionReturnType;
            };
            // init config object
            for (name in component) {
                if (Util.hasProperty(component,name) && name !== "gameObject") {
                    o = component[name];
                    serializedObject = serializeObject(o);
                    if (serializedObject !== functionReturnType) {
                        config[name] = serializedObject;
                    }
                }
            }
            return res;
        },
        /**
         * For each non function attribute in config, set the attribute on object.
         * @method applyConfig
         * @param {Object} object
         * @param {Object} config
         * @param {Array_String} excludeFilter
         * @static
         */
        applyConfig: function (object, config, excludeFilter) {
            var contains = Util.contains,
                hasProperty = Util.hasProperty;
            config = config || {};
            excludeFilter = excludeFilter || [];
            for (var name in config) {
                if (typeof config[name] !== 'function' && !contains(excludeFilter, name) && hasProperty(object,name)) {
                    object[name] = config[name];
                }
            }
            // force setting uid
            if (config.uid && config.uid !== object.uid) {
                object.uid = config.uid;
            }
        },
        /**
         * Reads a parameter from a url string.
         * @method getParameter
         * @param {String} url
         * @param {String} parameterName
         * @return {String} parameter value or null if not found.
         * @static
         */
        getParameter: function (url, parameterName) {
            var regexpStr = "[\\?&]" + parameterName + "=([^&#]*)",
                regexp = new RegExp(regexpStr),
                res = regexp.exec(url);
            if( res === null ) {
                return null;
            } else {
                return res[1];
            }
        },
        /**
         * Reads a int parameter from a url string.
         * @method getParameterInt
         * @param {String} url
         * @param {String} parameterName
         * @return {String} parameter value or null if not found.
         * @static
         */
        getParameterInt: function(url, parameterName, notFoundValue) {
            var res = Util.getParameter(url,parameterName);
            if (res === null) {
                return notFoundValue;
            } else {
                return parseInt(res, 10);
            }
        },
        /**
         * Reads a float parameter from a url string.
         * @method getParameterInt
         * @param {String} url
         * @param {String} parameterName
         * @return {String} parameter value or null if not found.
         * @static
         */
        getParameterFloat: function(url, parameterName, notFoundValue) {
            var res = Util.getParameter(url,parameterName);
            if (res === null) {
                return notFoundValue;
            } else {
                return parseFloat(res);
            }
        },
        /**
         * Scales the image by drawing the image on a canvas object.
         * @method scaleImage
         * @param {Image}imageObj
         * @param {Number} newWidth
         * @param {Number} newHeight
         * @return {Canvas} return a Canvas object (acts as a image)
         * @static
         */
        scaleImage: function (imageObj, newWidth, newHeight) {
            // from http://www.khronos.org/webgl/wiki/WebGL_and_OpenGL_Differences
            var canvas = document.createElement("canvas"),
                ctx;
            canvas.width = newWidth;
            canvas.height = newHeight;
            ctx = canvas.getContext("2d");
            ctx.drawImage(imageObj,
                0, 0, imageObj.width, imageObj.height,
                0, 0, canvas.width, canvas.height);
            return canvas;
        },
        /**
         * Converts a typed array to a number array
         * @method typedArrayToArray
         * @static
         * @param {TypedArray} typedArray
         * @return {Array_Number}
         */
        typedArrayToArray: function (typedArray) {
            var length = typedArray.length,
                res = new Array(length),
                i;
            for (i = 0; i < length; i++){
                res[i] = typedArray[i];
            }
            return res;
        },

        /**
         * Remove one element from an array - either the first instance or all instances
         * @method removeElementFromArray
         * @static
         * @param {Array} array
         * @param {Object} removeValue value to be deleted
         * @param {boolean} deleteAll  deletaAll objects (or exit function after first deletion)
         * @return {boolean} elementRemoved
         */
        removeElementFromArray: function (array, removeValue, deleteAll) {
            var elementRemoved = false,
                i;
            for(i = array.length-1; i >= 0; i--) {
                if(array[i] === removeValue) {
                    elementRemoved = true;
                    array.splice(i, 1);
                    if (!deleteAll) {
                        break;
                    }
                }
            }
            return elementRemoved;
        },

        /**
         * Removes all values from one array in another array
         * @method removeElementsFromArray
         * @static
         * @param array {Array}
         * @param removeValues {Object} value to be deleted
         */
        removeElementsFromArray: function (array, removeValues) {
            var i,j;
            for (i = array.length-1; i >= 0; i--) {
                for (j = removeValues.length - 1; j >= 0; j--) {
                    if (array[i] === removeValues[j]) {
                        array.splice(i, 1);
                    }
                }
            }
        },
        /**
         * Insert the element into a sorted array
         * @static
         * @method insertSorted
         * @param {Object} element
         * @param {Array} sortedArray
         * @param {Function} [sortFunc=kick.core.Util.numberSortFunction] has the signature foo(obj1,obj2) returns Number.
         */
        insertSorted : function (element,sortedArray,sortFunc) {
            var i;
            if (!sortFunc) {
                sortFunc = Util.numberSortFunction;
            }
            // assuming that the array is relative small
            for (i = sortedArray.length-1; i >= 0; i--) {
                if (sortFunc(sortedArray[i],element) <= 0) {
                    sortedArray.splice(i+1, 0, element);
                    return;
                }
            }
            sortedArray.unshift(element);
        },
        /**
         * Returns a-b
         * @static
         * @method numberSortFunction
         * @param {Number} a
         * @param {Number} b
         * @return {Number} a-b
         */
        numberSortFunction : function (a, b) {
            return a - b;
        },
        /**
         * Loops through array and return true if any array element strict equals the element.
         * This uses the === to compare the two elements.
         * @static
         * @method contains
         * @param {Array} array
         * @param {Object}element
         * @return {boolean} array contains element
         */
        contains : function (array, element) {
            var i;
            for (i = array.length - 1; i >= 0; i--) {
                if (array[i] === element) {
                    return true;
                }
            }
            return false;
        },
        /**
         * Packs a Uint32 into a kick.math.Vec4
         * @static
         * @method uint32ToVec4
         * @param {Number} uint32
         * @param {kick.math.Vec4} dest
         * @return {kick.math.Vec4}
         */
        uint32ToVec4 : function(uint32, dest) {
            var i;
            if (!dest) {
                dest = new Float32Array(4);
            }
            packIntToFloatInt32Buffer[0] = uint32;
            for (i = 0; i < 4; i++) {
                dest[i] = packIntToFloatUint8Buffer[i] / 255;
            }
            return dest;
        },
        /**
         * Unpacks a kick.math.Vec4 into a Uint32
         * @static
         * @method vec4ToUint32
         * @param {kick.math.Vec4} vec4
         */
        vec4ToUint32 : function(vec4) {
            var i;
            for (i = 0; i < 4; i++) {
                packIntToFloatUint8Buffer[i] = vec4[i] * 255;
            }
            return packIntToFloatInt32Buffer[0];
        },
        /**
         * Unpacks an array of uint8 into a Uint32
         * @static
         * @method vec4uint8ToUint32
         * @param {Array_Number} vec4uint8
         */
        vec4uint8ToUint32 : function (vec4uint8) {
            var i;
            for (i = 0; i < 4; i++){
                packIntToFloatUint8Buffer[i] = vec4uint8[i];
            }
            return packIntToFloatInt32Buffer[0];
        },
        /**
         * Supports up to 3 byte UTF-8 encoding (including Basic Multilingual Plane)
         * @static
         * @method utf8Encode
         * @param {String} str
         * @return Uint8Array
         */
        utf8Encode:function (str) {
            var res = [],
                i,
                charCode;
            for (i = 0; i < str.length; i++) {
                charCode = str.charCodeAt(i);
                if (charCode < 0x007F) {
                    res.push(charCode);
                } else if (charCode <= 0x07FF) {
                    res.push(0xC0 + (charCode >> 6));
                    res.push(0x80 + (charCode & 0x3F));
                } else if (charCode <= 0xFFFF) {
                    res.push(0xE0 + (charCode >> 12));
                    res.push(0x80 + ((charCode >> 6) & 0x3F));
                    res.push(0x80 + (charCode & 0x3F));
                } else {
                    if (ASSERT) {
                        Util.fail("Unsupported character. Charcode " + charCode);
                    }
                }
            }
            return new Uint8Array(res);
        },
        /**
         * Removes all properties (methods and attributes) of an object
         * @static
         * @method removeAllProperties
         * @param {Object} obj
         */
        removeAllProperties: function (obj) {
            for (var name in obj) {
                if (obj.hasOwnProperty(name)) {
                    delete obj[name];
                }
            }
        },
        /**
         * Supports up to 3 byte UTF-8 encoding (including Basic Multilingual Plane)
         * @static
         * @method utf8Decode
         * @param {Uint8Array} bytes
         * @return String
         */
        utf8Decode: function (bytes) {
            var str = "",
                i,
                byteVal,
                byte2,
                byte3,
                charValue;
            for (i = 0; i < bytes.length; i++) {
                byteVal = bytes[i];
                if ((byteVal & 0x80) === 0) { // Bytes 0xxxxxxx
                    str += String.fromCharCode(byteVal);
                } else if ((byteVal & 0xE0) === 0xC0) { // Bytes 110xxxxx
                    i++;
                    byte2 = bytes[i];
                    byteVal = (byteVal & 0x1F) << 6;
                    byte2 = byte2 & 0x3F;
                    charValue = byteVal + byte2;
                    str += String.fromCharCode(charValue);
                } else if ((byteVal & 0xF0) === 0xE0) { // Bytes 1110xxxx
                    i++;
                    byte2 = bytes[i];
                    i++;
                    byte3 = bytes[i];
                    byteVal = (byteVal & 0x1F) << 12;
                    byte2 = (byte2 & 0x3F) << 6;
                    byte3 = byte3 & 0x3F;
                    charValue = byteVal + byte2 + byte3;
                    str += String.fromCharCode(charValue);
                } else {
                    if (ASSERT) {
                        Util.fail("Unsupported encoding");
                    }
                }
            }
            return str;
        },
        /**
         * @static
         * @method isPowerOfTwo
         * @param {Number} x value
         * @return {Number}
         */
        isPowerOfTwo: function (x) {
            return (x & (x - 1)) === 0;
        },
        /**
         * @static
         * @method nextHighestPowerOfTwo
         * @param {Number} x value
         * @return {Number}
         */
        nextHighestPowerOfTwo: function (x) {
            var i;
            --x;
            for (i = 1; i < 32; i <<= 1) {
                x = x | x >> i;
            }
            return x + 1;
        },
        /**
         * @static
         * @method convertSubMeshesToTriangleIndices
         * @param {Array} subMeshes array of array of indices
         * @param {Number} primitiveType such as 4 or 5
         * @param {Boolean} removeDegenerate remove degenerate triangles
         * @return {Array|null} triangleIndices or null if not possible to convert
         */
        convertSubMeshesToTriangleIndices: function (subMeshes, primitiveType, removeDegenerate){
            var result = [],
                i,
                subResult;
            for (i=0;i<subMeshes.length;i++){
                subResult = Util.convertToTriangleIndices(subMeshes[i], primitiveType, removeDegenerate);
                if (!subResult) {
                    return null;
                }
                result = result.concat(Util.typedArrayToArray(subResult));
            }
            return result;
        },
        /**
         * @static
         * @method convertToTriangleIndices
         * @param {Array} indices index array
         * @param {Number} primitiveType such as Constants.GL\_TRIANGLES or Constants.GL\_TRIANGLE\_STRIP
         * @param {Boolean} removeDegenerate remove degenerate triangles
         * @return {Array|null} triangleIndices or null if not possible to convert
         */
        convertToTriangleIndices: function (indices, primitiveType, removeDegenerate) {
            var i,
                even = 1,
                trianleIndices = [indices[0], indices[1], indices[2]];
            if (primitiveType === 4){
                return indices;
            } else if (primitiveType === 6){
                var res = [indices[0],indices[1],indices[2]];
                for (i = 3; i  <indices.length; i++) {
                    res.push(indices[0]);
                    res.push(indices[i-1]);
                    res.push(indices[i]);
                }
                return res;
            } else if (primitiveType !== 5){
                return null;
            }

            for (i = 3; i < indices.length; i++) {
                if (removeDegenerate){
                    if (indices[i-1] === indices[i] ||
                        indices[i-2] === indices[i] ||
                        indices[i-1] === indices[i-2]) {
                        continue;
                    }
                }
                if (i % 2 === even) {
                    trianleIndices.push(indices[i-1]);
                    trianleIndices.push(indices[i-2]);
                    trianleIndices.push(indices[i]);
                } else {
                    trianleIndices.push(indices[i-2]);
                    trianleIndices.push(indices[i-1]);
                    trianleIndices.push(indices[i]);
                }
            }
            return trianleIndices;
        },
        /**
         * Invokes debugger and logs a warning
         * @method warn
         * @static
         */
        warn:function (message) {
            debugger;
            console.log(message);
        },
        /**
         * Invokes debugger and logs an error
         * @method fail
         * @static
         */
        fail:function (message) {
            debugger;
            console.error(message);
        }
    };

    return Util;
});

define('kick/core/ChunkData',["./Util", "./Constants"], function (Util, constants) {
    

    var utf8Decode = Util.utf8Decode,
        utf8Encode = Util.utf8Encode,
        DEBUG = true,
        fail = Util.fail,
        paddingArray = new Uint8Array(4);

    /**
     * Chunk data format object
     * @class ChunkData
     * @namespace kick.core
     * @constructor
     */
    return function () {
        var MAGIC_NUMBER = 0xF001,
            VERSION_NUMBER = 1,
            Float32ArrayType = 1,
            Float64ArrayType = 2,
            Int16ArrayType = 3,
            Int32ArrayType = 4,
            Int8ArrayType = 5,
            Uint16ArrayType = 6,
            Uint32ArrayType = 7,
            Uint8ArrayType = 8,
            Chunk = function (chunkId, chunkType, chunkDataLength, data) {
                var thisObj = this;
                this.chunkId = chunkId;
                this.chunkType = chunkType;
                this.chunkDataLength = chunkDataLength; // contains the actual data
                this.data = data; // data is assumed to have the length
                Object.defineProperties(this, {
                    paddingSize: {
                        get: function () {
                            var dataSize = thisObj.data.length * thisObj.data.BYTES_PER_ELEMENT,
                                dataSizeMod4 = dataSize % 8;
                            if (dataSizeMod4) {
                                return 8 - dataSizeMod4;
                            }
                            return 0;
                        }
                    },
                    paddingData: {
                        get: function () {
                            return paddingArray.subarray(0, thisObj.paddingSize);
                        }
                    }
                });
            },
            thisObj = this,
            chunks = [],
            /**
             * Return header size in bytes
             * @method getHeaderSize
             * @private
             */
            getHeaderSize = function () {
                return 2 + // magic number
                    2 + // version number
                    4; // number of chunks
            },
            /**
             * Return chunks size in bytes
             * @method
             * @private
             */
            getChunksSize = function () {
                var sum = 0,
                    chunkHeaderLength = 8,
                    i;
                for (i = 0; i < chunks.length; i++) {
                    sum += chunks[i].chunkDataLength +
                        chunkHeaderLength +
                        chunks[i].paddingSize;
                }
                return sum;
            },
            getTypeEnum = function (array) {
                if (array instanceof Float32Array) { return Float32ArrayType; }
                if (array instanceof Float64Array) { return Float64ArrayType; }
                if (array instanceof Int16Array) { return Int16ArrayType; }
                if (array instanceof Int32Array) { return Int32ArrayType; }
                if (array instanceof Int8Array) { return Int8ArrayType; }
                if (array instanceof Uint16Array) { return Uint16ArrayType; }
                if (array instanceof Uint8Array) { return Uint8ArrayType; }
                return null;
            },
            getTypeClass = function (id) {
                if (id === Float32ArrayType) { return Float32Array; }
                if (id === Float64ArrayType) { return Float64Array; }
                if (id === Int16ArrayType) { return Int16Array; }
                if (id === Int32ArrayType) { return Int32Array; }
                if (id === Int8ArrayType) { return Int8Array; }
                if (id === Uint16ArrayType) { return Uint16Array; }
                if (id === Uint8ArrayType) { return Uint8Array; }
                return null;
            };
        /**
         * Size of chunkdata in bytes. Note that the data is added padding so it always fit into a double array.
         * @method getSize
         */
        this.getSize = function () {
            var size = getHeaderSize() + getChunksSize(),
                remainder = size % 8;
            if (remainder !== 0) {
                size += 8 - remainder;
            }
            return size;
        };

        /**
         * @method serialize
         * @return ArrayBuffer
         */
        this.serialize = function () {
            var output = new ArrayBuffer(thisObj.getSize()),
                byteOffset = 0,
                uint8View = new Uint8Array(output, 0),
                uint16View = new Uint16Array(output, byteOffset),
                uint32View,
                i,
                ViewType,
                view;
            uint16View[0] = MAGIC_NUMBER;
            uint16View[1] = VERSION_NUMBER;
            byteOffset += 4;
            uint32View = new Uint32Array(output, byteOffset);
            uint32View[0] = chunks.length;
            byteOffset += 4;
            for (i = 0; i < chunks.length; i++) {
                uint16View = new Uint16Array(output, byteOffset);
                uint16View[0] = chunks[i].chunkId;
                uint16View[1] = chunks[i].chunkType;
                byteOffset += 4;
                uint32View = new Uint32Array(output, byteOffset);
                uint32View[0] = chunks[i].chunkDataLength;
                byteOffset += 4;
                ViewType = getTypeClass(chunks[i].chunkType);
                view = new ViewType(output);
                view.set(chunks[i].data, byteOffset / view.BYTES_PER_ELEMENT);
                byteOffset += chunks[i].chunkDataLength;

                uint8View.set(chunks[i].paddingData, byteOffset); // write padding data
                byteOffset += chunks[i].paddingSize;
            }
            return output;
        };

        /**
         * @method get
         * @param {Number} chunkid
         * @return TypedArrayView[Number]
         */
        this.get = function (chunkid) {
            var i;
            for (i = 0; i < chunks.length; i++) {
                if (chunks[i].chunkId === chunkid) {
                    return chunks[i].data;
                }
            }
            return null;
        };
        /**
         * @method getString
         * @param {Number} chunkid
         * @return String or null
         */
        this.getString = function (chunkid) {
            var value = thisObj.get(chunkid);
            if (value) {
                return utf8Decode(value);
            }
            return null;
        };

        /**
         * @method getNumber
         * @param {Number} chunkid
         * @return String or null
         */
        this.getNumber = function (chunkid) {
            var value = thisObj.get(chunkid);
            if (value) {
                return value[0];
            }
            return null;
        };

        /**
         * @method getArrayBuffer
         * @param {Number} chunkid
         * @return ArrayBuffer  or null if not found
         */
        this.getArrayBuffer = function (chunkid) {
            var value = thisObj.get(chunkid),
                arrayBuffer,
                res;
            if (value) {
                arrayBuffer = new ArrayBuffer(value.length * value.BYTES_PER_ELEMENT);
                res = new Uint8Array(arrayBuffer);
                res.set(value);
                return arrayBuffer;
            }
            return null;
        };

        /**
         * @method remove
         * @param {Number} chunkid
         * @return Boolean true when deleted
         */
        this.remove = function (chunkid) {
            var i;
            for (i = 0; i < chunks.length; i++) {
                if (chunks[i].chunkId === chunkid) {
                    chunks = chunks.splice(i, 1);
                    return true;
                }
            }
            return false;
        };

        /**
         * @method setString
         * @param {Number} chunkId
         * @param {String} str
         */
        this.setString = function (chunkId, str) {
            var array = utf8Encode(str);
            thisObj.set(chunkId, array);
        };

        /**
         * Uses a Float32Array for storing the number. Note that potentially precision can get lost.
         * @method setNumber
         * @param {Number} chunkId
         * @param {Number} num
         */
        this.setNumber = function (chunkId, num) {
            var array = new Float32Array([num]);
            thisObj.set(chunkId, array);
        };

        /**
         * @method setArrayBuffer
         * @param {Number} chunkId
         * @param {ArrayBuffer} arrayBuffer
         */
        this.setArrayBuffer = function (chunkId, arrayBuffer) {
            thisObj.set(chunkId, new Uint8Array(arrayBuffer));
        };

        /**
         * Note that this method saves a reference to the array (it does not copy data)
         * @method set
         * @param {Number} chunkId
         * @param {TypedArrayView} array
         */
        this.set = function (chunkId, array) {
            thisObj.remove(chunkId);
            var chunkType = getTypeEnum(array),
                lengthBytes;
            if (chunkType) {
                lengthBytes = array.length * array.BYTES_PER_ELEMENT;
                chunks.push(new Chunk(chunkId, chunkType, lengthBytes, array));
            } else if (DEBUG) {
                fail("Unsupported array type");
            }
        };

        /**
         * Loads the binary data into the object
         * @method deserialize
         * @param {ArrayBuffer} binaryData
         * @return {boolean} success
         */
        this.deserialize = function (binaryData) {
            if (!(binaryData instanceof ArrayBuffer)) {
                if (DEBUG) {
                    fail("binaryData is not instanceof ArrayBuffer");
                }
                return false;
            }
            var newChunks = [],
                byteOffset = 0,
                uint16View = new Uint16Array(binaryData, byteOffset),
                uint32View,
                chunksLength,
                i,
                chunkId,
                chunkType,
                chunkDataLength,
                DataType,
                data,
                chunk;
            if (uint16View[0] !== MAGIC_NUMBER || uint16View[1] !== VERSION_NUMBER) {
                if (DEBUG) {
                    if (uint16View[0] !== MAGIC_NUMBER) {
                        fail("Invalid magic number");
                    } else {
                        fail("Unsupported version number");
                    }
                }
                return false;
            }
            byteOffset += 4;
            uint32View = new Uint32Array(binaryData, byteOffset);
            chunksLength = uint32View[0];
            byteOffset += 4;
            for (i = 0; i < chunksLength; i++) {
                uint16View = new Uint16Array(binaryData, byteOffset);
                chunkId = uint16View[0];
                chunkType = uint16View[1];
                byteOffset += 4;
                uint32View = new Uint32Array(binaryData, byteOffset);
                chunkDataLength = uint32View[0];
                byteOffset += 4;
                DataType = getTypeClass(chunkType);
                data = new DataType(binaryData, byteOffset, chunkDataLength / DataType.BYTES_PER_ELEMENT);
                chunk = new Chunk(chunkId, chunkType, chunkDataLength, data);
                newChunks.push(chunk);
                byteOffset += chunkDataLength;
                byteOffset += chunk.paddingSize; // skip padding data
            }
            chunks = newChunks;
            return true;
        };
    };
});

define('kick/math/Vec4',["kick/core/Constants"], function (constants) {
    
    var wrapArray = function (array, length) {
        var i,
            index = 0,
            count = array.length / length,
            res = [];
        for (i = 0; i < count; i++, index += length) {
            res[i] = array.subarray(index, index + length);
        }
        return res;
    };

    /**
     * Vec4 - 4 Dimensional Vector<br>
     * Note: To perform vec3 functions on vec4, simply call the vec3 functions<br>
     * @class Vec4
     * @namespace kick.math
     */
    return {
        /**
         * Create a continuous array in memory mapped to vec4.
         *
         * Example
         * @example
         *     var ref = {};
         *     var v = kick.math.Vec4.array(2,ref);
         *     v[1][1] = 1;
         *     ref.mem[5] == v[1][1];
         *
         * Will be layout like this:
         * @example
         *     [vec4][vec4] = [0][1][2][3][4][5][6][7]
         *
         * @method array
         * @param {Number} count Number of vec 3 to be layout in memory
         * @param {Object} ref Optional, if set a memory reference is set to ref.mem
         * @return {kick.math.Vec3} New vec3
         * @static
         */
        array: function (count, ref) {
            var memory = new Float32Array(count * 4);
            if (ref) {
                ref.mem = memory;
            }
            return wrapArray(memory, 4);
        },

        /**
         * Wraps a Float32Array with multiple vec4 arrays. For instance if you have colors defined in a single
         * Float32Array, but need to do vector operations on the elements of the array, instead of copying data out of the
         * Float32Array, wrapArray will give you access to the same data.
         * <br>
         * Example:<br>
         * @example
         *     function averageColor(float32arrayColor){
         *         var sum = vec4.create(),
         *             wrappedArray = vec4.wrapArray(float32arrayColor),
         *             weigth = 1.0/wrappedArray;
         *         for (var i=0;i  &lt; wrappedArray.length;i++){
         *             vec4.add(sum,wrappedArray[i]);
         *         }
         *         return vec4.multiply(sum, sum, [weight, weight, weight, weight]);
         *     }
         * @method wrapArray
         * @param {Float32Array} array
         * @return {Array_kick.math.Vec4}
         * @static
         */
        wrapArray: function (array) {
            return wrapArray(array, 4);
        },


        /**
         * Creates a new, empty vec4
         *
         * @method create
         * @return {kick.math.Vec4} New vec4
         * @static
         */
        create: function () {
            return new Float32Array(4);
        },

        /**
         * Creates a new vec4 initialized with values from an existing vector
         *
         * @method clone
         * @param {kick.math.Vec4} a vector to clone
         * @return {kick.math.Vec4} a new 4D vector
         * @static
         */
        clone: function (a) {
            var out = new Float32Array(4);
            out[0] = a[0];
            out[1] = a[1];
            out[2] = a[2];
            out[3] = a[3];
            return out;
        },

        /**
         * Creates a new vec4 initialized with the given values
         *
         * @method fromValues
         * @param {Number} x X component
         * @param {Number} y Y component
         * @param {Number} z Z component
         * @param {Number} w W component
         * @return {kick.math.Vec4} a new 4D vector
         * @static
         */
        fromValues: function (x, y, z, w) {
            var out = new Float32Array(4);
            out[0] = x;
            out[1] = y;
            out[2] = z;
            out[3] = w;
            return out;
        },

        /**
         * Copy the values from one vec4 to another
         *
         * @method copy
         * @param {kick.math.Vec4} out the receiving vector
         * @param {kick.math.Vec4} a the source vector
         * @return {kick.math.Vec4} out
         * @static
         */
        copy: function (out, a) {
            out[0] = a[0];
            out[1] = a[1];
            out[2] = a[2];
            out[3] = a[3];
            return out;
        },

        /**
         * Set the components of a vec4 to the given values
         *
         * @method set
         * @param {kick.math.Vec4} out the receiving vector
         * @param {Number} x X component
         * @param {Number} y Y component
         * @param {Number} z Z component
         * @param {Number} w W component
         * @return {kick.math.Vec4} out
         * @static
         */
        set: function (out, x, y, z, w) {
            out[0] = x;
            out[1] = y;
            out[2] = z;
            out[3] = w;
            return out;
        },

        /**
         * Adds two vec4's
         *
         * @method add
         * @param {kick.math.Vec4} out the receiving vector
         * @param {kick.math.Vec4} a the first operand
         * @param {kick.math.Vec4} b the second operand
         * @return {kick.math.Vec4} out
         * @static
         */
        add: function (out, a, b) {
            out[0] = a[0] + b[0];
            out[1] = a[1] + b[1];
            out[2] = a[2] + b[2];
            out[3] = a[3] + b[3];
            return out;
        },


        /**
         * Subtracts two vec4's
         * @method subtract
         * @param {kick.math.Vec4} out the receiving vector
         * @param {kick.math.Vec4} a the first operand
         * @param {kick.math.Vec4} b the second operand
         * @return {kick.math.Vec4} out
         * @static
         */
        subtract: function (out, a, b) {
            out[0] = a[0] - b[0];
            out[1] = a[1] - b[1];
            out[2] = a[2] - b[2];
            out[3] = a[3] - b[3];
            return out;
        },


        /**
         * Multiplies two vec4's
         * @method multiply
         * @param {kick.math.Vec4} out the receiving vector
         * @param {kick.math.Vec4} a the first operand
         * @param {kick.math.Vec4} b the second operand
         * @return {kick.math.Vec4} out
         * @static
         */
        multiply: function (out, a, b) {
            out[0] = a[0] * b[0];
            out[1] = a[1] * b[1];
            out[2] = a[2] * b[2];
            out[3] = a[3] * b[3];
            return out;
        },


        /**
         * Divides two vec4's
         *
         * @method divide
         * @param {kick.math.Vec4} out the receiving vector
         * @param {kick.math.Vec4} a the first operand
         * @param {kick.math.Vec4} b the second operand
         * @return {kick.math.Vec4} out
         * @static
         */
        divide: function (out, a, b) {
            out[0] = a[0] / b[0];
            out[1] = a[1] / b[1];
            out[2] = a[2] / b[2];
            out[3] = a[3] / b[3];
            return out;
        },

        /**
         * Returns the minimum of two vec4's
         *
         * @method min
         * @param {kick.math.Vec4} out the receiving vector
         * @param {kick.math.Vec4} a the first operand
         * @param {kick.math.Vec4} b the second operand
         * @return {kick.math.Vec4} out
         * @static
         */
        min: function (out, a, b) {
            out[0] = Math.min(a[0], b[0]);
            out[1] = Math.min(a[1], b[1]);
            out[2] = Math.min(a[2], b[2]);
            out[3] = Math.min(a[3], b[3]);
            return out;
        },

        /**
         * Returns the maximum of two vec4's
         *
         * @method max
         * @param {kick.math.Vec4} out the receiving vector
         * @param {kick.math.Vec4} a the first operand
         * @param {kick.math.Vec4} b the second operand
         * @return {kick.math.Vec4} out
         * @static
         */
        max: function (out, a, b) {
            out[0] = Math.max(a[0], b[0]);
            out[1] = Math.max(a[1], b[1]);
            out[2] = Math.max(a[2], b[2]);
            out[3] = Math.max(a[3], b[3]);
            return out;
        },

        /**
         * Scales a vec4 by a scalar number
         *
         * @method scale
         * @param {kick.math.Vec4} out the receiving vector
         * @param {kick.math.Vec4} a the vector to scale
         * @param {Number} b amount to scale the vector by
         * @return {kick.math.Vec4} out
         * @static
         */
        scale: function (out, a, b) {
            out[0] = a[0] * b;
            out[1] = a[1] * b;
            out[2] = a[2] * b;
            out[3] = a[3] * b;
            return out;
        },

        /**
         * Calculates the euclidian distance between two vec4's
         *
         * @method distance
         * @param {kick.math.Vec4} a the first operand
         * @param {kick.math.Vec4} b the second operand
         * @return {Number} distance between a and b
         * @static
         */
        distance: function (a, b) {
            var x = b[0] - a[0],
                y = b[1] - a[1],
                z = b[2] - a[2],
                w = b[3] - a[3];
            return Math.sqrt(x * x + y * y + z * z + w * w);
        },

        /**
         * Calculates the squared euclidian distance between two vec4's
         *
         * @method squaredDistance
         * @param {kick.math.Vec4} a the first operand
         * @param {kick.math.Vec4} b the second operand
         * @return {Number} squared distance between a and b
         * @static
         */
        squaredDistance: function (a, b) {
            var x = b[0] - a[0],
                y = b[1] - a[1],
                z = b[2] - a[2],
                w = b[3] - a[3];
            return x * x + y * y + z * z + w * w;
        },

        /**
         * Calculates the length of a vec4
         *
         * @method length
         * @param {kick.math.Vec4} a vector to calculate length of
         * @return {Number} length of a
         * @static
         */
        length: function (a) {
            var x = a[0],
                y = a[1],
                z = a[2],
                w = a[3];
            return Math.sqrt(x * x + y * y + z * z + w * w);
        },

        /**
         * Calculates the squared length of a vec4
         *
         * @method squaredLength
         * @param {kick.math.Vec4} a vector to calculate squared length of
         * @return {Number} squared length of a
         * @static
         */
        squaredLength: function (a) {
            var x = a[0],
                y = a[1],
                z = a[2],
                w = a[3];
            return x * x + y * y + z * z + w * w;
        },

        /**
         * Negates the components of a Vec4
         * @method negate
         * @param {kick.math.Vec4} out the receiving vector
         * @param {kick.math.Vec4} a vector to negate
         * @return {kick.math.Vec4} out
         * @static
         */
        negate: function (out, a) {
            out[0] = -a[0];
            out[1] = -a[1];
            out[2] = -a[2];
            out[3] = -a[3];
            return out;
        },

        /**
         * Normalize a vec4
         *
         * @method normalize
         * @param {kick.math.Vec4} out the receiving vector
         * @param {kick.math.Vec4} a vector to normalize
         * @return {kick.math.Vec4} out
         * @static
         */
        normalize: function (out, a) {
            var x = a[0],
                y = a[1],
                z = a[2],
                w = a[3];
            var len = x*x + y*y + z*z + w*w;
            if (len > 0) {
                len = 1 / Math.sqrt(len);
                out[0] = a[0] * len;
                out[1] = a[1] * len;
                out[2] = a[2] * len;
                out[3] = a[3] * len;
            }
            return out;
        },


        /**
         * Calculates the dot product of two vec4's
         * @method dot
         * @param {kick.math.Vec4} a the first operand
         * @param {kick.math.Vec4} b the second operand
         * @return {Number} dot product of a and b
         * @static
         */
        dot: function (a, b) {
            return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
        },

        /**
         * Performs a linear interpolation between two vec4's
         *
         * @method lerp
         * @param {kick.math.Vec4} out the receiving vector
         * @param {kick.math.Vec4} a the first operand
         * @param {kick.math.Vec4} b the second operand
         * @param {Number} t interpolation amount between the two inputs
         * @return {kick.math.Vec4} out
         * @static
         */
        lerp: function (out, a, b, t) {
            var ax = a[0],
                ay = a[1],
                az = a[2],
                aw = a[3];
            out[0] = ax + t * (b[0] - ax);
            out[1] = ay + t * (b[1] - ay);
            out[2] = az + t * (b[2] - az);
            out[3] = aw + t * (b[3] - aw);
            return out;
        },

        /**
         * Transforms the vec4 with a mat4.
         *
         * @method transformMat4
         * @param {kick.math.Vec4} out the receiving vector
         * @param {kick.math.Vec4} a the vector to transform
         * @param {kick.math.Mat4} m matrix to transform with
         * @return {kick.math.Vec4} out
         * @static
         */
        transformMat4: function (out, a, m) {
            var x = a[0], y = a[1], z = a[2], w = a[3];
            out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
            out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
            out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
            out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
            return out;
        },

        /**
         * Transforms the vec4 with a quat
         *
         * @method transformQuat
         * @param {kick.math.Vec4} out the receiving vector
         * @param {kick.math.Vec4} a the vector to transform
         * @param {kick.math.Quat} q quaternion to transform with
         * @return {kick.math.Vec4} out
         * @static
         */
        transformQuat: function (out, a, q) {
            var x = a[0], y = a[1], z = a[2],
                qx = q[0], qy = q[1], qz = q[2], qw = q[3],

            // calculate quat * vec
                ix = qw * x + qy * z - qz * y,
                iy = qw * y + qz * x - qx * z,
                iz = qw * z + qx * y - qy * x,
                iw = -qx * x - qy * y - qz * z;

            // calculate result * inverse quat
            out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
            out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
            out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
            return out;
        },

        /**
         * Perform some operation over an array of vec4s.
         *
         * @method forEach
         * @param {Array} a the array of vectors to iterate over
         * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed
         * @param {Number} offset Number of elements to skip at the beginning of the array
         * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
         * @param {Function} fn Function to call for each vector in the array
         * @param {Object} [arg] additional argument to pass to fn
         * @return {Array} a
         * @static
         */
        forEach: (function () {
            var vec = new Float32Array(4);

            return function (a, stride, offset, count, fn, arg) {
                var i, l;
                if (!stride) {
                    stride = 4;
                }

                if (!offset) {
                    offset = 0;
                }

                if (count) {
                    l = Math.min((count * stride) + offset, a.length);
                } else {
                    l = a.length;
                }

                for (i = offset; i < l; i += stride) {
                    vec[0] = a[i]; vec[1] = a[i+1]; vec[2] = a[i+2]; vec[3] = a[i+3];
                    fn(vec, vec, arg);
                    a[i] = vec[0]; a[i+1] = vec[1]; a[i+2] = vec[2]; a[i+3] = vec[3];
                }

                return a;
            };
        }()),

        /**
         * Test to see if vectors are equal (difference is less than epsilon)
         * @method equal
         * @param {kick.math.Vec4} vec first operand
         * @param {kick.math.Vec4} vec2 second operand
         * @param {Number} epsilon Optional - default value is
         * @return {Boolean} true if two vectors are equals
         * @static
         */
        equal: function (vec, vec2, epsilon) {
            var i;
            if (!epsilon) {
                epsilon = 0.00001;
            }
            for (i = 0; i < 2; i++) {
                if (Math.abs(vec[i] - vec2[i]) > epsilon) {
                    return false;
                }
            }
            return true;
        },


        /**
         * Returns a string representation of a vector
         * @method str
         * @param {kick.math.Vec4} vec vec4 to represent as a string
         * @return {String} string representation of vec
         * @static
         */
        str: function (vec) {
            return '[' + vec[0] + ', ' + vec[1] + ', ' + vec[2] + ', ' + vec[3] + ']';
        }
    };
});

define('kick/math/Mat4',["./Vec4"], function (vec4) {
    
    var epsilon = 0.000001,
        vec3length = function (vec) {
            var x = vec[0], y = vec[1], z = vec[2];
            return Math.sqrt(x * x + y * y + z * z);
        },
        mat4,
        quatNormalize = function (quat, dest) {
            if (!dest) { dest = quat; }

            var x = quat[0], y = quat[1], z = quat[2], w = quat[3],
                len = Math.sqrt(x * x + y * y + z * z + w * w);
            if (len === 0) {
                dest[0] = 0;
                dest[1] = 0;
                dest[2] = 0;
                dest[3] = 0;
                return dest;
            }
            len = 1 / len;
            dest[0] = x * len;
            dest[1] = y * len;
            dest[2] = z * len;
            dest[3] = w * len;

            return dest;
        },
        quatSetFromRotationMatrix = function (out, mat) {
            var x, y, z, w,
                m00 = mat[0], m01 = mat[4], m02 = mat[8],
                m10 = mat[1], m11 = mat[5], m12 = mat[9],
                m20 = mat[2], m21 = mat[6], m22 = mat[10],
                absQ,
                quat = vec4;  // here vec4 are used to avoid circular dependency (Only 'constuctor' and 'set' methods are used)
            // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm
            function copySign(a, b) {
                return b < 0 ? -Math.abs(a) : Math.abs(a);
            }
            absQ = Math.pow(mat4.determinant(mat), 1.0 / 3.0);
            w = Math.sqrt(Math.max(0, absQ + m00  + m11 + m22)) / 2;
            x = Math.sqrt(Math.max(0, absQ + m00  - m11 - m22)) / 2;
            y = Math.sqrt(Math.max(0, absQ - m00  + m11 - m22)) / 2;
            z = Math.sqrt(Math.max(0, absQ - m00  - m11 + m22)) / 2;
            x = copySign(x, (m21 - m12)); // m21 - m12
            y = copySign(y, (m02 - m20)); // m02 - m20
            z = copySign(z, (m10 - m01)); // m10 - m01
            quat.copy(out, [x, y, z, w]);
            quatNormalize(out);
            return out;
        };

    /**
     * mat4 - 4x4 Matrix<br>
     * Any javascript array containing at least 16 numeric elements can serve as a Mat4
     * @class Mat4
     * @namespace kick.math
     */
    mat4 = {
        /**
         * Creates a new identity Mat4 using the Float32Arrat<br>
         *
         * @method create
         * @return {kick.math.Mat4} New mat4
         * @static
         */
        create: function () {
            var out = new Float32Array(16);

            out[0] = 1;
            out[5] = 1;
            out[10] = 1;
            out[15] = 1;
            return out;
        },

        /**
         * Creates a new mat4 initialized with values from an existing matrix
         * @method clone
         * @param {kick.math.Mat4} a matrix to clone
         * @return {kick.math.Mat4} a new 4x4 matrix
         * @static
         */
        clone: function (a) {
            var out = new Float32Array(16);
            out[0] = a[0];
            out[1] = a[1];
            out[2] = a[2];
            out[3] = a[3];
            out[4] = a[4];
            out[5] = a[5];
            out[6] = a[6];
            out[7] = a[7];
            out[8] = a[8];
            out[9] = a[9];
            out[10] = a[10];
            out[11] = a[11];
            out[12] = a[12];
            out[13] = a[13];
            out[14] = a[14];
            out[15] = a[15];
            return out;
        },

        /**
         * Copies the values of one mat4 to another
         * @method copy
         * @param {kick.math.Mat4} out the receiving matrix
         * @param {kick.math.Mat4} a the source matrix
         * @return {kick.math.Mat4} out
         * @static
         */
        copy: function (out, a) {
            out[0] = a[0];
            out[1] = a[1];
            out[2] = a[2];
            out[3] = a[3];
            out[4] = a[4];
            out[5] = a[5];
            out[6] = a[6];
            out[7] = a[7];
            out[8] = a[8];
            out[9] = a[9];
            out[10] = a[10];
            out[11] = a[11];
            out[12] = a[12];
            out[13] = a[13];
            out[14] = a[14];
            out[15] = a[15];
            return out;
        },


        /**
         * Set translate, rotate, scale
         * @method setTRS
         * @param {kick.math.Mat4} dest
         * @param {kick.math.Vec3} translate
         * @param {kick.math.Quat} rotateQuat
         * @param {kick.math.Vec3} scale
         * @return {kick.math.Mat4} dest
         * @static
         */
        setTRS: function (out, translate, rotateQuat, scale) {
            // Quaternion math
            var scaleX = scale[0], scaleY = scale[1], scaleZ = scale[2],
                x = rotateQuat[0], y = rotateQuat[1], z = rotateQuat[2], w = rotateQuat[3],
                x2 = x + x,
                y2 = y + y,
                z2 = z + z,

                xx = x * x2,
                xy = x * y2,
                xz = x * z2,
                yy = y * y2,
                yz = y * z2,
                zz = z * z2,
                wx = w * x2,
                wy = w * y2,
                wz = w * z2;

            out[0] = (1 - (yy + zz)) * scaleX;
            out[1] = (xy + wz) * scaleX;
            out[2] = (xz - wy) * scaleX;
            out[3] = 0;
            out[4] = (xy - wz) * scaleY;
            out[5] = (1 - (xx + zz)) * scaleY;
            out[6] = (yz + wx) * scaleY;
            out[7] = 0;
            out[8] = (xz + wy) * scaleZ;
            out[9] = (yz - wx) * scaleZ;
            out[10] = (1 - (xx + yy)) * scaleZ;
            out[11] = 0;
            out[12] = translate[0];
            out[13] = translate[1];
            out[14] = translate[2];
            out[15] = 1;

            return out;
        },

        /**
         * Set the inverse of translate, rotate, scale
         * @method setTRSInverse
         * @param {kick.math.Mat4} out
         * @param {kick.math.Vec3} translate
         * @param {kick.math.Quat} rotateQuat must be normalized
         * @param {kick.math.Vec3} scale
         * @return {kick.math.Mat4} out
         * @static
         */
        setTRSInverse: function (out, translate, rotateQuat, scale) {
            // Quaternion math
            var scaleX = scale[0], scaleY = scale[1], scaleZ = scale[2],
                x = rotateQuat[0], y = rotateQuat[1], z = rotateQuat[2], w = rotateQuat[3],
                x2 = x + x,
                y2 = y + y,
                z2 = z + z,

                xx = x * x2,
                xy = x * y2,
                xz = x * z2,
                yy = y * y2,
                yz = y * z2,
                zz = z * z2,
                wx = w * x2,
                wy = w * y2,
                wz = w * z2,

            // compute trs
                a00 = (1 - (yy + zz)) * scaleX,
                a01 = (xy + wz) * scaleX,
                a02 = (xz - wy) * scaleX,
                a10 = (xy - wz) * scaleY,
                a11 = (1 - (xx + zz)) * scaleY,
                a12 = (yz + wx) * scaleY,
                a20 = (xz + wy) * scaleZ,
                a21 = (yz - wx) * scaleZ,
                a22 = (1 - (xx + yy)) * scaleZ,
                a30 = translate[0],
                a31 = translate[1],
                a32 = translate[2],
                a33 = 1,
            // compute inverse
                b00 = a00 * a11 - a01 * a10,
                b01 = a00 * a12 - a02 * a10,
                b03 = a01 * a12 - a02 * a11,
                b06 = a20 * a31 - a21 * a30,
                b07 = a20 * a32 - a22 * a30,
                b08 = a20 * a33,
                b09 = a21 * a32 - a22 * a31,
                b10 = a21 * a33,
                b11 = a22 * a33,

                d = (b00 * b11 - b01 * b10 + b03 * b08),
                invDet;

            // Calculate the determinant
            if (!d) { return null; }
            invDet = 1 / d;

            out[0] = (a11 * b11 - a12 * b10) * invDet;
            out[1] = (-a01 * b11 + a02 * b10) * invDet;
            out[2] = (a33 * b03) * invDet;
            out[3] = 0;
            out[4] = (-a10 * b11 + a12 * b08) * invDet;
            out[5] = (a00 * b11 - a02 * b08) * invDet;
            out[6] = (-a33 * b01) * invDet;
            out[7] = 0;
            out[8] = (a10 * b10 - a11 * b08) * invDet;
            out[9] = (-a00 * b10 + a01 * b08) * invDet;
            out[10] = (a33 * b00) * invDet;
            out[11] = 0;
            out[12] = (-a10 * b09 + a11 * b07 - a12 * b06) * invDet;
            out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * invDet;
            out[14] = (-a30 * b03 + a31 * b01 - a32 * b00) * invDet;
            out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * invDet;

            return out;
        },

        /**
         * Sets a mat4 to an identity matrix
         * @method identity
         * @param {kick.math.Mat4} out mat4 to set
         * @return {kick.math.Mat4} out
         * @static
         */
        identity: function (out) {
            out[0] = 1;
            out[1] = 0;
            out[2] = 0;
            out[3] = 0;
            out[4] = 0;
            out[5] = 1;
            out[6] = 0;
            out[7] = 0;
            out[8] = 0;
            out[9] = 0;
            out[10] = 1;
            out[11] = 0;
            out[12] = 0;
            out[13] = 0;
            out[14] = 0;
            out[15] = 1;
            return out;
        },

        /**
         * Transposes a mat4 (flips the values over the diagonal)
         * @method transpose
         * @param {kick.math.Mat4} out the receiving matrix
         * @param {kick.math.Mat4} a the source matrix
         * @return {kick.math.Mat4} out
         * @static
         */
        transpose: function (out, a) {
            // If we are transposing ourselves we can skip a few steps but have to cache some values
            if (out === a) {
                var a01 = a[1], a02 = a[2], a03 = a[3],
                    a12 = a[6], a13 = a[7],
                    a23 = a[11];

                out[1] = a[4];
                out[2] = a[8];
                out[3] = a[12];
                out[4] = a01;
                out[6] = a[9];
                out[7] = a[13];
                out[8] = a02;
                out[9] = a12;
                out[11] = a[14];
                out[12] = a03;
                out[13] = a13;
                out[14] = a23;
            } else {
                out[0] = a[0];
                out[1] = a[4];
                out[2] = a[8];
                out[3] = a[12];
                out[4] = a[1];
                out[5] = a[5];
                out[6] = a[9];
                out[7] = a[13];
                out[8] = a[2];
                out[9] = a[6];
                out[10] = a[10];
                out[11] = a[14];
                out[12] = a[3];
                out[13] = a[7];
                out[14] = a[11];
                out[15] = a[15];
            }

            return out;
        },

        /**
         * Inverts a Mat4
         * @method invert
         * @param {kick.math.Mat4} out the receiving matrix
         * @param {kick.math.Mat4} a the source matrix
         * @return {kick.math.Mat4} out
         * @static
         */
        invert: function (out, a) {
            var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
                a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
                a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
                a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

                b00 = a00 * a11 - a01 * a10,
                b01 = a00 * a12 - a02 * a10,
                b02 = a00 * a13 - a03 * a10,
                b03 = a01 * a12 - a02 * a11,
                b04 = a01 * a13 - a03 * a11,
                b05 = a02 * a13 - a03 * a12,
                b06 = a20 * a31 - a21 * a30,
                b07 = a20 * a32 - a22 * a30,
                b08 = a20 * a33 - a23 * a30,
                b09 = a21 * a32 - a22 * a31,
                b10 = a21 * a33 - a23 * a31,
                b11 = a22 * a33 - a23 * a32,

            // Calculate the determinant
                det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

            if (!det) {
                return null;
            }
            det = 1.0 / det;

            out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
            out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
            out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
            out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
            out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
            out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
            out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
            out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
            out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
            out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
            out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
            out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
            out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
            out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
            out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
            out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;

            return out;
        },


        /**
         * Calculates the adjugate of a mat4
         *
         * @method adjoint
         * @param {kick.math.Mat4} out the receiving matrix
         * @param {kick.math.Mat4} a the source matrix
         * @return {kick.math.Mat4} out
         * @static
         */
        adjoint: function (out, a) {
            var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
                a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
                a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
                a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

            out[0]  =  (a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22));
            out[1]  = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
            out[2]  =  (a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12));
            out[3]  = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
            out[4]  = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
            out[5]  =  (a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22));
            out[6]  = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
            out[7]  =  (a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12));
            out[8]  =  (a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21));
            out[9]  = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
            out[10] =  (a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11));
            out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
            out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
            out[13] =  (a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21));
            out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
            out[15] =  (a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11));
            return out;
        },
        /**
         * Calculates the determinant of a mat4
         * @method determinant
         * @param {kick.math.Mat4} a mat4 to calculate determinant of
         * @return {Number} determinant of mat
         * @static
         */
        determinant: function (a) {
            var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
                a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
                a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
                a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

                b00 = a00 * a11 - a01 * a10,
                b01 = a00 * a12 - a02 * a10,
                b02 = a00 * a13 - a03 * a10,
                b03 = a01 * a12 - a02 * a11,
                b04 = a01 * a13 - a03 * a11,
                b05 = a02 * a13 - a03 * a12,
                b06 = a20 * a31 - a21 * a30,
                b07 = a20 * a32 - a22 * a30,
                b08 = a20 * a33 - a23 * a30,
                b09 = a21 * a32 - a22 * a31,
                b10 = a21 * a33 - a23 * a31,
                b11 = a22 * a33 - a23 * a32;

            // Calculate the determinant
            return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
        },

        /**
         * Performs a matrix multiplication
         * @method multiply
         * @param {kick.math.Mat4} out the receiving matrix
         * @param {kick.math.Mat4} a the first operand
         * @param {kick.math.Mat4} b the second operand
         * @return {kick.math.Mat4} out
         * @static
         */
        multiply: function (out, a, b) {
            var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
                a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
                a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
                a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

            // Cache only the current line of the second matrix
                b0  = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
            out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
            out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
            out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
            out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;

            b0 = b[4]; b1 = b[5]; b2 = b[6]; b3 = b[7];
            out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
            out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
            out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
            out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;

            b0 = b[8]; b1 = b[9]; b2 = b[10]; b3 = b[11];
            out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
            out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
            out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
            out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;

            b0 = b[12]; b1 = b[13]; b2 = b[14]; b3 = b[15];
            out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
            out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
            out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
            out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
            return out;
        },

        /**
         * Translates a matrix by the given vector
         * @method translate
         * @param {kick.math.Mat4} out the receiving matrix
         * @param {kick.math.Mat4} a the matrix to translate
         * @param {kick.math.Vec3} v vector to translate by
         * @return {kick.math.Mat4} out
         * @static
         */
        translate: function (out, a, v) {
            var x = v[0], y = v[1], z = v[2],
                a00, a01, a02, a03,
                a10, a11, a12, a13,
                a20, a21, a22, a23;

            if (a === out) {
                out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
                out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
                out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
                out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
            } else {
                a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
                a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
                a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

                out[0] = a00; out[1] = a01; out[2] = a02; out[3] = a03;
                out[4] = a10; out[5] = a11; out[6] = a12; out[7] = a13;
                out[8] = a20; out[9] = a21; out[10] = a22; out[11] = a23;

                out[12] = a00 * x + a10 * y + a20 * z + a[12];
                out[13] = a01 * x + a11 * y + a21 * z + a[13];
                out[14] = a02 * x + a12 * y + a22 * z + a[14];
                out[15] = a03 * x + a13 * y + a23 * z + a[15];
            }

            return out;
        },

        /**
         * Scales a matrix by the given vector
         * @method scale
         * @param {kick.math.Mat4} out the receiving matrix
         * @param {kick.math.Mat4} a the matrix to scale
         * @param {kick.math.Vec3} v the vec3 to scale the matrix by
         * @return {kick.math.Mat4} out
         * @static
         */
        scale: function (out, a, v) {
            var x = v[0], y = v[1], z = v[2];

            out[0] = a[0] * x;
            out[1] = a[1] * x;
            out[2] = a[2] * x;
            out[3] = a[3] * x;
            out[4] = a[4] * y;
            out[5] = a[5] * y;
            out[6] = a[6] * y;
            out[7] = a[7] * y;
            out[8] = a[8] * z;
            out[9] = a[9] * z;
            out[10] = a[10] * z;
            out[11] = a[11] * z;
            out[12] = a[12];
            out[13] = a[13];
            out[14] = a[14];
            out[15] = a[15];
            return out;
        },

        /**
         * Rotates a matrix by the given angle around the specified axis<br>
         * If rotating around a primary axis (X,Y,Z) one of the specialized rotation functions should be used instead for
         * performance
         * @method rotate
         * @param {kick.math.Mat4} out the receiving matrix
         * @param {kick.math.Mat4} a the matrix to rotate
         * @param {Number} rad the angle to rotate the matrix by
         * @param {kick.math.Vec3} axis the axis to rotate around
         * @return {kick.math.Mat4} out
         * @static
         */
        rotate: function (out, a, rad, axis) {
            var x = axis[0], y = axis[1], z = axis[2],
                len = Math.sqrt(x * x + y * y + z * z),
                s, c, t,
                a00, a01, a02, a03,
                a10, a11, a12, a13,
                a20, a21, a22, a23,
                b00, b01, b02,
                b10, b11, b12,
                b20, b21, b22;

            if (Math.abs(len) < epsilon) { return null; }

            len = 1 / len;
            x *= len;
            y *= len;
            z *= len;

            s = Math.sin(rad);
            c = Math.cos(rad);
            t = 1 - c;

            a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
            a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
            a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

            // Construct the elements of the rotation matrix
            b00 = x * x * t + c; b01 = y * x * t + z * s; b02 = z * x * t - y * s;
            b10 = x * y * t - z * s; b11 = y * y * t + c; b12 = z * y * t + x * s;
            b20 = x * z * t + y * s; b21 = y * z * t - x * s; b22 = z * z * t + c;

            // Perform rotation-specific matrix multiplication
            out[0] = a00 * b00 + a10 * b01 + a20 * b02;
            out[1] = a01 * b00 + a11 * b01 + a21 * b02;
            out[2] = a02 * b00 + a12 * b01 + a22 * b02;
            out[3] = a03 * b00 + a13 * b01 + a23 * b02;
            out[4] = a00 * b10 + a10 * b11 + a20 * b12;
            out[5] = a01 * b10 + a11 * b11 + a21 * b12;
            out[6] = a02 * b10 + a12 * b11 + a22 * b12;
            out[7] = a03 * b10 + a13 * b11 + a23 * b12;
            out[8] = a00 * b20 + a10 * b21 + a20 * b22;
            out[9] = a01 * b20 + a11 * b21 + a21 * b22;
            out[10] = a02 * b20 + a12 * b21 + a22 * b22;
            out[11] = a03 * b20 + a13 * b21 + a23 * b22;

            if (a !== out) { // If the source and destination differ, copy the unchanged last row
                out[12] = a[12];
                out[13] = a[13];
                out[14] = a[14];
                out[15] = a[15];
            }
            return out;
        },
        /**
         * Rotates a matrix by the given angle around the X axis
         * @method rotateX
         * @param {kick.math.Mat4} out the receiving matrix
         * @param {kick.math.Mat4} a the matrix to rotate
         * @param {Number} rad the angle to rotate the matrix by
         * @return {kick.math.Mat4} out
         * @static
         */
        rotateX: function (out, a, rad) {
            var s = Math.sin(rad),
                c = Math.cos(rad),
                a10 = a[4],
                a11 = a[5],
                a12 = a[6],
                a13 = a[7],
                a20 = a[8],
                a21 = a[9],
                a22 = a[10],
                a23 = a[11];

            if (a !== out) { // If the source and destination differ, copy the unchanged rows
                out[0]  = a[0];
                out[1]  = a[1];
                out[2]  = a[2];
                out[3]  = a[3];
                out[12] = a[12];
                out[13] = a[13];
                out[14] = a[14];
                out[15] = a[15];
            }

            // Perform axis-specific matrix multiplication
            out[4] = a10 * c + a20 * s;
            out[5] = a11 * c + a21 * s;
            out[6] = a12 * c + a22 * s;
            out[7] = a13 * c + a23 * s;
            out[8] = a20 * c - a10 * s;
            out[9] = a21 * c - a11 * s;
            out[10] = a22 * c - a12 * s;
            out[11] = a23 * c - a13 * s;
            return out;
        },

        /**
         * Rotates a matrix by the given angle around the Y axis
         * @method rotateY
         * @param {kick.math.Mat4} out the receiving matrix
         * @param {kick.math.Mat4} a the matrix to rotate
         * @param {Number} rad the angle to rotate the matrix by
         * @return {kick.math.Mat4} out
         * @static
         */
        rotateY: function (out, a, rad) {
            var s = Math.sin(rad),
                c = Math.cos(rad),
                a00 = a[0],
                a01 = a[1],
                a02 = a[2],
                a03 = a[3],
                a20 = a[8],
                a21 = a[9],
                a22 = a[10],
                a23 = a[11];

            if (a !== out) { // If the source and destination differ, copy the unchanged rows
                out[4]  = a[4];
                out[5]  = a[5];
                out[6]  = a[6];
                out[7]  = a[7];
                out[12] = a[12];
                out[13] = a[13];
                out[14] = a[14];
                out[15] = a[15];
            }

            // Perform axis-specific matrix multiplication
            out[0] = a00 * c - a20 * s;
            out[1] = a01 * c - a21 * s;
            out[2] = a02 * c - a22 * s;
            out[3] = a03 * c - a23 * s;
            out[8] = a00 * s + a20 * c;
            out[9] = a01 * s + a21 * c;
            out[10] = a02 * s + a22 * c;
            out[11] = a03 * s + a23 * c;
            return out;
        },

        /**
         * Rotates a matrix by the given angle around the Z axis
         * @method rotateZ
         * @param {kick.math.Mat4} out the receiving matrix
         * @param {kick.math.Mat4} a the matrix to rotate
         * @param {Number} rad the angle to rotate the matrix by
         * @return {kick.math.Mat4} out
         * @static
         */
        rotateZ: function (out, a, rad) {
            var s = Math.sin(rad),
                c = Math.cos(rad),
                a00 = a[0],
                a01 = a[1],
                a02 = a[2],
                a03 = a[3],
                a10 = a[4],
                a11 = a[5],
                a12 = a[6],
                a13 = a[7];

            if (a !== out) { // If the source and destination differ, copy the unchanged last row
                out[8]  = a[8];
                out[9]  = a[9];
                out[10] = a[10];
                out[11] = a[11];
                out[12] = a[12];
                out[13] = a[13];
                out[14] = a[14];
                out[15] = a[15];
            }

            // Perform axis-specific matrix multiplication
            out[0] = a00 * c + a10 * s;
            out[1] = a01 * c + a11 * s;
            out[2] = a02 * c + a12 * s;
            out[3] = a03 * c + a13 * s;
            out[4] = a10 * c - a00 * s;
            out[5] = a11 * c - a01 * s;
            out[6] = a12 * c - a02 * s;
            out[7] = a13 * c - a03 * s;
            return out;
        },
        /**
         * mat4.fromRotationTranslation
         * Creates a matrix from a quaternion rotation and vector translation
         * This is equivalent to (but much faster than):
         *
         *     mat4.identity(dest);
         *     mat4.translate(dest, vec);
         *     var quatMat = mat4.create();
         *     quat.toMat4(quat, quatMat);
         *     mat4.multiply(dest, quatMat);
         *
         *
         * @method fromRotationTranslation
         * @param {kick.math.Mat4} out mat4 receiving operation result
         * @param {kick.math.Quat} q Rotation quaternion
         * @param {kick.math.Vec3} v Translation vector
         * @return {kick.math.Mat4} out
         * @static
         */
        fromRotationTranslation: function (out, q, v) {
            // Quaternion math
            var x = q[0], y = q[1], z = q[2], w = q[3],
                x2 = x + x,
                y2 = y + y,
                z2 = z + z,

                xx = x * x2,
                xy = x * y2,
                xz = x * z2,
                yy = y * y2,
                yz = y * z2,
                zz = z * z2,
                wx = w * x2,
                wy = w * y2,
                wz = w * z2;

            out[0] = 1 - (yy + zz);
            out[1] = xy + wz;
            out[2] = xz - wy;
            out[3] = 0;
            out[4] = xy - wz;
            out[5] = 1 - (xx + zz);
            out[6] = yz + wx;
            out[7] = 0;
            out[8] = xz + wy;
            out[9] = yz - wx;
            out[10] = 1 - (xx + yy);
            out[11] = 0;
            out[12] = v[0];
            out[13] = v[1];
            out[14] = v[2];
            out[15] = 1;

            return out;
        },


        /**
         * Calculates a 4x4 matrix from the given quaternion
         * @method fromQuat
         * @param {kick.math.Mat4} out mat4 receiving operation result
         * @param {kick.math.Quat} q Quaternion to create matrix from
         *
         * @return {kick.math.Mat4} out
         * @static
         */
        fromQuat: function (out, q) {
            var x = q[0], y = q[1], z = q[2], w = q[3],
                x2 = x + x,
                y2 = y + y,
                z2 = z + z,

                xx = x * x2,
                xy = x * y2,
                xz = x * z2,
                yy = y * y2,
                yz = y * z2,
                zz = z * z2,
                wx = w * x2,
                wy = w * y2,
                wz = w * z2;

            out[0] = 1 - (yy + zz);
            out[1] = xy + wz;
            out[2] = xz - wy;
            out[3] = 0;

            out[4] = xy - wz;
            out[5] = 1 - (xx + zz);
            out[6] = yz + wx;
            out[7] = 0;

            out[8] = xz + wy;
            out[9] = yz - wx;
            out[10] = 1 - (xx + yy);
            out[11] = 0;

            out[12] = 0;
            out[13] = 0;
            out[14] = 0;
            out[15] = 1;

            return out;
        },

        /**
         * Generates a frustum matrix with the given bounds
         * @method frustum
         * @param {kick.math.Mat4} out mat4 frustum matrix will be written into
         * @param {Number} left Left bound of the frustum
         * @param {Number} right Right bound of the frustum
         * @param {Number} bottom Bottom bound of the frustum
         * @param {Number} top Top bound of the frustum
         * @param {Number} near Near bound of the frustum
         * @param {Number} far Far bound of the frustum
         * @return {kick.math.Mat4} out
         * @static
         */
        frustum: function (out, left, right, bottom, top, near, far) {
            var rl = 1 / (right - left),
                tb = 1 / (top - bottom),
                nf = 1 / (near - far);
            out[0] = (near * 2) * rl;
            out[1] = 0;
            out[2] = 0;
            out[3] = 0;
            out[4] = 0;
            out[5] = (near * 2) * tb;
            out[6] = 0;
            out[7] = 0;
            out[8] = (right + left) * rl;
            out[9] = (top + bottom) * tb;
            out[10] = (far + near) * nf;
            out[11] = -1;
            out[12] = 0;
            out[13] = 0;
            out[14] = (far * near * 2) * nf;
            out[15] = 0;
            return out;
        },

        /**
         * Generates a perspective projection matrix with the given bounds
         * @method perspective
         * @param {kick.math.Mat4} out mat4 frustum matrix will be written into
         * @param {number} fovy Vertical field of view in radians
         * @param {number} aspect Aspect ratio. typically viewport width/height
         * @param {number} near Near bound of the frustum
         * @param {number} far Far bound of the frustum
         * @return {kick.math.Mat4} out
         * @static
         */
        perspective: function (out, fovy, aspect, near, far) {
            var f = 1.0 / Math.tan(fovy / 2),
                nf = 1 / (near - far);
            out[0] = f / aspect;
            out[1] = 0;
            out[2] = 0;
            out[3] = 0;
            out[4] = 0;
            out[5] = f;
            out[6] = 0;
            out[7] = 0;
            out[8] = 0;
            out[9] = 0;
            out[10] = (far + near) * nf;
            out[11] = -1;
            out[12] = 0;
            out[13] = 0;
            out[14] = (2 * far * near) * nf;
            out[15] = 0;
            return out;
        },

        /**
         * Generates a orthogonal projection matrix with the given bounds
         * @method ortho
         * @param {kick.math.Mat4} out mat4 frustum matrix will be written into
         * @param {number} left Left bound of the frustum
         * @param {number} right Right bound of the frustum
         * @param {number} bottom Bottom bound of the frustum
         * @param {number} top Top bound of the frustum
         * @param {number} near Near bound of the frustum
         * @param {number} far Far bound of the frustum
         * @return {kick.math.Mat4} out
         * @static
         */
        ortho: function (out, left, right, bottom, top, near, far) {
            var lr = 1 / (left - right),
                bt = 1 / (bottom - top),
                nf = 1 / (near - far);
            out[0] = -2 * lr;
            out[1] = 0;
            out[2] = 0;
            out[3] = 0;
            out[4] = 0;
            out[5] = -2 * bt;
            out[6] = 0;
            out[7] = 0;
            out[8] = 0;
            out[9] = 0;
            out[10] = 2 * nf;
            out[11] = 0;
            out[12] = (left + right) * lr;
            out[13] = (top + bottom) * bt;
            out[14] = (far + near) * nf;
            out[15] = 1;
            return out;
        },

        /**
         * Generates a look-at matrix with the given eye position, focal point, and up axis
         * @method lookAt
         * @param {kick.math.Mat4} out mat4 frustum matrix will be written into
         * @param {kick.math.Vec3} eye Position of the viewer
         * @param {kick.math.Vec3} center Point the viewer is looking at
         * @param {kick.math.Vec3} up vec3 pointing up
         * @return {kick.math.Mat4} out
         * @static
         */
        lookAt: function (out, eye, center, up) {
            var x0, x1, x2, y0, y1, y2, z0, z1, z2, len,
                eyex = eye[0],
                eyey = eye[1],
                eyez = eye[2],
                upx = up[0],
                upy = up[1],
                upz = up[2],
                centerx = center[0],
                centery = center[1],
                centerz = center[2];

            if (Math.abs(eyex - centerx) < epsilon &&
                Math.abs(eyey - centery) < epsilon &&
                Math.abs(eyez - centerz) < epsilon) {
                return mat4.identity(out);
            }

            z0 = eyex - centerx;
            z1 = eyey - centery;
            z2 = eyez - centerz;

            len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
            z0 *= len;
            z1 *= len;
            z2 *= len;

            x0 = upy * z2 - upz * z1;
            x1 = upz * z0 - upx * z2;
            x2 = upx * z1 - upy * z0;
            len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
            if (!len) {
                x0 = 0;
                x1 = 0;
                x2 = 0;
            } else {
                len = 1 / len;
                x0 *= len;
                x1 *= len;
                x2 *= len;
            }

            y0 = z1 * x2 - z2 * x1;
            y1 = z2 * x0 - z0 * x2;
            y2 = z0 * x1 - z1 * x0;

            len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
            if (!len) {
                y0 = 0;
                y1 = 0;
                y2 = 0;
            } else {
                len = 1 / len;
                y0 *= len;
                y1 *= len;
                y2 *= len;
            }

            out[0] = x0;
            out[1] = y0;
            out[2] = z0;
            out[3] = 0;
            out[4] = x1;
            out[5] = y1;
            out[6] = z1;
            out[7] = 0;
            out[8] = x2;
            out[9] = y2;
            out[10] = z2;
            out[11] = 0;
            out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
            out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
            out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
            out[15] = 1;

            return out;
        },

        /**
         * Copies the upper 3x3 elements of a mat4 into another mat4
         * @method toRotationMat
         * @param {kick.math.Mat4} out mat4 receiving copied values
         * @param {kick.math.Mat4} mat mat4 containing values to copy
         * @return {kick.math.Mat4} out
         * @static
         */
        toRotationMat: function (out, mat) {
            out[0] = mat[0];
            out[1] = mat[1];
            out[2] = mat[2];
            out[3] = mat[3];
            out[4] = mat[4];
            out[5] = mat[5];
            out[6] = mat[6];
            out[7] = mat[7];
            out[8] = mat[8];
            out[9] = mat[9];
            out[10] = mat[10];
            out[11] = mat[11];
            out[12] = 0;
            out[13] = 0;
            out[14] = 0;
            out[15] = 1;

            return out;
        },

        /**
         * Copies the upper 3x3 elements of a mat4 into a mat3
         * @method toMat3
         * @param {kick.math.Mat3} out Optional, mat3 receiving copied values
         * @param {kick.math.Mat4} mat mat4 containing values to copy
         * @return {kick.math.Mat3} out
         * @static
         */
        toMat3: function (out, mat) {
            out[0] = mat[0];
            out[1] = mat[1];
            out[2] = mat[2];
            out[3] = mat[4];
            out[4] = mat[5];
            out[5] = mat[6];
            out[6] = mat[8];
            out[7] = mat[9];
            out[8] = mat[10];

            return out;
        },

        /**
         * Calculates the normal matrix (that is the transpose of the inverse of the upper 3x3 elements of a mat4) and
         * copies the result into a mat3<br>
         * @method toNormalMat3
         * @param {kick.math.Mat3} out mat3 receiving values
         * @param {kick.math.Mat4} mat mat4 containing values to transpose, invert and copy
         * @return {kick.math.Mat3} out
         * @static
         */
        toNormalMat3: function (out, mat) {
            // Cache the matrix values (makes for huge speed increases!)
            var a00 = mat[0], a01 = mat[1], a02 = mat[2],
                a10 = mat[4], a11 = mat[5], a12 = mat[6],
                a20 = mat[8], a21 = mat[9], a22 = mat[10],
                b01 = a22 * a11 - a12 * a21,
                b11 = -a22 * a10 + a12 * a20,
                b21 = a21 * a10 - a11 * a20,
                d = a00 * b01 + a01 * b11 + a02 * b21,
                id;
            if (!d) { return null; }
            id = 1 / d;


            out[0] = b01 * id;
            out[3] = (-a22 * a01 + a02 * a21) * id;
            out[6] = (a12 * a01 - a02 * a11) * id;

            out[1] = b11 * id;
            out[4] = (a22 * a00 - a02 * a20) * id;
            out[7] = (-a12 * a00 + a02 * a10) * id;

            out[2] = b21 * id;
            out[5] = (-a21 * a00 + a01 * a20) * id;
            out[8] = (a11 * a00 - a01 * a10) * id;

            return out;
        },

        /**
         * Calculates the inverse of the upper 3x3 elements of a mat4 and copies the result into a mat3<br>
         * The resulting matrix is useful for calculating transformed normals
         * @method toInverseMat3
         * @param {kick.math.Mat4} mat mat4 containing values to invert and copy
         * @param {kick.math.Mat3} out mat3 receiving values
         * @return {kick.math.Mat3} out
         * @static
         */
        toInverseMat3: function (out, mat) {
            // Cache the matrix values (makes for huge speed increases!)
            var a00 = mat[0], a01 = mat[1], a02 = mat[2],
                a10 = mat[4], a11 = mat[5], a12 = mat[6],
                a20 = mat[8], a21 = mat[9], a22 = mat[10],

                b01 = a22 * a11 - a12 * a21,
                b11 = -a22 * a10 + a12 * a20,
                b21 = a21 * a10 - a11 * a20,

                d = a00 * b01 + a01 * b11 + a02 * b21,
                id;

            if (!d) { return null; }
            id = 1 / d;

            out[0] = b01 * id;
            out[1] = (-a22 * a01 + a02 * a21) * id;
            out[2] = (a12 * a01 - a02 * a11) * id;
            out[3] = b11 * id;
            out[4] = (a22 * a00 - a02 * a20) * id;
            out[5] = (-a12 * a00 + a02 * a10) * id;
            out[6] = b21 * id;
            out[7] = (-a21 * a00 + a01 * a20) * id;
            out[8] = (a11 * a00 - a01 * a10) * id;

            return out;
        },



        /**
         * Transforms a vec3 with the given matrix<br>
         * 4th vector component is implicitly '1'
         * @method multiplyVec3
         * @param {kick.math.Vec3} out vec3 receiving operation result.
         * @param {kick.math.Mat4} mat mat4 to transform the vector with
         * @param {kick.math.Vec3} vec vec3 to transform
         * @return {kick.math.Vec3} out
         * @static
         */
        multiplyVec3: function (out, mat, vec) {
            var x = vec[0], y = vec[1], z = vec[2];

            out[0] = mat[0] * x + mat[4] * y + mat[8] * z + mat[12];
            out[1] = mat[1] * x + mat[5] * y + mat[9] * z + mat[13];
            out[2] = mat[2] * x + mat[6] * y + mat[10] * z + mat[14];

            return out;
        },

        /**
         * Transforms a vec3 with the given matrix<br>
         * 4th vector component is implicitly '0'
         * @method multiplyVec3Vector
         * @param {kick.math.Vec3} out vec3 receiving operation result.
         * @param {kick.math.Mat4} mat mat4 to transform the vector with
         * @param {kick.math.Vec3} vec vec3 to transform
         * @return {kick.math.Vec3} out
         * @static
         */
        multiplyVec3Vector: function (out, mat, vec) {
            var x = vec[0], y = vec[1], z = vec[2];

            out[0] = mat[0] * x + mat[4] * y + mat[8] * z;
            out[1] = mat[1] * x + mat[5] * y + mat[9] * z;
            out[2] = mat[2] * x + mat[6] * y + mat[10] * z;
            out[3] = mat[3] * x + mat[7] * y + mat[11] * z;

            return out;
        },

        /**
         * Transforms a vec4 with the given matrix
         * @method multiplyVec4
         * @param {kick.math.Vec4} out vec4 receiving operation result.
         * @param {kick.math.Mat4} mat mat4 to transform the vector with
         * @param {kick.math.Vec4} vec vec4 to transform
         * @return {kick.math.Vec4} out
         * @static
         */
        multiplyVec4: function (out, mat, vec) {
            var x = vec[0], y = vec[1], z = vec[2], w = vec[3];

            out[0] = mat[0] * x + mat[4] * y + mat[8] * z + mat[12] * w;
            out[1] = mat[1] * x + mat[5] * y + mat[9] * z + mat[13] * w;
            out[2] = mat[2] * x + mat[6] * y + mat[10] * z + mat[14] * w;
            out[3] = mat[3] * x + mat[7] * y + mat[11] * z + mat[15] * w;

            return out;
        },

        /**
         * Returns array with translate, rotate scale
         * @method decompose
         * @param {kick.math.Mat4} mat mat4 to decompose
         * @param {kick.math.Vec3} translate
         * @param {kick.math.Quat} rotate
         * @param {kick.math.Vec3} scale
         * @return Array_tranlate_rotate_scale
         * @static
         */
        decompose: (function () {
            var copy = new Float32Array(16);
            return function (mat, tranlate, rotate, scale) {
                var x = [mat[0], mat[1], mat[2]],
                    y = [mat[4], mat[5], mat[6]],
                    z = [mat[8], mat[9], mat[10]],
                    scaleX,
                    scaleY,
                    scaleZ;

                tranlate[0] = mat[12];
                tranlate[1] = mat[13];
                tranlate[2] = mat[14];

                scale[0] = scaleX = vec3length(x);
                scale[1] = scaleY = vec3length(y);
                scale[2] = scaleZ = vec3length(z);

                this.copy(copy, mat);

                copy[0] /= scaleX;
                copy[1] /= scaleX;
                copy[2] /= scaleX;

                copy[4] /= scaleY;
                copy[5] /= scaleY;
                copy[6] /= scaleY;

                copy[8] /= scaleZ;
                copy[9] /= scaleZ;
                copy[10] /= scaleZ;


                quatSetFromRotationMatrix(rotate, copy);

                return [tranlate, rotate, scale];
            };
        }()),



        /**
         * Returns a string representation of a mat4
         * @method str
         * @param {kick.math.Mat4} mat mat4 to represent as a string
         * @return {String} string representation of mat
         * @static
         */
        str: function (mat) {
            return '[' + mat[0] + ', ' + mat[1] + ', ' + mat[2] + ', ' + mat[3] +
                ', ' + mat[4] + ', ' + mat[5] + ', ' + mat[6] + ', ' + mat[7] +
                ', ' + mat[8] + ', ' + mat[9] + ', ' + mat[10] + ', ' + mat[11] +
                ', ' + mat[12] + ', ' + mat[13] + ', ' + mat[14] + ', ' + mat[15] + ']';
        },

        /**
         * Returns a string representation of a mat4 printed as a 4x4 matrix (on 4 lines)
         * @method strPretty
         * @param {kick.math.Mat4} mat mat4 to represent as a string
         * @return {String} string representation of mat
         * @static
         */
        strPretty: function (mat) {
            return '[' + mat[0] + ', ' + mat[4] + ', ' + mat[8] + ', ' + mat[12] + '\n' +
                ', ' + mat[1] + ', ' + mat[5] + ', ' + mat[9] + ', ' + mat[13] + '\n' +
                ', ' + mat[2] + ', ' + mat[6] + ', ' + mat[10] + ', ' + mat[14] + '\n' +
                ', ' + mat[3] + ', ' + mat[7] + ', ' + mat[11] + ', ' + mat[15] + ']';
        }
    };
    return mat4;
});



define('kick/math/Vec3',["kick/core/Constants", "./Mat4"], function (constants, mat4) {
    
    var wrapArray = function (array, length) {
        var i,
            index = 0,
            count = array.length / length,
            res = [];
        for (i = 0; i < count; i++, index += length) {
            res[i] = array.subarray(index, index + length);
        }
        return res;
    };

    /**
     * Vec3 - 3 Dimensional Vector
     * @class Vec3
     * @namespace kick.math
     */
    return {
        /**
         * See kick.math.Vec4.wrapArray
         * @method wrapArray
         * @param {Float32Array} array
         * @return {Array_kick.math.Vec3} of vec3
         * @static
         */
        wrapArray: function (array) {
            return wrapArray(array, 3);
        },

        /**
         * Create a continuous array in memory mapped to vec3. <br>
         * <br>
         * Example<br>
         * @example
         *     var ref = {};
         *     var v = kick.math.Vec3.array(2,ref);
         *     v[1][1] = 1;
         *     ref.mem[4] == v[1][1];
         *
         * Will be layed out like this: <br>
         * <br>
         * @example
         *     [vec3][vec3) = [0][1][2][3][4][5]
         *
         *
         * @method array
         * @param {Number} count Number of vec 3 to be layed out in memory
         * @param {Object} ref Optional, if set a memory reference is set to ref.mem
         * @return {kick.math.Vec3} New vec3
         * @static
         */
        array: function (count, ref) {
            var memory = new Float32Array(count * 3);
            if (ref) {
                ref.mem = memory;
            }
            return wrapArray(memory, 3);
        },
        /**
         * Creates a new, empty vec3
         *
         * @method create
         * @return {kick.math.Vec3} New vec3
         * @static
         */
        create: function () {
            return new Float32Array(3);
        },

        /**
         * @method clone
         * @param {kick.math.Vec3} a vector to clone
         * @return {kick.math.Vec3} a new 3D vector
         * @static
         */
        clone: function (a) {
            var out = new Float32Array(3);
            out[0] = a[0];
            out[1] = a[1];
            out[2] = a[2];
            return out;
        },

        /**
         * Creates a new vec3 initialized with the given values
         * @method fromValues
         * @param {Number} x X component
         * @param {Number} y Y component
         * @param {Number} z Z component
         * @return {kick.math.Vec3} a new 3D vector
         * @static
         */
        fromValues: function (x, y, z) {
            var out = new Float32Array(3);
            out[0] = x;
            out[1] = y;
            out[2] = z;
            return out;
        },

        /**
         * Copy the values from one vec3 to another
         *
         * @method copy
         * @param {kick.math.Vec3} out the receiving vector
         * @param {kick.math.Vec3} a the source vector
         * @return {kick.math.Vec3} out
         * @static
         */
        copy: function (out, a) {
            out[0] = a[0];
            out[1] = a[1];
            out[2] = a[2];
            return out;
        },

        /**
         * Set the components of a vec3 to the given values
         *
         * @method set
         * @param {kick.math.Vec3} out the receiving vector
         * @param {Number} x X component
         * @param {Number} y Y component
         * @param {Number} z Z component
         * @return {kick.math.Vec3} out
         * @static
         */
        set: function (out, x, y, z) {
            out[0] = x;
            out[1] = y;
            out[2] = z;
            return out;
        },

        /**
         * Adds two vec3's
         * @method add
         * @param {kick.math.Vec3} out the receiving vector
         * @param {kick.math.Vec3} a the first operand
         * @param {kick.math.Vec3} b the second operand
         * @return {kick.math.Vec3} out
         * @static
         */
        add: function (out, a, b) {
            out[0] = a[0] + b[0];
            out[1] = a[1] + b[1];
            out[2] = a[2] + b[2];
            return out;
        },

        /**
         * Subtracts two vec3's
         *
         * @method subtract
         * @param {kick.math.Vec3} out the receiving vector
         * @param {kick.math.Vec3} a the first operand
         * @param {kick.math.Vec3} b the second operand
         * @return {kick.math.Vec3} out
         * @static
         */
        subtract: function (out, a, b) {
            out[0] = a[0] - b[0];
            out[1] = a[1] - b[1];
            out[2] = a[2] - b[2];
            return out;
        },


        /**
         * Multiplies two vec3's
         * @method multiply
         * @param {kick.math.Vec3} out the receiving vector
         * @param {kick.math.Vec3} a the first operand
         * @param {kick.math.Vec3} b the second operand
         * @return {kick.math.Vec3} out
         * @static
         */
        multiply: function (out, a, b) {
            out[0] = a[0] * b[0];
            out[1] = a[1] * b[1];
            out[2] = a[2] * b[2];
            return out;
        },

        /**
         * Divides two vec3's
         *
         * @method divide
         * @param {kick.math.Vec3} out the receiving vector
         * @param {kick.math.Vec3} a the first operand
         * @param {kick.math.Vec3} b the second operand
         * @return {kick.math.Vec3} out
         * @static
         */
        divide: function (out, a, b) {
            out[0] = a[0] / b[0];
            out[1] = a[1] / b[1];
            out[2] = a[2] / b[2];
            return out;
        },

        /**
         * Returns the minimum of two vec3's
         *
         * @method min
         * @param {kick.math.Vec3} out the receiving vector
         * @param {kick.math.Vec3} a the first operand
         * @param {kick.math.Vec3} b the second operand
         * @return {kick.math.Vec3} out
         * @static
         */
        min: function (out, a, b){
            out[0] = Math.min(a[0], b[0]);
            out[1] = Math.min(a[1], b[1]);
            out[2] = Math.min(a[2], b[2]);
            return out;
        },

        /**
         * Returns the maximum of two vec3's
         *
         * @method max
         * @param {kick.math.Vec3} out the receiving vector
         * @param {kick.math.Vec3} a the first operand
         * @param {kick.math.Vec3} b the second operand
         * @return {kick.math.Vec3} out
         * @static
         */
        max: function (out, a, b) {
            out[0] = Math.max(a[0], b[0]);
            out[1] = Math.max(a[1], b[1]);
            out[2] = Math.max(a[2], b[2]);
            return out;
        },

        /**
         * Scales a vec3 by a scalar number
         * @method scale
         * @param {kick.math.Vec3} out the receiving vector
         * @param {kick.math.Vec3} a the vector to scale
         * @param {Number} b amount to scale the vector by
         * @return {kick.math.Vec3} out
         * @static
         */
        scale: function (out, a, b) {
            out[0] = a[0] * b;
            out[1] = a[1] * b;
            out[2] = a[2] * b;
            return out;
        },

        /**
         * Calculates the euclidian distance between two vec3's
         *
         * @method distance
         * @param {kick.math.Vec3} a the first operand
         * @param {kick.math.Vec3} b the second operand
         * @return {Number} distance between a and b
         * @static
         */
        distance: function (a, b) {
            var x = b[0] - a[0],
                y = b[1] - a[1],
                z = b[2] - a[2];
            return Math.sqrt(x * x + y * y + z * z);
        },

        /**
         * Calculates the squared euclidian distance between two vec3's
         *
         * @method squaredDistance
         * @param {kick.math.Vec3} a the first operand
         * @param {kick.math.Vec3} b the second operand
         * @return {Number} squared distance between a and b
         * @static
         */
        squaredDistance: function (a, b) {
            var x = b[0] - a[0],
                y = b[1] - a[1],
                z = b[2] - a[2];
            return x * x + y * y + z * z;
        },

        /**
         * Calculates the length of a vec3
         *
         * @method length
         * @param {kick.math.Vec3} a vector to calculate length of
         * @return {Number} Length of vec
         * @static
         */
        length: function (a) {
            var x = a[0],
                y = a[1],
                z = a[2];
            return Math.sqrt(x * x + y * y + z * z);
        },

        /**
         * Calculates the squared length of a vec3
         * @method squaredLength
         * @param {kick.math.Vec3} a vector to calculate squared length of
         * @return {Number} Squared length of vec
         * @static
         */
        squaredLength: function (a) {
            var x = a[0],
                y = a[1],
                z = a[2];
            return x * x + y * y + z * z;
        },

        /**
         * Negates the components of a vec3
         * @method negate
         * @param {kick.math.Vec3} out the receiving vector
         * @param {kick.math.Vec3} a vector to negate
         * @return {kick.math.Vec3} out
         * @static
         */
        negate: function (out, a) {
            out[0] = -a[0];
            out[1] = -a[1];
            out[2] = -a[2];
            return out;
        },



        /**
         * Normalize a vec3
         *
         * @method normalize
         * @param {kick.math.Vec3} out the receiving vector
         * @param {kick.math.Vec3} a vector to normalize
         * @return {kick.math.Vec3} out
         * @static
         */
        normalize: function (out, a) {
            var x = a[0],
                y = a[1],
                z = a[2],
                len = x * x + y * y + z * z;
            if (len > 0) {
                //TODO: evaluate use of glm_invsqrt here?
                len = 1 / Math.sqrt(len);
                out[0] = a[0] * len;
                out[1] = a[1] * len;
                out[2] = a[2] * len;
            }
            return out;
        },

        /**
         * Calculates the dot product of two vec3s
         * @method dot
         * @param {kick.math.Vec3} a the first operand
         * @param {kick.math.Vec3} b the second operand
         * @return {Number} dot product of a and b
         * @static
         */
        dot: function (a, b) {
            return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
        },

        /**
         * Generates the cross product of two vec3s
         * @method cross
         * @param {kick.math.Vec3} out the receiving vector
         * @param {kick.math.Vec3} a the first operand
         * @param {kick.math.Vec3} b the second operand
         * @return {kick.math.Vec3} out
         * @static
         */
        cross: function (out, a, b) {
            var ax = a[0], ay = a[1], az = a[2],
                bx = b[0], by = b[1], bz = b[2];

            out[0] = ay * bz - az * by;
            out[1] = az * bx - ax * bz;
            out[2] = ax * by - ay * bx;
            return out;
        },

        /**
         * Performs a linear interpolation between two vec3
         *
         * @method lerp
         * @param {kick.math.Vec3} out the receiving vector
         * @param {kick.math.Vec3} a the first operand
         * @param {kick.math.Vec3} b the second operand
         * @param {Number} t interpolation amount between the two inputs
         * @return {kick.math.Vec3} out
         * @static
         */
        lerp: function (out, a, b, t) {
            var ax = a[0],
                ay = a[1],
                az = a[2];
            out[0] = ax + t * (b[0] - ax);
            out[1] = ay + t * (b[1] - ay);
            out[2] = az + t * (b[2] - az);
            return out;
        },

        /**
         * Transforms the vec3 with a mat4.
         * 4th vector component is implicitly '1'
         *
         * @method transformMat4
         * @param {kick.math.Vec3} out the receiving vector
         * @param {kick.math.Vec3} a the vector to transform
         * @param {kick.math.Mat4} m matrix to transform with
         * @return {kick.math.Vec3} out
         * @static
         */
        transformMat4: function (out, a, m) {
            var x = a[0], y = a[1], z = a[2];
            out[0] = m[0] * x + m[4] * y + m[8] * z + m[12];
            out[1] = m[1] * x + m[5] * y + m[9] * z + m[13];
            out[2] = m[2] * x + m[6] * y + m[10] * z + m[14];
            return out;
        },

        /**
         * Transforms the vec3 with a quat
         *
         * @method transformQuat
         * @param {kick.math.Vec3} out the receiving vector
         * @param {kick.math.Vec3} a the vector to transform
         * @param {kick.math.Quat} q quaternion to transform with
         * @return {kick.math.Vec3} out
         * @static
         */
        transformQuat: function (out, a, q) {
            var x = a[0], y = a[1], z = a[2],
                qx = q[0], qy = q[1], qz = q[2], qw = q[3],

            // calculate quat * vec
                ix = qw * x + qy * z - qz * y,
                iy = qw * y + qz * x - qx * z,
                iz = qw * z + qx * y - qy * x,
                iw = -qx * x - qy * y - qz * z;

            // calculate result * inverse quat
            out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
            out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
            out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
            return out;
        },

        /**
         * Perform some operation over an array of vec3s.
         *
         * @method forEach
         * @param {Array} a the array of vectors to iterate over
         * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
         * @param {Number} offset Number of elements to skip at the beginning of the array
         * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
         * @param {Function} fn Function to call for each vector in the array
         * @param {Object} [arg] additional argument to pass to fn
         * @return {Array} a
         * @static
         */
        forEach: (function () {
            var vec = new Float32Array(3);

            return function (a, stride, offset, count, fn, arg) {
                var i, l;
                if (!stride) {
                    stride = 3;
                }

                if (!offset) {
                    offset = 0;
                }

                if (count) {
                    l = Math.min((count * stride) + offset, a.length);
                } else {
                    l = a.length;
                }

                for (i = offset; i < l; i += stride) {
                    vec[0] = a[i]; vec[1] = a[i+1]; vec[2] = a[i+2];
                    fn(vec, vec, arg);
                    a[i] = vec[0]; a[i+1] = vec[1]; a[i+2] = vec[2];
                }

                return a;
            };
        }()),

        /**
         * Generates a unit vector pointing from one vector to another
         * @method direction
         * @param {kick.math.Vec3} out vec3 receiving operation result.
         * @param {kick.math.Vec3} vec origin vec3
         * @param {kick.math.Vec3} vec2 vec3 to point to
         * @return {kick.math.Vec3} dest if specified, vec otherwise
         * @static
         */
        direction: function (out, vec, vec2) {
            var x = vec[0] - vec2[0],
                y = vec[1] - vec2[1],
                z = vec[2] - vec2[2],
                len = Math.sqrt(x * x + y * y + z * z);

            if (!len) {
                out[0] = 0;
                out[1] = 0;
                out[2] = 0;
                return out;
            }

            len = 1 / len;
            out[0] = x * len;
            out[1] = y * len;
            out[2] = z * len;
            return out;
        },



        /**
         * Calculates the euclidean distance between two vec3
         *
         * @method dist
         * @param {kick.math.Vec3} vec first vector
         * @param {kick.math.Vec3} vec2 second vector
         * @return {Number} distance between vec and vec2
         * @static
         */
        dist: function (vec, vec2) {
            var x = vec2[0] - vec[0],
                y = vec2[1] - vec[1],
                z = vec2[2] - vec[2];

            return Math.sqrt(x * x + y * y + z * z);
        },

        /**
         * Projects the specified vec3 from screen space into object space
         * Based on Mesa gluUnProject implementation at:
         * http://webcvs.freedesktop.org/mesa/Mesa/src/glu/mesa/project.c?revision=1.4&view=markup
         *
         * @method unproject
         * @param {kick.math.Vec3} out vec3 receiving unprojected result.
         * @param {kick.math.Vec3} vec screen-space vector to project
         * @param {kick.math.Mat4} modelView Model-View matrix
         * @param {kick.math.Mat4} proj Projection matrix
         * @param {kick.math.Vec4} viewportRect Viewport as given to gl.viewport [x, y, width, height]
         * @return {kick.math.Vec3} dest if specified, vec otherwise
         * @static
         */
        unproject: (function () {
            var m = new Float32Array(16),
                v = new Float32Array(4);
            return function (out, vec, modelView, proj, viewportRect) {
                v[0] = (vec[0] - viewportRect[0]) * 2.0 / viewportRect[2] - 1.0;
                v[1] = (vec[1] - viewportRect[1]) * 2.0 / viewportRect[3] - 1.0;
                v[2] = 2.0 * vec[2] - 1.0;
                v[3] = 1.0;

                mat4.multiply(m, proj, modelView);
                if (!mat4.invert(m, m)) { return null; }

                mat4.multiplyVec4(v, m, v);
                if (v[3] === 0.0) { return null; }

                out[0] = v[0] / v[3];
                out[1] = v[1] / v[3];
                out[2] = v[2] / v[3];

                return out;
            };
        }()),

        /**
         * Converts the spherical coordinates (in radians) to carterian coordinates.<br>
         * Spherical coordinates are mapped so vec[0] is radius, vec[1] is polar and vec[2] is elevation
         * @method sphericalToCarterian
         * @param {kick.math.Vec3} out
         * @param {kick.math.Vec3} spherical spherical coordinates
         * @return {kick.math.Vec3} position in cartesian angles
         * @static
         */
        sphericalToCarterian: function (out, spherical) {
            var radius = spherical[0],
                polar = -spherical[1],
                elevation = spherical[2],
                a = radius * Math.cos(elevation);
            out[0] = a * Math.cos(polar);
            out[1] = radius * Math.sin(elevation);
            out[2] = a * Math.sin(polar);
            return out;
        },

        /**
         * Test to see if vectors are equal (difference is less than epsilon)
         * @method equal
         * @param {kick.math.Vec3} vec first operand
         * @param {kick.math.Vec3} vec2 second operand
         * @param {Number} epsilon Optional - default value is
         * @return {Boolean} true if two vectors are equals
         * @static
         */
        equal: function (vec, vec2, epsilon) {
            var i;
            if (!epsilon) {
                epsilon = 0.00001;
            }
            for (i = 0; i < 3; i++) {
                if (Math.abs(vec[i] - vec2[i]) > epsilon) {
                    return false;
                }
            }
            return true;
        },



        /**
         * Converts from cartesian coordinates to spherical coordinates (in radians)<br>
         * Spherical coordinates are mapped so vec[0] is radius, vec[1] is polar and vec[2] is elevation
         * @method cartesianToSpherical
         * @param {kick.math.Vec3} out
         * @param {kick.math.Vec3} cartesian
         * @return {kick.math.Vec3}
         * @static
         */
        cartesianToSpherical: function (out, cartesian) {
            var x = cartesian[0],
                y = cartesian[1],
                z = cartesian[2],
                sphericalX;
            if (x === 0) {
                x = 0.00001;
            }

            out[0] = sphericalX = Math.sqrt(x * x + y * y + z * z);
            out[1] = -Math.atan(z / x);
            if (x < 0) {
                out[1] += Math.PI;
            }
            out[2] = Math.asin(y / sphericalX);
            return out;
        },

        /**
         * Returns a string representation of a vector
         * @method str
         * @param {kick.math.Vec3} vec vec3 to represent as a string
         * @return {String} string representation of vec
         * @static
         */
        str: function (vec) {
            return '[' + vec[0] + ', ' + vec[1] + ', ' + vec[2] + ']';
        }
    };
});


define('kick/math/Aabb',["kick/core/Constants", "./Vec3", "./Mat4"], function (constants, vec3, mat4) {
    

    /**
     * @module kick.math
     */

    /**
     * Axis-Aligned Bounding Box. A rectangle or box with the restriction that it's sides or faces are parallel to the
     * axes of the system.
     * The aabb is represented using an array: [min\_x,min\_y,min\_z,max\_x,max\_y,max\_z]
     * @class Aabb
     * @namespace kick.math
     */
    return {
        /**
         * Default value is min=MAX, max=MIN (meaning that it has a negative size)
         * @method create
         * @param {Array_Number | kick.math.Aabb} vec3Min Optional, vec3Min containing values to initialize minimum values with Default. Or an aabb.
         * @param {Array_Number} vec3Max Optional, vec3Max containing values to initialize maximum values with
         * @return {kick.math.Aabb} New aabb
         * @static
         */
        create: function (vec3Min, vec3Max) {
            var dest = new Float32Array(6);

            if (vec3Min) {
                dest[0] = vec3Min[0];
                dest[1] = vec3Min[1];
                dest[2] = vec3Min[2];
                if (vec3Min.length === 6) {
                    dest[3] = vec3Min[3];
                    dest[4] = vec3Min[4];
                    dest[5] = vec3Min[5];
                } else if (vec3Max) {
                    dest[3] = vec3Max[0];
                    dest[4] = vec3Max[1];
                    dest[5] = vec3Max[2];
                } else {
                    dest[3] = dest[0];
                    dest[4] = dest[1];
                    dest[5] = dest[2];
                }
            } else {
                dest[0] = Number.MAX_VALUE;
                dest[1] = Number.MAX_VALUE;
                dest[2] = Number.MAX_VALUE;
                dest[3] = -Number.MAX_VALUE;
                dest[4] = -Number.MAX_VALUE;
                dest[5] = -Number.MAX_VALUE;
            }
            return dest;
        },

        /**
         * Copies the values of one aabb to another
         * @method copy
         * @param {kick.math.Aabb} out receiving copied values
         * @param {kick.math.Aabb} aabb containing values to copy
         * @return {kick.math.Aabb} dest
         * @static
         */
        copy: function (out, aabb) {
            out[0] = aabb[0];
            out[1] = aabb[1];
            out[2] = aabb[2];
            out[3] = aabb[3];
            out[4] = aabb[4];
            out[5] = aabb[5];
            return out;
        },

        /**
         * Transforms the eight points of the Axis-Aligned Bounding Box into a new AABB
         * @method transform
         * @param {kick.math.Aabb} out
         * @param {kick.math.Aabb} aabbIn
         * @param {kick.math.Mat4} mat
         * @return {kick.math.Aabb}
         * @static
         */
        transform: (function () {
            var point = vec3.create(),
                temp = new Float32Array(6);
            return function (out, aabbIn, mat) {
                var max = Number.MAX_VALUE,
                    min = -Number.MAX_VALUE,
                    i,
                    j,
                    k,
                    transformedPoint;

                this.copy(temp, [max, max, max, min, min, min]);

                for (i = 0; i < 2; i++) {
                    for (j = 0; j < 2; j++) {
                        for (k = 0; k < 2; k++) {
                            point[0] = aabbIn[i * 3];
                            point[1] = aabbIn[j * 3 + 1];
                            point[2] = aabbIn[k * 3 + 2];
                            transformedPoint = mat4.multiplyVec3(point, mat, point);
                            this.addPoint(temp, temp, transformedPoint);
                        }
                    }
                }
                this.copy(out, temp);
                return out;
            };
        }()),

        /**
         * @method merge
         * @param {kick.math.Aabb} out
         * @param {kick.math.Aabb} aabb
         * @param {kick.math.Aabb} aabb2
         * @return {kick.math.Aabb} out
         * @static
         */
        merge: function (out, aabb, aabb2) {
            out[0] = Math.min(aabb[0], aabb2[0]);
            out[1] = Math.min(aabb[1], aabb2[1]);
            out[2] = Math.min(aabb[2], aabb2[2]);
            out[3] = Math.max(aabb[3], aabb2[3]);
            out[4] = Math.max(aabb[4], aabb2[4]);
            out[5] = Math.max(aabb[5], aabb2[5]);
            return out;
        },

        /**
         * @method addPoint
         * @param {kick.math.Aabb} out
         * @param {kick.math.Aabb} aabb
         * @param {kick.math.Vec3} a point
         * @return {kick.math.Aabb} aabb (same object as input)
         * @static
         */
        addPoint: function (out, aabb, a) {
            var vpX = a[0],
                vpY = a[1],
                vpZ = a[2];
            out[0] = Math.min(aabb[0], vpX);
            out[1] = Math.min(aabb[1], vpY);
            out[2] = Math.min(aabb[2], vpZ);
            out[3] = Math.max(aabb[3], vpX);
            out[4] = Math.max(aabb[4], vpY);
            out[5] = Math.max(aabb[5], vpZ);
            return aabb;
        },
        /**
         * @method addPointIndexed
         * @param {kick.math.Aabb} out
         * @param {kick.math.Aabb} aabb
         * @param {Array} a array of Numbers
         * @param {Number} offset
         * @return {kick.math.Aabb} aabb (same object as input)
         * @static
         */
        addPointIndexed: function (out, aabb, a, offset) {
            var vpX = a[0+offset],
                vpY = a[1+offset],
                vpZ = a[2+offset];
            out[0] = Math.min(aabb[0], vpX);
            out[1] = Math.min(aabb[1], vpY);
            out[2] = Math.min(aabb[2], vpZ);
            out[3] = Math.max(aabb[3], vpX);
            out[4] = Math.max(aabb[4], vpY);
            out[5] = Math.max(aabb[5], vpZ);
            return aabb;
        },


        /**
         * @method center
         * @param {kick.math.Vec3} out
         * @param {kick.math.Aabb} aabb
         * @return {kick.math.Vec3} out
         * @static
         */
        center: function (out, aabb) {
            out[0] = (aabb[0] + aabb[3]) * 0.5;
            out[1] = (aabb[1] + aabb[4]) * 0.5;
            out[2] = (aabb[2] + aabb[5]) * 0.5;

            return out;
        },

        /**
         * @method halfVector
         * @param {kick.math.Vec3} out
         * @param {kick.math.Aabb} aabb
         * @return {kick.math.Vec3} out
         * @static
         */
        halfVec3: function (out, aabb) {
            out[0] = (aabb[3] - aabb[0]) * 0.5;
            out[1] = (aabb[4] - aabb[1]) * 0.5;
            out[2] = (aabb[5] - aabb[2]) * 0.5;

            return out;
        },

        /**
         * Diagonal from min to max
         * @method diagonal
         * @param {kick.math.Vec3} out
         * @param {kick.math.Aabb} aabb
         * @return {kick.math.Vec3} out
         * @static
         */
        diagonal: function (out, aabb) {
            out[0] = aabb[3] - aabb[0];
            out[1] = aabb[4] - aabb[1];
            out[2] = aabb[5] - aabb[2];
            return out;
        },

        /**
         * @method str
         * @param {kick.math.Aabb} aabb
         * @static
         */
        str: function (aabb) {
            return "{(" +
                aabb[0] + "," +
                aabb[1] + "," +
                aabb[2] + "),(" +
                aabb[3] + "," +
                aabb[4] + "," +
                aabb[5] + ")}";
        }
    };
});

define('kick/math/Vec2',["kick/core/Constants"], function (constants) {
    
    var wrapArray = function (array, length) {
        var i,
            index = 0,
            count = array.length / length,
            res = [];
        for (i = 0; i < count; i++, index += length) {
            res[i] = array.subarray(index, index + length);
        }
        return res;
    };

    /**
     * Vec2 - 2 dimensional vector
     * Any javascript array containing at least 2 numeric elements can serve as a vec2
     * @class Vec2
     * @namespace kick.math
     */
    return {
        /**
         * See kick.math.Vec4.wrapArray
         * @method wrapArray
         * @param {Float32Array} array
         * @return {Array_kick.math.Vec2} of vec2
         * @static
         */
        wrapArray: function (array) {
            return wrapArray(array, 2);
        },


        /**
         * Create a continuous array in memory mapped to vec2. <br>
         * @method array
         * @param {Number} count Number of vec 2 to be layed out in memory
         * @param {Object} ref Optional, if set a memory reference is set to ref.mem
         * @return {kick.math.Vec2} New vec2
         * @static
         */
        array: function (count, ref) {
            var memory = new Float32Array(count * 2);
            if (ref) {
                ref.mem = memory;
            }
            return wrapArray(memory, 2);
        },

        /**
         * Creates a new, empty vec2
         *
         * @method create
         * @return {kick.math.Vec2} New vec2
         * @static
         */
        create: function () {
            return new Float32Array(2);
        },

        /**
         * @method clone
         * @param {kick.math.Vec2} a vector to clone
         * @return {kick.math.Vec2} a new 2D vector
         * @static
         */
        clone: function (a) {
            var out = new Float32Array(2);
            out[0] = a[0];
            out[1] = a[1];
            return out;
        },

        /**
         * Creates a new vec2 initialized with the given values
         *
         * @method fromValues
         * @param {Number} x X component
         * @param {Number} y Y component
         * @return {kick.math.Vec2} a new 2D vector
         * @static
         */
        fromValues: function (x, y) {
            var out = new Float32Array(2);
            out[0] = x;
            out[1] = y;
            return out;
        },

        /**
         * Copies the values of one vec2 to another
         *
         * @method copy
         * @param {kick.math.Vec2} out the receiving vector
         * @param {kick.math.Vec2} a the source vector
         * @return {kick.math.Vec2} out
         * @static
         */
        copy: function (out, a) {
            out[0] = a[0];
            out[1] = a[1];
            return out;
        },

        /**
         * Set the components of a vec2 to the given values
         * @method set
         * @param {kick.math.Vec2} out the receiving vector
         * @param {Number} x X component
         * @param {Number} y Y component
         * @return {kick.math.Vec2} out
         * @static
         */
        set: function (out, x, y) {
            out[0] = x;
            out[1] = y;
            return out;
        },

        /**
         * Adds two vec2's
         * @method add
         * @param {kick.math.Vec2} out the receiving vector
         * @param {kick.math.Vec2} a the first operand
         * @param {kick.math.Vec2} b the second operand
         * @return {kick.math.Vec2} out
         * @static
         */
        add: function (out, a, b) {
            out[0] = a[0] + b[0];
            out[1] = a[1] + b[1];
            return out;
        },

        /**
         * Subtracts two vec2's
         * @method subtract
         * @param {kick.math.Vec2} out the receiving vector
         * @param {kick.math.Vec2} a the first operand
         * @param {kick.math.Vec2} b the second operand
         * @return {kick.math.Vec2} out
         * @static
         */
        subtract: function (out, a, b) {
            out[0] = a[0] - b[0];
            out[1] = a[1] - b[1];
            return out;
        },

        /**
         * Multiplies two vec2's
         *
         * @method multiply
         * @param {kick.math.Vec2} out the receiving vector
         * @param {kick.math.Vec2} a the first operand
         * @param {kick.math.Vec2} b the second operand
         * @return {kick.math.Vec2} out
         * @static
         */
        multiply: function (out, a, b) {
            out[0] = a[0] * b[0];
            out[1] = a[1] * b[1];
            return out;
        },

        /**
         * Divides two vec2's
         *
         * @method divide
         * @param {kick.math.Vec2} out the receiving vector
         * @param {kick.math.Vec2} a the first operand
         * @param {kick.math.Vec2} b the second operand
         * @return {kick.math.Vec2} out
         * @static
         */
        divide: function (out, a, b) {
            out[0] = a[0] / b[0];
            out[1] = a[1] / b[1];
            return out;
        },

        /**
         * Returns the minimum of two vec2's
         *
         * @method min
         * @param {kick.math.Vec2} out the receiving vector
         * @param {kick.math.Vec2} a the first operand
         * @param {kick.math.Vec2} b the second operand
         * @return {kick.math.Vec2} out
         * @static
         */
        min: function (out, a, b) {
            out[0] = Math.min(a[0], b[0]);
            out[1] = Math.min(a[1], b[1]);
            return out;
        },

        /**
         * Returns the maximum of two vec2's
         *
         * @method max
         * @param {kick.math.Vec2} out the receiving vector
         * @param {kick.math.Vec2} a the first operand
         * @param {kick.math.Vec2} b the second operand
         * @return {kick.math.Vec2} out
         * @static
         */
        max: function (out, a, b) {
            out[0] = Math.max(a[0], b[0]);
            out[1] = Math.max(a[1], b[1]);
            return out;
        },

        /**
         * Scales a vec2 by a scalar number
         *
         * @method scale
         * @param {kick.math.Vec2} out the receiving vector
         * @param {kick.math.Vec2} a the vector to scale
         * @param {Number} b amount to scale the vector by
         * @return {kick.math.Vec2} out
         * @static
         */
        scale: function (out, a, b) {
            out[0] = a[0] * b;
            out[1] = a[1] * b;
            return out;

        },

        /**
         * Calculates the euclidian distance between two vec2's
         *
         * @method distance
         * @param {kick.math.Vec2} a the first operand
         * @param {kick.math.Vec2} b the second operand
         * @return {Number} distance between a and b
         * @static
         */
        distance: function (a, b) {
            var x = b[0] - a[0],
                y = b[1] - a[1];
            return Math.sqrt(x * x + y * y);
        },

        /**
         * Calculates the squared euclidian distance between two vec2's
         *
         * @method squaredDistance
         * @param {kick.math.Vec2} a the first operand
         * @param {kick.math.Vec2} b the second operand
         * @return {Number} squared distance between a and b
         * @static
         */
        squaredDistance: function (a, b) {
            var x = b[0] - a[0],
                y = b[1] - a[1];
            return x * x + y * y;
        },

        /**
         * Calculates the length of a vec2
         *
         * @method length
         * @param {kick.math.Vec2} a vector to calculate length of
         * @return {Number} length of a
         * @static
         */
        length: function (a) {
            var x = a[0],
                y = a[1];
            return Math.sqrt(x * x + y * y);
        },


        /**
         * Calculates the squared length of a vec2
         *
         * @method squaredLength
         * @param {kick.math.Vec2} a vector to calculate squared length of
         * @return {Number} squared length of a
         * @static
         */
        squaredLength: function (a) {
            var x = a[0],
                y = a[1];
            return x * x + y * y;
        },


        /**
         * Negates the components of a vec2
         *
         * @method negate
         * @param {kick.math.Vec2} out the receiving vector
         * @param {kick.math.Vec2} a vector to negate
         * @return {kick.math.Vec2} out
         * @static
         */
        negate: function (out, a) {
            out[0] = -a[0];
            out[1] = -a[1];
            return out;
        },

        /**
         * Normalize a vec2
         *
         * @method normalize
         * @param {kick.math.Vec2} out the receiving vector
         * @param {kick.math.Vec2} a vector to normalize
         * @return {kick.math.Vec2} out
         * @static
         */
        normalize: function (out, a) {
            var x = a[0],
                y = a[1],
                len = x * x + y * y;
            if (len > 0) {
                //TODO: evaluate use of glm_invsqrt here?
                len = 1 / Math.sqrt(len);
                out[0] = a[0] * len;
                out[1] = a[1] * len;
            }
            return out;
        },

        /**
         * Calculates the dot product of two vec2's
         *
         * @method dot
         * @param {kick.math.Vec2} a the first operand
         * @param {kick.math.Vec2} b the second operand
         * @return {Number} dot product of a and b
         * @static
         */
        dot: function (a, b) {
            return a[0] * b[0] + a[1] * b[1];
        },

        /**
         * Computes the cross product of two vec2's
         * Note that the cross product must by definition produce a 3D vector
         *
         * @method cross
         * @param {kick.math.Vec3} out the receiving vector
         * @param {kick.math.Vec2} a the first operand
         * @param {kick.math.Vec2} b the second operand
         * @return {kick.math.Vec3} out
         * @static
         */
        cross: function (out, a, b) {
            var z = a[0] * b[1] - a[1] * b[0];
            out[0] = out[1] = 0;
            out[2] = z;
            return out;
        },

        /**
         * Performs a linear interpolation between two vec2's
         *
         * @method lerp
         * @param {kick.math.Vec2} out the receiving vector
         * @param {kick.math.Vec2} a the first operand
         * @param {kick.math.Vec2} b the second operand
         * @param {Number} t interpolation amount between the two inputs
         * @return {kick.math.Vec2} out
         * @static
         */
        lerp: function (out, a, b, t) {
            var ax = a[0],
                ay = a[1];
            out[0] = ax + t * (b[0] - ax);
            out[1] = ay + t * (b[1] - ay);
            return out;
        },


        /**
         * Transforms the vec2 with a mat2
         *
         * @method transformMat2
         * @param {kick.math.Vec2} out the receiving vector
         * @param {kick.math.Vec2} a the vector to transform
         * @param {kick.math.Mat2} m matrix to transform with
         * @return {kick.math.Vec2} out
         * @static
         */
        transformMat2: function (out, a, m) {
            var x = a[0],
                y = a[1];
            out[0] = m[0] * x + m[2] * y;
            out[1] = m[1] * x + m[3] * y;
            return out;
        },

        /**
         * Transforms the vec2 with a mat2d
         * @method transformMat2d
         * @param {kick.math.Vec2} out the receiving vector
         * @param {kick.math.Vec2} a the vector to transform
         * @param {kick.math.Mat2d} m matrix to transform with
         * @return {kick.math.Vec2} out
         * @static
         */
        transformMat2d: function(out, a, m) {
            var x = a[0],
                y = a[1];
            out[0] = m[0] * x + m[2] * y + m[4];
            out[1] = m[1] * x + m[3] * y + m[5];
            return out;
        },


        /**
         * Transforms the vec2 with a mat3
         * 3rd vector component is implicitly '1'
         * @method transformMat3
         * @param {kick.math.Vec2} out the receiving vector
         * @param {kick.math.Vec2} a the vector to transform
         * @param {kick.math.Mat3} m matrix to transform with
         * @return {kick.math.Vec2} out
         * @static
         */
        transformMat3: function(out, a, m) {
            var x = a[0],
                y = a[1];
            out[0] = m[0] * x + m[3] * y + m[6];
            out[1] = m[1] * x + m[4] * y + m[7];
            return out;
        },

        /**
         * Transforms the vec2 with a mat4
         * 3rd vector component is implicitly '0'
         * 4th vector component is implicitly '1'
         * @method transformMat4
         * @param {kick.math.Vec2} out the receiving vector
         * @param {kick.math.Vec2} a the vector to transform
         * @param {kick.math.Mat4} m matrix to transform with
         * @return {kick.math.Vec2} out
         * @static
         */
        transformMat4: function(out, a, m) {
            var x = a[0],
                y = a[1];
            out[0] = m[0] * x + m[4] * y + m[12];
            out[1] = m[1] * x + m[5] * y + m[13];
            return out;
        },


        /**
         * Perform some operation over an array of vec2s.
         * @method forEach
         * @param {Array} a the array of vectors to iterate over
         * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed
         * @param {Number} offset Number of elements to skip at the beginning of the array
         * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
         * @param {Function} fn Function to call for each vector in the array
         * @param {Object} [arg] additional argument to pass to fn
         * @return {Array} a
         * @static
         */
        forEach: (function () {
            var vec = new Float32Array(2);

            return function (a, stride, offset, count, fn, arg) {
                var i, l;
                if (!stride) {
                    stride = 2;
                }

                if (!offset) {
                    offset = 0;
                }

                if (count) {
                    l = Math.min((count * stride) + offset, a.length);
                } else {
                    l = a.length;
                }

                for (i = offset; i < l; i += stride) {
                    vec[0] = a[i]; vec[1] = a[i+1];
                    fn(vec, vec, arg);
                    a[i] = vec[0]; a[i+1] = vec[1];
                }

                return a;
            };
        }()),

        /**
         * Test to see if vectors are equal (difference is less than epsilon)
         * @method equal
         * @param {kick.math.Vec2} vec first operand
         * @param {kick.math.Vec2} vec2 second operand
         * @param {Number} epsilon Optional - default value is
         * @return {Boolean} true if two vectors are equals
         * @static
         */
        equal: function (vec, vec2, epsilon) {
            var i;
            if (!epsilon) {
                epsilon = 0.00001;
            }
            for (i = 0; i < 2; i++) {
                if (Math.abs(vec[i] - vec2[i]) > epsilon) {
                    return false;
                }
            }
            return true;
        },

        /**
         * Returns a string representation of a vector
         * @method str
         * @param {kick.math.Vec2} vec vec2 to represent as a string
         * @return {String} string representation of vec
         * @static
         */
        str: function (vec) {
            return '[' + vec[0] + ', ' + vec[1] + ']';
        }

    };
});

define('kick/mesh/MeshData',["kick/core/Constants", "kick/core/Util", "kick/core/ChunkData", "kick/math/Aabb", "kick/math/Vec2", "kick/math/Vec3", "kick/math/Vec4", "kick/math/Mat4"],
    function (Constants, Util, ChunkData, Aabb, Vec2, Vec3, Vec4, Mat4) {
        

        var ASSERT = true,
            MeshData;

        /**
         * Mesh data class.
         * Allows for modifying mesh object easily.
         * This is a pure data class with no WebGL dependency
         * @class MeshData
         * @namespace kick.mesh
         * @param {Object} [config]
         * @constructor
         */
        MeshData = function (config) {
            var data = {},
                thisObj = this,
                _indices = [],
                _interleavedArray,
                _interleavedArrayFormat,
                _vertexAttrLength,
                _usage = 35044,
                _meshType,
                _name,
                clearInterleavedData = function () {
                    _interleavedArray = null;
                    _interleavedArrayFormat = null;
                    _vertexAttrLength = null;
                },
                isVertexDataInitialized = function () {
                    return data.vertex;
                },
                isInterleavedDataInitialized = function () {
                    return _interleavedArray;
                },
                createVertexDataFromInterleavedData = function () {
                    var vertexLength = _interleavedArray.byteLength / (_vertexAttrLength), i, j,
                        attributeName,
                        attributeConfig,
                        offset = 0,
                        ArrayType,
                        floatView;
                    data = {};
                    for (i = 0; i < vertexLength; i++) {
                        for (attributeName in _interleavedArrayFormat) {
                            if (_interleavedArrayFormat.hasOwnProperty(attributeName)) {
                                attributeConfig = _interleavedArrayFormat[attributeName];
                                ArrayType = attributeConfig.type === 5126 ? Float32Array : Int32Array;
                                if (i === 0) {
                                    data[attributeName] = new ArrayType(vertexLength * attributeConfig.size);
                                }

                                floatView = new ArrayType(_interleavedArray, offset + attributeConfig.pointer);
                                for (j = 0; j < attributeConfig.size; j++) {
                                    data[attributeName][i * attributeConfig.size + j] = floatView[j];
                                }
                            }
                        }
                        offset += _vertexAttrLength;
                    }
                },
                /**
                 * @method createGetterSetter
                 * @private
                 * @param {Number} type GL\_FLOAT or GL\_INT
                 * @param {string} name
                 */
                createGetterSetter = function (type, name) {
                    if (type === 5126 || type === 5124) {
                        var TypedArrayType = (type === 5126) ? Float32Array : Int32Array;
                        return {
                            get: function () {
                                if (!isVertexDataInitialized() && isInterleavedDataInitialized()) {
                                    createVertexDataFromInterleavedData();
                                }
                                return data[name];
                            },
                            set: function (newValue) {
                                if (newValue) {
                                    if (data[name] && data[name].length === newValue.length) {
                                        data[name].set(newValue);
                                    } else {
                                        data[name] = new TypedArrayType(newValue);
                                    }
                                } else {
                                    data[name] = null;
                                }
                                clearInterleavedData();
                            }
                        };
                    } else if (ASSERT) {
                        Util.fail("Unexpected type");
                    }
                },
                /**
                 * @method createInterleavedData
                 * @private
                 */
                createInterleavedData = function () {
                    var lengthOfVertexAttributes = [],
                        names = [],
                        types = [],
                        length = 0,
                        vertexAttributes = [],
                        data,
                        i,
                        j,
                        k,
                        vertex = thisObj.vertex,
                        vertexLen = vertex ?  vertex.length / 3 : 0,
                        vertexOffset = 0,
                        description = {},
                        dataArrayBuffer,
                        floatView,
                        intView,
                        dataSrc,
                        dataSrcLen,
                        SIZE_OF_FLOAT_OR_INT = 4,
                        addAttributes = function (name, size, type) {
                            var array = thisObj[name];

                            if (array) {
                                lengthOfVertexAttributes.push(size);
                                names.push(name);
                                types.push(type);
                                vertexAttributes.push(array);
                                description[name] = {
                                    pointer: length * 4,
                                    size: size,
                                    normalized: false,
                                    type: type,
                                    name: name
                                };
                                length += size;
                            }
                        };

                    addAttributes("vertex", 3, 5126);
                    addAttributes("normal", 3, 5126);
                    addAttributes("uv1", 2, 5126);
                    addAttributes("uv2", 2, 5126);
                    addAttributes("tangent", 4, 5126);
                    addAttributes("color", 4, 5126);
                    addAttributes("int1", 1, 5124);
                    addAttributes("int2", 2, 5124);
                    addAttributes("int3", 3, 5124);
                    addAttributes("int4", 4, 5124);

                    // copy data into array
                    if (_interleavedArray && _interleavedArray.length === length * vertexLen * SIZE_OF_FLOAT_OR_INT){
                        dataArrayBuffer = _interleavedArray;
                    } else {
                        dataArrayBuffer = new ArrayBuffer(length * vertexLen * SIZE_OF_FLOAT_OR_INT);
                    }

                    floatView = new Float32Array(dataArrayBuffer, 0);
                    intView = new Int32Array(dataArrayBuffer, 0);
                    for (i = 0; i < vertexLen; i++) {
                        for (j = 0; j < names.length; j++) {
                            dataSrc = vertexAttributes[j];
                            dataSrcLen = lengthOfVertexAttributes[j];

                            if (types[j] === 5126) {
                                data = floatView;
                            } else {
                                data = intView;
                            }

                            for (k = 0; k < dataSrcLen; k++) {
                                data[vertexOffset] = dataSrc[i * dataSrcLen + k];
                                vertexOffset += 1;
                            }
                        }
                    }
                    _interleavedArray = dataArrayBuffer;
                    _interleavedArrayFormat = description;
                    _vertexAttrLength = length * SIZE_OF_FLOAT_OR_INT;
                };

            /**
             * Saves the MeshData into binary form (ArrayBuffer)
             * @method serialize
             * @return ArrayBuffer
             */
            this.serialize = function () {
                var subMeshes,
                    numberOfSubMeshes,
                    i,
                    chunkData = new ChunkData();
                chunkData.setArrayBuffer(1, thisObj.interleavedArray);
                chunkData.setString(2, JSON.stringify(thisObj.interleavedArrayFormat));
                chunkData.setString(3, thisObj.name || "MeshData");
                subMeshes = thisObj.subMeshes;
                numberOfSubMeshes = subMeshes.length;
                chunkData.setNumber(4, numberOfSubMeshes);
                chunkData.setNumber(5, thisObj.vertexAttrLength);
                chunkData.setNumber(6, thisObj.usage);
                for (i = 0; i < numberOfSubMeshes; i++) {
                    chunkData.set(10 + i, subMeshes[i]);
                }

                return chunkData.serialize();
            };

            /**
             * Restores the
             * @method deserialize
             * @param {ArrayBuffer} data
             * @return Boolean
             */
            this.deserialize = function (data) {
                var chunkData = new ChunkData(),
                    numberOfSubMeshes,
                    submeshes,
                    i;
                if (chunkData.deserialize(data)) {
                    thisObj.interleavedArray = chunkData.getArrayBuffer(1);
                    thisObj.interleavedArrayFormat = JSON.parse(chunkData.getString(2));
                    thisObj.name = chunkData.getString(3);
                    numberOfSubMeshes = chunkData.getNumber(4);
                    thisObj.vertexAttrLength = chunkData.getNumber(5);
                    thisObj.usage = chunkData.getNumber(6) || 35044;
                    submeshes = [];
                    for (i = 0; i < numberOfSubMeshes; i++) {
                        submeshes[i] = chunkData.get(10 + i);
                    }
                    thisObj.subMeshes = submeshes;

                    return true;
                }
                return false;
            };


            Object.defineProperties(this, {
                /**
                 * Note that this property is not cached. Use kick.mesh.Mesh.aabb for a cached version.
                 * Readonly
                 * @property aabb
                 * @type kick.math.Aabb
                 */
                aabb: {
                    get: function () {
                        var vertexLength,
                            aabb,
                            i,
                            vertex = thisObj.vertex;
                        if (!vertex) {
                            return null;
                        }
                        vertexLength = vertex.length;
                        aabb = Aabb.create();
                        for (i = 0; i < vertexLength; i += 3) {
                            Aabb.addPointIndexed(aabb, aabb, vertex, i);
                        }
                        return aabb;
                    }
                },
                /**
                 * Must be either GL_STATIC_DRAW, GL_DYNAMIC_DRAW or GL_STREAM_DRAW.
                 * @property usage
                 * @type Number
                 * @default GL_STATIC_DRAW
                 */
                usage: {
                    get: function () {
                        return _usage;
                    },
                    set: function (newValue) {
                        if (ASSERT) {
                            if (newValue !== 35044 && newValue !== 35048 && newValue !== 35040) {
                                Util.fail("MeshData.usage Must be either GL_STATIC_DRAW, GL_DYNAMIC_DRAW or GL_STREAM_DRAW");
                            }
                        }
                        _usage = newValue;
                    }
                },
                /**
                 * @property name
                 * @type string
                 */
                name: {
                    get: function () {
                        return _name;
                    },
                    set: function (newValue) {
                        _name = newValue;
                    }
                },
                /**
                 * @property interleavedArray
                 * @type Float32Array
                 */
                interleavedArray: {
                    get: function () {
                        if ((!isInterleavedDataInitialized()) && isVertexDataInitialized()) {
                            createInterleavedData();
                        }
                        return _interleavedArray;
                    },
                    set: function (newValue) {
                        if (ASSERT) {
                            if (newValue && !(newValue instanceof ArrayBuffer)) {
                                Util.fail("MeshData.interleavedArray must be an ArrayBuffer");
                            }
                        }
                        if (!newValue) {
                            clearInterleavedData();
                        } else {
                            _interleavedArray = newValue;
                        }
                    }
                },
                /**
                 * Describes the interleaved array format.<br>
                 * The description is an object with a number of properties.<br>
                 * Each property name corresponds to the name of the vertex attribute.<br>
                 * Each property has the format <br>
                 * @example
                 *     {
                 *         pointer: 0, // {Number}
                 *         size: 0, //{Number} number of elements
                 *         normalized: 0, // {Boolean} should be normalized or not
                 *         type: 0 // {GL_FLOAT or GL_INT}
                 *     }
                 * <br>
                 * Example:<br>
                 * @example
                 *     var vertexOffset = meshData.interleavedArrayFormat["vertex"].pointer;
                 *
                 * @property interleavedArrayFormat
                 * @type Object
                 */
                interleavedArrayFormat: {
                    get: function () {
                        if ((!isInterleavedDataInitialized()) && isVertexDataInitialized()) {
                            createInterleavedData();
                        }
                        return _interleavedArrayFormat;
                    },
                    set: function (newValue) {
                        if (ASSERT) {
                            var n,
                                object;
                            if (newValue !== null) {
                                for (n in newValue) {
                                    if (newValue.hasOwnProperty(n)){
                                        object = newValue[n];
                                        if (typeof object === "object") {
                                            if (typeof (object.pointer) !== "number" ||
                                                    typeof (object.size) !== "number" ||
                                                    typeof (object.normalized) !== "boolean" ||
                                                    typeof (object.type) !== "number") {
                                                Util.fail("Invalid object signature - expected {pointer:,size:,normalized:,type:}");
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        if (!newValue) {
                            clearInterleavedData();
                        } else {
                            _interleavedArrayFormat = newValue;
                        }
                    }
                },
                /**
                 * The length of vertexAttributes for one vertex in bytes
                 * @property vertexAttrLength
                 * @type Number
                 */
                vertexAttrLength: {
                    get: function () {
                        if ((!isInterleavedDataInitialized()) && isVertexDataInitialized()) {
                            createInterleavedData();
                        }
                        return _vertexAttrLength;
                    },
                    set: function (newValue) {
                        if (ASSERT) {
                            if (typeof newValue !== "number" || newValue < 0) {
                                Util.fail("Invalid MeshData.vertexAttrLength - expected a real number");
                            }
                        }
                        if (!newValue) {
                            clearInterleavedData();
                        } else {
                            _vertexAttrLength = newValue;
                        }
                    }
                },
                /**
                 * Vertex attribute.
                 * Vertex (vec3)
                 * @property vertex
                 * @type Array_Number
                 */
                vertex: createGetterSetter(5126, "vertex"),
                /**
                 * Vertex attribute.
                 * Normal (vec3)
                 * @property normal
                 * @type Array_Number
                 */
                normal: createGetterSetter(5126, "normal"),
                /**
                 * Vertex attribute.
                 * UV1 (vec2)
                 * @property uv1
                 * @type Array_Number
                 */
                uv1: createGetterSetter(5126, "uv1"),
                /**
                 * Vertex attribute.
                 * UV2 (vec2)
                 * @property uv2
                 * @type Array_Number
                 */
                uv2: createGetterSetter(5126, "uv2"),
                /**
                 * Vertex attribute.
                 * Tangent (vec4)
                 * @property tangent
                 * @type Array_Number
                 */
                tangent: createGetterSetter(5126, "tangent"),
                /**
                 * Vertex attribute.
                 * Color (vec4)
                 * @property color
                 * @type Array_Number
                 */
                color: createGetterSetter(5126, "color"),
                /**
                 * Vertex attribute.
                 * Integer attribute (one Int32)
                 * @property int1
                 * @type Array_Number
                 */
                int1: createGetterSetter(5124, "int1"),
                /**
                 * Vertex attribute.
                 * Integer attribute (two Int32)
                 * @property int2
                 * @type Array_Number
                 */
                int2: createGetterSetter(5124, "int2"),
                /**
                 * Vertex attribute.
                 * Integer attribute (three Int32)
                 * @property int3
                 * @type Array_Number
                 */
                int3: createGetterSetter(5124, "int3"),
                /**
                 * Vertex attribute.
                 * Integer attribute (four Int32)
                 * @property int4
                 * @type Array_Number
                 */
                int4: createGetterSetter(5124, "int4"),
                /**
                 * Vertex attribute.
                 * indices (integer).
                 * indices is shortcut for subMeshes[0]
                 * @property indices
                 * @type Array_Number
                 */
                indices: {
                    get: function () {
                        if (_indices === 0) {
                            return null;
                        }
                        return _indices[0];
                    },
                    set: function (newValue) {
                        if (newValue && !(newValue instanceof Uint16Array)) {
                            newValue = new Uint16Array(newValue);
                        }
                        if (_indices[0] && isVertexDataInitialized()) {
                            clearInterleavedData();
                        }
                        if (newValue) {
                            _indices[0] = newValue;
                        }
                    }
                },
                /**
                 * Indices (integer) - One index array for each submesh
                 * @property subMeshes
                 * @type Array_Array_Number
                 */
                subMeshes: {
                    get: function () {
                        return _indices;
                    },
                    set: function (newValue) {
                        var i;
                        for (i = 0; i < newValue.length; i++) {
                            if (newValue[i] && !(newValue[i] instanceof Uint16Array)) {
                                newValue[i] = new Uint16Array(newValue[i]);
                            }
                        }
                        _indices = newValue;
                    }
                },
                /**
                 * Must be GL\_TRIANGLES, GL\_TRIANGLE\_FAN, GL\_TRIANGLE\_STRIP, GL\_POINTS, or GL\_LINES
                 * @property meshType
                 * @type Number
                 */
                meshType: {
                    get: function () {
                        return _meshType;
                    },
                    set: function (newValue) {
                        if (ASSERT) {
                            if (newValue !== 1 &&
                                    newValue !== 4 &&
                                    newValue !== 6 &&
                                    newValue !== 5 &&
                                    newValue !== 0
                                ) {
                                Util.fail("MeshData.meshType must be `GL_TRIANGLES, GL_TRIANGLE_FAN, GL_TRIANGLE_STRIP` or `GL_POINTS`");
                            }
                        }
                        _meshType = newValue;
                    }
                }
            });

            /**
             * @method isValid
             * @return {Boolean} if mesh is considered valid
             */
            this.isValid = function () {
                if (!isVertexDataInitialized() && isInterleavedDataInitialized()) {
                    createVertexDataFromInterleavedData();
                }
                var vertexCount = data.vertex.length / 3,
                    j,
                    i;
                for (j = 0; j < _indices.length; j++) {
                    for (i = _indices[j].length - 1; i >= 0; i--) {
                        if (_indices[j][i] >= vertexCount) {
                            Util.warn("_indices[" + j + "][" + i + "] >= vertexCount");
                            return false;
                        }
                    }
                }
                return true;
            };

            /**
             * @method isVertexDataInitialized
             * @return {Boolean} return true if vertex data is initialized
             */
            this.isVertexDataInitialized = isVertexDataInitialized;

            /**
             * @method isInterleavedDataInitialized
             * @return {Boolean} return true if interleaved data is initialized
             */
            this.isInterleavedDataInitialized = isInterleavedDataInitialized;

            /**
             * Creates a copy of the mesh and transform the vertex positions of the MeshData with a mat4.
             * Note that normals are not modified - so they may need to renormalized.
             * @method transform
             * @param {kick.math.Mat4} transformMatrix
             * @return {kick.mesh.MeshData} transformed mesh
             */
            this.transform = function (transformMatrix) {
                var copy = new MeshData(this),
                    wrappedVec3Array = Vec3.wrapArray(copy.vertex),
                    j;
                for (j = wrappedVec3Array.length - 1; j >= 0; j--) {
                    Mat4.multiplyVec3(wrappedVec3Array[j], transformMatrix, wrappedVec3Array[j]);
                }
                return copy;
            };
            /**
             * Combine two meshes and returns the combined mesh as a new Mesh object.<br>
             * The two meshes must have the same meshType. Only vertex attributes existing in
             * both mesh objects are transferred<br>
             * Triangle fans cannot be combined
             * @method combine
             * @param {kick.mesh.MeshData} secondMesh
             * @param {kick.math.Mat4} transform Optional transformation matrix
             * @return {kick.mesh.MeshData} mesh object or null if incompatible objects
             */
            this.combine = function (secondMesh, transform) {
                if (thisObj.meshType !== secondMesh.meshType || thisObj.meshType === 6) {
                    if (ASSERT) {
                        if (thisObj.meshType !== secondMesh.meshType) {
                            Util.fail("Mesh.combine does not support different meshTypes");
                        } else {
                            Util.fail("Mesh.combine does not support triangle fans");
                        }
                        return null;
                    }
                    return null;
                }
                var dataNames = ["vertex", "normal", "uv1", "uv2", "tangent", "color", "int1", "int2", "int3", "int4", "indices"],
                    i,
                    name,
                    appendObject,
                    newConfig;

                for (i = dataNames.length - 1; i >= 0; i--) {
                    name = dataNames[i];
                    if (!thisObj[name] || !secondMesh[name]) {
                        dataNames.splice(i, 1); // remove dataName from array
                    }
                }

                appendObject = function (config, source, indexOffset) {
                    var i, j, name, data, len;
                    for (i = dataNames.length - 1; i >= 0; i--) {
                        name = dataNames[i];
                        if (!config[name]) { // if undefined
                            config[name] = Util.typedArrayToArray(source[name]);
                        } else {
                            data = source[name];
                            if (indexOffset && name === "indices") {
                                // take a copy
                                data = new Uint16Array(data);
                                // add offset to copy
                                len = data.length;
                                for (j = 0; j < len; j++) {
                                    data[j] += indexOffset;
                                }
                            }
                            for (j = 0; j < data.length; j++) {
                                config[name].push(data[j]);
                            }
                        }
                    }
                };

                newConfig = {
                    meshType: thisObj.meshType
                };

                if (transform) {
                    secondMesh = secondMesh.transform(transform);
                }

                appendObject(newConfig, thisObj, 0);
                appendObject(newConfig, secondMesh, this.vertex.length / 3);

                if (thisObj.meshType === 5) {
                    // create two degenerate triangles to connect the two triangle strips
                    newConfig.indices.splice(thisObj.indices, 0, newConfig.indices[thisObj.indices.length], newConfig.indices[thisObj.indices.length + 1]);
                }

                return new MeshData(newConfig);
            };

            (function init() {
                if (!config) {
                    config = {};
                }

                var copyVertexData = function () {
                        thisObj.vertex = config.vertex ? new Float32Array(config.vertex) : null;
                        thisObj.normal = config.normal ? new Float32Array(config.normal) : null;
                        thisObj.uv1 = config.uv1 ? new Float32Array(config.uv1) : null;
                        thisObj.uv2 = config.uv2 ? new Float32Array(config.uv2) : null;
                        thisObj.tangent = config.tangent ? new Float32Array(config.tangent) : null;
                        thisObj.color = config.color ? new Float32Array(config.color) : null;
                        thisObj.int1 = config.int1 ? new Int32Array(config.int1) : null;
                        thisObj.int2 = config.int2 ? new Int32Array(config.int2) : null;
                        thisObj.int3 = config.int3 ? new Int32Array(config.int3) : null;
                        thisObj.int4 = config.int4 ? new Int32Array(config.int4) : null;
                    },
                    copyInterleavedData = function () {
                        thisObj.interleavedArray = config.interleavedArray;
                        thisObj.interleavedArrayFormat = config.interleavedArrayFormat;
                        thisObj.vertexAttrLength = config.vertexAttrLength;
                    };

                if (config instanceof MeshData) {
                    if (config.isVertexDataInitialized()) {
                        copyVertexData();
                    } else {
                        if (ASSERT) {
                            if (!config.isInterleavedDataInitialized()) {
                                Util.fail("Either vertex or interleaved data should be initialized");
                            }
                        }
                        copyInterleavedData();
                    }
                } else {
                    if (config.vertex) {
                        copyVertexData();
                    } else if (config.interleavedArray) {
                        copyInterleavedData();
                    }
                }
                thisObj.name = config.name;
                thisObj.indices = config.indices;
                thisObj.meshType = Util.hasProperty(config,"meshType") ?  config.meshType : 4;
            }());
        };

        /**
         * Create an array of empty UV coordinates
         * @method createUv1
         */
        MeshData.prototype.createUv1 = function () {
            var vertexCount = this.vertex.length / 3;
            this.uv1 = new Float32Array(vertexCount*2);
        };

        /**
         * Create an array of empty UV coordinates
         * @method createUv2
         */
        MeshData.prototype.createUv2 = function () {
            var vertexCount = this.vertex.length / 3;
            this.uv2 = new Float32Array(vertexCount * 2);
        };


        /**
         * Recalculate the angle weighted vertex normals based on the triangle mesh
         * @method recalculateNormals
         * @return {Boolean} false if meshtype is not GL\_TRIANGLES or GL\_TRIANGLE\_STRIP
         */
        MeshData.prototype.recalculateNormals = function () {
            var vertexCount = this.vertex.length / 3,
                triangles = Util.convertSubMeshesToTriangleIndices(this.subMeshes, this.meshType, true),
                triangleCount = triangles.length / 3,
                vertex = Vec3.wrapArray(this.vertex),
                a,
                normalArrayRef = {},
                normalArray = Vec3.array(vertexCount, normalArrayRef),
                v1v2 = Vec3.create(),
                v1v3 = Vec3.create(),
                v2v3Alias = v1v3,
                temp = v1v2,
                weight1,
                weight2,
                normal = Vec3.create(),
                i1,
                i2,
                i3,
                v1,
                v2,
                v3;
            if (!triangles) {
                return false;
            }

            for (a = 0; a < triangleCount; a++) {
                i1 = triangles[a * 3];
                i2 = triangles[a * 3 + 1];
                i3 = triangles[a * 3 + 2];

                v1 = vertex[i1];
                v2 = vertex[i2];
                v3 = vertex[i3];

                Vec3.subtract(v1v2, v2, v1);
                Vec3.subtract(v1v3, v3, v1);
                Vec3.normalize(v1v2, v1v2);
                Vec3.normalize(v1v3, v1v3);
                Vec3.cross(normal, v1v2, v1v3);
                Vec3.normalize(normal, normal);

                weight1 = Math.acos(Math.max(-1, Math.min(1, Vec3.dot(v1v2, v1v3))));
                Vec3.subtract(v2v3Alias, v3, v2);
                Vec3.normalize(v2v3Alias, v2v3Alias);
                weight2 = Math.PI - Math.acos(Math.max(-1, Math.min(1, Vec3.dot(v1v2, v2v3Alias))));
                Vec3.add(normalArray[i1], normalArray[i1], Vec3.scale(temp, normal, weight1));
                Vec3.add(normalArray[i2], normalArray[i2], Vec3.scale(temp, normal, weight2));
                Vec3.add(normalArray[i3], normalArray[i3], Vec3.scale(temp, normal, Math.PI - weight1 - weight2));
            }
            for (a = 0; a < vertexCount; a++) {
                Vec3.normalize(normalArray[a], normalArray[a]);
            }
            this.normal =  normalArrayRef.mem;
        };

        /**
         * Recalculates the tangents on a triangle mesh.<br>
         * Algorithm is based on<br>
         *   Lengyel, Eric. Computing Tangent Space Basis Vectors for an Arbitrary Mesh.<br>
         *   Terathon Software 3D Graphics Library, 2001.<br>
         *   http://www.terathon.com/code/tangent.html
         * @method recalculateTangents
         * @return {Boolean} false if meshtype is not supported
         */
        MeshData.prototype.recalculateTangents = function () {
            var vertex = Vec3.wrapArray(this.vertex),
                vertexCount = vertex.length,
                normal = Vec3.wrapArray(this.normal),
                texcoord = Vec2.wrapArray(this.uv1),
                triangles = Util.convertSubMeshesToTriangleIndices(this.subMeshes, this.meshType, true),
                triangleCount = triangles.length / 3,
                tangentBuffer = new Float32Array(vertexCount * 4),
                tangent = Vec4.wrapArray(tangentBuffer),
                tan1 = Vec3.array(vertexCount),
                tan2 = Vec3.array(vertexCount),
                a,
                tmpFloat = 0,
                tmpVec3 = Vec3.create(),
                i1,
                i2,
                i3,
                v1,
                v2,
                v3,
                w1,
                w2,
                w3,
                x1,
                x2,
                y1,
                y2,
                z1,
                z2,
                s1,
                s2,
                t1,
                t2,
                r,
                t,
                n,
                sdir,
                tdir;
            if (!triangles) {
                return false;
            }

            for (a = 0; a < triangleCount; a++) {
                i1 = triangles[a * 3];
                i2 = triangles[a * 3 + 1];
                i3 = triangles[a * 3 + 2];

                v1 = vertex[i1];
                v2 = vertex[i2];
                v3 = vertex[i3];

                w1 = texcoord[i1];
                w2 = texcoord[i2];
                w3 = texcoord[i3];

                x1 = v2[0] - v1[0];
                x2 = v3[0] - v1[0];
                y1 = v2[1] - v1[1];
                y2 = v3[1] - v1[1];
                z1 = v2[2] - v1[2];
                z2 = v3[2] - v1[2];

                s1 = w2[0] - w1[0];
                s2 = w3[0] - w1[0];
                t1 = w2[1] - w1[1];
                t2 = w3[1] - w1[1];

                r = 1.0 / (s1 * t2 - s2 * t1);
                sdir = Vec3.clone([(t2 * x1 - t1 * x2) * r,
                    (t2 * y1 - t1 * y2) * r,
                    (t2 * z1 - t1 * z2) * r]);
                tdir = Vec3.clone([(s1 * x2 - s2 * x1) * r,
                    (s1 * y2 - s2 * y1) * r,
                    (s1 * z2 - s2 * z1) * r]);

                Vec3.add(tan1[i1], tan1[i1], sdir);
                Vec3.add(tan1[i2], tan1[i2], sdir);
                Vec3.add(tan1[i3], tan1[i3], sdir);

                Vec3.add(tan2[i1], tan2[i1], tdir);
                Vec3.add(tan2[i2], tan2[i2], tdir);
                Vec3.add(tan2[i3], tan2[i3], tdir);
            }
            for (a = 0; a < vertexCount; a++) {
                n = normal[a];
                t = tan1[a];

                // Gram-Schmidt orthogonalize
                // tangent[a] = (t - n * Dot(n, t)).Normalize();
                tmpFloat = Vec3.dot(n, t);
                Vec3.scale(tmpVec3, n, tmpFloat);
                Vec3.subtract(tmpVec3, t, tmpVec3);
                Vec3.normalize(tmpVec3, tmpVec3);
                Vec3.copy(tangent[a], tmpVec3);

                // Calculate handedness
                // tangent[a].w = (Dot(Cross(n, t), tan2[a]) < 0.0F) ? -1.0F : 1.0F;
                tangent[a][3] = (Vec3.dot(Vec3.cross(Vec3.create(), n, t), tan2[a]) < 0.0) ? -1.0 : 1.0;
            }
            this.tangent = tangentBuffer;
            return true;
        };

        return MeshData;
    });

define('kick/mesh/MeshDataFactory',["./MeshData", "kick/math/Vec2", "kick/math/Vec3", "kick/core/Constants", "kick/core/Util"],
    function (MeshData, Vec2, Vec3, Constants, Util) {
    

    /**
     * Class responsible for creating MeshData objects
     * @class MeshDataFactory
     * @namespace kick.mesh
     * @static
     */
    return {
        /**
         * Create a single point (in 0,0,0)
         * @method createPointData
         * @static
         * @return {kick.core.MeshData} point mesh
         */
        createPointData: function () {
            return new MeshData({
                name: "Point",
                vertex: [
                    0, 0, 0
                ],
                meshType: 0,
                indices: [0]
            });
        },
        /**
         * Creates a triangle in the XY plane
         * @method createTriangleData
         * @static
         * @return {kick.core.MeshData} triangle mesh
         */
        createTriangleData : function () {
            var sqrt75 = Math.sqrt(0.75);
            return new MeshData({
                name: "Triangle",
                vertex: [
                    0, 1, 0,
                    -sqrt75, -0.5, 0,
                    sqrt75, -0.5, 0
                ],
                uv1: [
                    0.5, 1,
                    0.125, 0.25,
                    1 - 0.125, 0.25
                ],
                normal: [
                    0, 0, 1,
                    0, 0, 1,
                    0, 0, 1
                ],
                indices: [0, 1, 2]
            });
        },
        /**
         * Creates a disc in the XY plane
         * @method createDiscData
         * @param {Number} slices
         * @static
         * @return {kick.core.MeshData} triangle mesh
         */
        createDiscData : function (slices) {
            if (!slices){
                slices = 20;
            }
            var vertices = [0,0,0],
                uvs = [0.5,0.5],
                normals = [0,0,1],
                indices = [0],
                i;

            for (i = 0; i <= slices; i++) {
                var fraction = 2 * Math.PI * i / slices;
                vertices.push(Math.sin(fraction));
                vertices.push(-Math.cos(fraction));
                vertices.push(0);
                uvs.push(Math.sin(fraction) * 0.5 + 0.5);
                uvs.push(-Math.cos(fraction) * 0.5 + 0.5);
                normals.push(0);
                normals.push(0);
                normals.push(1);
                indices.push(indices.length);
            }
            return new MeshData({
                name: "Triangle",
                vertex: vertices,
                uv1: uvs,
                normal: normals,
                indices: indices,
                meshType: 6
            });
        },

        /**
         * Create a plane in the XY plane (made of two triangles). The mesh objects has UVs and normals attributes.
         * @method createPlaneData
         * @static
         * @return {kick.mesh.MeshData} plane mesh
         */
        createPlaneData : function () {
            return new MeshData({
                name: "Plane",
                vertex: [
                    1, -1, 0,
                    1, 1, 0,
                    -1, -1, 0,
                    -1, 1, 0

                ],
                uv1: [
                    1, 0,
                    1, 1,
                    0, 0,
                    0, 1
                ],
                normal: [
                    0, 0, 1,
                    0, 0, 1,
                    0, 0, 1,
                    0, 0, 1
                ],
                indices: [0, 1, 2, 2, 1, 3]
            });
        },

        /**
         * Create a UV sphere
         * @method createUVSphereData
         * @static
         * @param {Number} slices Optional default value is 64
         * @param {Number} stacks Optional default value is 32
         * @param {Number} radius
         * @return {kick.mesh.MeshData} uv-sphere mesh
         */
        createUVSphereData : function (slices, stacks, radius) {
            if (!slices || slices < 3) {
                slices = 64;
            }
            if (!stacks || stacks < 2) {
                stacks = 32;
            }
            if (!radius) {
                radius = 1;
            }
            var j, i,
                vertexCount = (stacks+1) * (slices + 1),
                normalsMemory = {},
                normals = Vec3.array(vertexCount, normalsMemory),
                verticesMemory = {},
                vertices = Vec3.array(vertexCount, verticesMemory),
                uvsMemory = {},
                uvs = Vec2.array(vertexCount, uvsMemory),
                indices = [],
                piDivStacks = Math.PI / stacks,
                PIDiv2 = Math.PI / 2,
                PI2 = Math.PI * 2,
                index = 0,
                latitude1,
                sinLat1,
                cosLat1,
                longitude,
                sinLong, cosLong,
                x1, y1, z1,
                meshDataConf;
            // create vertices
            for (j = 0; j <= stacks; j++) {
                latitude1 = piDivStacks * j - PIDiv2;
                sinLat1 = Math.sin(latitude1);
                cosLat1 = Math.cos(latitude1);
                for (i = 0; i <= slices; i++) {
                    longitude = (PI2 / slices) * i;
                    sinLong = Math.sin(longitude);
                    cosLong = Math.cos(longitude);
                    x1 = cosLong * cosLat1;
                    y1 = sinLat1;
                    z1 = sinLong * cosLat1;
                    Vec3.copy(normals[index], [x1, y1, z1]);
                    Vec2.copy(uvs[index], [1 - i / slices, j / stacks]);
                    Vec3.copy(vertices[index], [radius * x1, radius * y1, radius * z1]);
                    index++;
                }
            }
            // create indices
            for (j = 0; j < stacks; j++) {
                if (j > 0) {
                    indices.push(j * (slices + 1)); // make degenerate
                }
                for (i = 0; i <= slices; i++) {
                    index = j * (slices + 1) + i;
                    indices.push(index);
                    indices.push(index + slices + 1);
                }
                if (j + 1 < stacks) {
                    indices.push(index + slices + 1); // make degenerate
                }
            }
            meshDataConf = {
                name: "UVSphere",
                vertex: verticesMemory.mem,
                uv1: uvsMemory.mem,
                normal: normalsMemory.mem,
                indices: indices,
                meshType: 5
            };
            return new MeshData(meshDataConf);
        },

        /**
         * Create a code of size length. The cube has colors, normals and UVs.<br>
         * Note that the length of the sides are 2*length
         * @method createCubeData
         * @static
         * @param {Number} length Optional, default value is 1.0
         * @return {kick.mesh.Mesh} cube mesh
         */
        createCubeData : function (length) {
            if (!length) {
                length = 1;
            }

            //    v6----- v5
            //   /|      /|
            //  v1------v0|
            //  | |     | |
            //  | |v7---|-|v4
            //  |/      |/
            //  v2------v3
            var meshDataConf = {
                name: "Cube",
                vertex: [
                    length, length, length,
                    -length, length, length,
                    -length, -length, length,
                    length, -length, length,        // v0-v1-v2-v3
                    length, length, length,
                    length, -length, length,
                    length, -length, -length,
                    length, length, -length,        // v0-v3-v4-v5
                    length, length, length,
                    length, length, -length,
                    -length, length, -length,
                    -length, length, length,        // v0-v5-v6-v1
                    -length, length, length,
                    -length, length, -length,
                    -length, -length, -length,
                    -length, -length, length,    // v1-v6-v7-v2
                    -length, -length, -length,
                    length, -length, -length,
                    length, -length, length,
                    -length, -length, length,    // v7-v4-v3-v2
                    length, -length, -length,
                    -length, -length, -length,
                    -length, length, -length,
                    length, length, -length   // v4-v7-v6-v5
                ],
                uv1: [
                    1, 1,
                    0, 1,
                    0, 0,
                    1, 0,                    // v0-v1-v2-v3
                    0, 1,
                    0, 0,
                    1, 0,
                    1, 1,              // v0-v3-v4-v5
                    1, 0,
                    1, 1,
                    0, 1,
                    0, 0,              // v0-v5-v6-v1 (top)
                    1, 1,
                    0, 1,
                    0, 0,
                    1, 0,              // v1-v6-v7-v2
                    1, 1,
                    0, 1,
                    0, 0,
                    1, 0,              // v7-v4-v3-v2 (bottom)
                    0, 0,
                    1, 0,
                    1, 1,
                    0, 1             // v4-v7-v6-v5
                ],
                normal: [
                    0, 0, 1,
                    0, 0, 1,
                    0, 0, 1,
                    0, 0, 1,             // v0-v1-v2-v3
                    1, 0, 0,
                    1, 0, 0,
                    1, 0, 0,
                    1, 0, 0,              // v0-v3-v4-v5
                    0, 1, 0,
                    0, 1, 0,
                    0, 1, 0,
                    0, 1, 0,              // v0-v5-v6-v1
                    -1, 0, 0,
                    -1, 0, 0,
                    -1, 0, 0,
                    -1, 0, 0,          // v1-v6-v7-v2
                    0, -1, 0,
                    0, -1, 0,
                    0, -1, 0,
                    0, -1, 0,         // v7-v4-v3-v2
                    0, 0, -1,
                    0, 0, -1,
                    0, 0, -1,
                    0, 0, -1        // v4-v7-v6-v5
                ],
                color: [
                    1, 1, 1, 1,
                    1, 1, 0, 1,
                    1, 0, 0, 1,
                    1, 0, 1, 1,              // v0-v1-v2-v3
                    1, 1, 1, 1,
                    1, 0, 1, 1,
                    0, 0, 1, 1,
                    0, 1, 1, 1,              // v0-v3-v4-v5
                    1, 1, 1, 1,
                    0, 1, 1, 1,
                    0, 1, 0, 1,
                    1, 1, 0, 1,              // v0-v5-v6-v1
                    1, 1, 0, 1,
                    0, 1, 0, 1,
                    0, 0, 0, 1,
                    1, 0, 0, 1,              // v1-v6-v7-v2
                    0, 0, 0, 1,
                    0, 0, 1, 1,
                    1, 0, 1, 1,
                    1, 0, 0, 1,              // v7-v4-v3-v2
                    0, 0, 1, 1,
                    0, 0, 0, 1,
                    0, 1, 0, 1,
                    0, 1, 1, 1             // v4-v7-v6-v5
                ],
                indices: [
                    0, 1, 2,
                    0, 2, 3,
                    4, 5, 6,
                    4, 6, 7,
                    8, 9, 10,
                    8, 10, 11,
                    12, 13, 14,
                    12, 14, 15,
                    16, 17, 18,
                    16, 18, 19,
                    20, 21, 22,
                    20, 22, 23]
            };
            return new MeshData(meshDataConf);
        }
    };
});

define('kick/material/GLSLConstants',[], function () {
    

    /**
     * Contains glsl source code constants<br>
     * The content of this class is generated from the content of the file folder src/glsl
     * @class GLSLConstants
     * @namespace kick.material
     * @static
     */
    // created by include_glsl_files.js - do not edit content
/**
* GLSL file content
* @property __error_fs.glsl
* @type String
*/
/**
* GLSL file content
* @property __error_vs.glsl
* @type String
*/
/**
* GLSL file content
* @property __pick_fs.glsl
* @type String
*/
/**
* GLSL file content
* @property __pick_normal_fs.glsl
* @type String
*/
/**
* GLSL file content
* @property __pick_normal_vs.glsl
* @type String
*/
/**
* GLSL file content
* @property __pick_uv_fs.glsl
* @type String
*/
/**
* GLSL file content
* @property __pick_uv_vs.glsl
* @type String
*/
/**
* GLSL file content
* @property __pick_vs.glsl
* @type String
*/
/**
* GLSL file content
* @property __shadowmap_fs.glsl
* @type String
*/
/**
* GLSL file content
* @property __shadowmap_vs.glsl
* @type String
*/
/**
* GLSL file content
* @property bloom_1_pass_fs.glsl
* @type String
*/
/**
* GLSL file content
* @property bloom_2_pass_fs.glsl
* @type String
*/
/**
* GLSL file content
* @property bloom_3_pass_fs.glsl
* @type String
*/
/**
* GLSL file content
* @property bloom_pass_vs.glsl
* @type String
*/
/**
* GLSL file content
* @property bumped_specular_fs.glsl
* @type String
*/
/**
* GLSL file content
* @property bumped_specular_vs.glsl
* @type String
*/
/**
* GLSL file content
* @property diffuse_fs.glsl
* @type String
*/
/**
* GLSL file content
* @property diffuse_vs.glsl
* @type String
*/
/**
* GLSL file content
* @property light.glsl
* @type String
*/
/**
* GLSL file content
* @property shadowmap.glsl
* @type String
*/
/**
* GLSL file content
* @property skybox_fs.glsl
* @type String
*/
/**
* GLSL file content
* @property skybox_vs.glsl
* @type String
*/
/**
* GLSL file content
* @property specular_fs.glsl
* @type String
*/
/**
* GLSL file content
* @property specular_vs.glsl
* @type String
*/
/**
* GLSL file content
* @property transparent_diffuse_fs.glsl
* @type String
*/
/**
* GLSL file content
* @property transparent_diffuse_vs.glsl
* @type String
*/
/**
* GLSL file content
* @property transparent_point_sprite_fs.glsl
* @type String
*/
/**
* GLSL file content
* @property transparent_point_sprite_vs.glsl
* @type String
*/
/**
* GLSL file content
* @property transparent_specular_fs.glsl
* @type String
*/
/**
* GLSL file content
* @property transparent_specular_vs.glsl
* @type String
*/
/**
* GLSL file content
* @property transparent_unlit_fs.glsl
* @type String
*/
/**
* GLSL file content
* @property transparent_unlit_vs.glsl
* @type String
*/
/**
* GLSL file content
* @property unlit_fs.glsl
* @type String
*/
/**
* GLSL file content
* @property unlit_vertex_color_fs.glsl
* @type String
*/
/**
* GLSL file content
* @property unlit_vertex_color_vs.glsl
* @type String
*/
/**
* GLSL file content
* @property unlit_vs.glsl
* @type String
*/
return {"__error_fs.glsl":"precision highp float;\nvoid main(void)\n{\ngl_FragColor = vec4(1.0,0.5, 0.9, 1.0);\n}","__error_vs.glsl":"attribute vec3 vertex;\nuniform mat4 _mvProj;\nvoid main(void) {\ngl_Position = _mvProj * vec4(vertex, 1.0);\n} ","__pick_fs.glsl":"precision mediump float;\nvarying vec4 gameObjectUID;\nvoid main(void)\n{\ngl_FragColor = gameObjectUID;\n}","__pick_normal_fs.glsl":"precision mediump float;\nvarying vec3 vNormal;\nvoid main(void)\n{\ngl_FragColor = vec4(vNormal,0);\n}","__pick_normal_vs.glsl":"attribute vec3 vertex;\nattribute vec3 normal;\nuniform mat4 _mvProj;\nuniform mat3 _norm;\nvarying vec3 vNormal;\nvoid main(void) {\n// compute position\ngl_Position = _mvProj * vec4(vertex, 1.0);\nvNormal = (_norm * normal) / 2.0 + vec3(0.5, 0.5, 0.5);\n}","__pick_uv_fs.glsl":"precision mediump float;\nvarying vec2 vUV;\nvoid main(void)\n{\ngl_FragColor = vec4(vUV, 0, 0);\n}","__pick_uv_vs.glsl":"attribute vec3 vertex;\nattribute vec2 uv1;\nuniform mat4 _mvProj;\nuniform mat3 _norm;\nvarying vec2 vUV;\nvoid main(void) {\n// compute position\ngl_Position = _mvProj * vec4(vertex, 1.0);\nvUV = uv1;\n}","__pick_vs.glsl":"attribute vec3 vertex;\nuniform mat4 _mvProj;\nuniform vec4 _gameObjectUID;\nvarying vec4 gameObjectUID;\nvoid main(void) {\n// compute position\ngl_Position = _mvProj * vec4(vertex, 1.0);\ngameObjectUID = _gameObjectUID;\n}","__shadowmap_fs.glsl":"precision highp float;\n#pragma include \"shadowmap.glsl\"\nvoid main() {\ngl_FragColor = packDepth( gl_FragCoord.z );\n}\n","__shadowmap_vs.glsl":"attribute vec3 vertex;\nuniform mat4 _mvProj;\nvoid main(void) {\ngl_Position = _mvProj * vec4(vertex, 1.0);\n} ","bloom_1_pass_fs.glsl":"#ifdef GL_ES\nprecision highp float;\n#endif\nvarying vec2 vUv;\nuniform sampler2D mainTexture;\nconst float LumThresh = 0.75;\nfloat luma( vec3 color ) {\nreturn 0.2126 * color.r + 0.7152 * color.g +0.0722 * color.b;\n}\nvoid main(void)\n{\nvec4 val = vec4(texture2D(mainTexture,vUv).xyz,1.0);\nfloat weight = clamp( luma(val.rgb) - LumThresh, 0.0, 1.0 ) * (1.0 / (1.0 - LumThresh) );\ngl_FragColor = val * weight;\n}","bloom_2_pass_fs.glsl":"#ifdef GL_ES\nprecision highp float;\n#endif\nvarying vec2 vUv;\nuniform sampler2D mainTexture;\nconst float LumThresh = 0.75;\nuniform float height;\nvoid main(void)\n{\nfloat dy = 1.0 / height;\nvec4 sum = vec4(0.0);\nsum += texture2D(mainTexture, vUv + vec2(0.0,-dy*9.0)) * 0.016745;\nsum += texture2D(mainTexture, vUv + vec2(0.0,-dy*8.0)) * 0.023526;\nsum += texture2D(mainTexture, vUv + vec2(0.0,-dy*7.0)) * 0.031756;\nsum += texture2D(mainTexture, vUv + vec2(0.0,-dy*6.0)) * 0.041186;\nsum += texture2D(mainTexture, vUv + vec2(0.0,-dy*5.0)) * 0.051320;\nsum += texture2D(mainTexture, vUv + vec2(0.0,-dy*4.0)) * 0.061442;\nsum += texture2D(mainTexture, vUv + vec2(0.0,-dy*3.0)) * 0.070675;\nsum += texture2D(mainTexture, vUv + vec2(0.0,-dy*2.0)) * 0.078108;\nsum += texture2D(mainTexture, vUv + vec2(0.0,-dy*1.0)) * 0.082937;\nsum += texture2D(mainTexture, vUv) * 0.084613;\nsum += texture2D(mainTexture, vUv + vec2(0.0,dy*1.0)) * 0.082937;\nsum += texture2D(mainTexture, vUv + vec2(0.0,dy*2.0)) * 0.078108;\nsum += texture2D(mainTexture, vUv + vec2(0.0,dy*3.0)) * 0.070675;\nsum += texture2D(mainTexture, vUv + vec2(0.0,dy*4.0)) * 0.061442;\nsum += texture2D(mainTexture, vUv + vec2(0.0,dy*5.0)) * 0.051320;\nsum += texture2D(mainTexture, vUv + vec2(0.0,dy*6.0)) * 0.041186;\nsum += texture2D(mainTexture, vUv + vec2(0.0,dy*7.0)) * 0.031756;\nsum += texture2D(mainTexture, vUv + vec2(0.0,dy*8.0)) * 0.023526;\nsum += texture2D(mainTexture, vUv + vec2(0.0,dy*9.0)) * 0.016745;\ngl_FragColor = sum;\n}","bloom_3_pass_fs.glsl":"#ifdef GL_ES\nprecision highp float;\n#endif\nvarying vec2 vUv;\nuniform sampler2D mainTexture;\nuniform sampler2D originTexture;\nconst float BloomAmount = 1.0;\nuniform float width;\nvoid main(void)\n{\nfloat dy = 1.0 / width;\nvec4 sum = vec4(0.0);\nsum += texture2D(mainTexture, vUv + vec2(-dy*9.0,0.0)) * 0.016745;\nsum += texture2D(mainTexture, vUv + vec2(-dy*8.0,0.0)) * 0.023526;\nsum += texture2D(mainTexture, vUv + vec2(-dy*7.0,0.0)) * 0.031756;\nsum += texture2D(mainTexture, vUv + vec2(-dy*6.0,0.0)) * 0.041186;\nsum += texture2D(mainTexture, vUv + vec2(-dy*5.0,0.0)) * 0.051320;\nsum += texture2D(mainTexture, vUv + vec2(-dy*4.0,0.0)) * 0.061442;\nsum += texture2D(mainTexture, vUv + vec2(-dy*3.0,0.0)) * 0.070675;\nsum += texture2D(mainTexture, vUv + vec2(-dy*2.0,0.0)) * 0.078108;\nsum += texture2D(mainTexture, vUv + vec2(-dy*1.0,0.0)) * 0.082937;\nsum += texture2D(mainTexture, vUv) * 0.084613;\nsum += texture2D(mainTexture, vUv + vec2(dy*1.0,0.0)) * 0.082937;\nsum += texture2D(mainTexture, vUv + vec2(dy*2.0,0.0)) * 0.078108;\nsum += texture2D(mainTexture, vUv + vec2(dy*3.0,0.0)) * 0.070675;\nsum += texture2D(mainTexture, vUv + vec2(dy*4.0,0.0)) * 0.061442;\nsum += texture2D(mainTexture, vUv + vec2(dy*5.0,0.0)) * 0.051320;\nsum += texture2D(mainTexture, vUv + vec2(dy*6.0,0.0)) * 0.041186;\nsum += texture2D(mainTexture, vUv + vec2(dy*7.0,0.0)) * 0.031756;\nsum += texture2D(mainTexture, vUv + vec2(dy*8.0,0.0)) * 0.023526;\nsum += texture2D(mainTexture, vUv + vec2(dy*9.0,0.0)) * 0.016745;\ngl_FragColor = sum * BloomAmount + texture2D(originTexture, vUv);\n}\n","bloom_pass_vs.glsl":"attribute vec3 vertex;\nattribute vec2 uv1;\nuniform mat4 _mvProj;\nvarying vec2 vUv;\nvoid main(void) {\ngl_Position = _mvProj * vec4(vertex, 1.0);\nvUv = uv1;\n}","bumped_specular_fs.glsl":"precision mediump float;\nvarying vec2 v_uv;\nvarying vec3 viewVec;\nvarying vec3 lightVec;\nvarying vec3 pointLight[LIGHTS];\nvarying vec4 vShadowMapCoord;\n#pragma include \"light.glsl\"\n#pragma include \"shadowmap.glsl\"\nuniform float specularExponent;\nuniform vec4 specularColor;\nuniform vec4 mainColor;\nuniform sampler2D mainTexture;\nuniform sampler2D normalMap;\nvoid getDirectionalLight(vec3 normal, vec3 ecLightDir, vec3 reflection, vec3 colorIntensity, float specularExponent, out vec3 diffuse, out float specular){\nfloat diffuseContribution = max(dot(normal, ecLightDir), 0.0);\nif ( diffuseContribution > 0.0){\nfloat specularContribution = max(dot(normal, reflection), 0.0);\nspecular = pow(specularContribution, specularExponent);\n} else {\nspecular = 0.0;\n}\ndiffuse = (colorIntensity * diffuseContribution);\n}\nvoid getPointLight(vec3 normal, vec3 ecPosition, vec3 ecLightPos2[LIGHTS], mat3 pLights[LIGHTS],float specularExponent, out vec3 diffuse, out float specular){\ndiffuse = vec3(0.0, 0.0, 0.0);\nspecular = 0.0;\nvec3 eye = vec3(0.0,0.0,1.0);\nfor (int i=0;i<LIGHTS;i++){\nvec3 ecLightPos = ecLightPos2[i];\nvec3 colorIntensity = pLights[i][1];\nvec3 attenuationVector = pLights[i][2];\n// direction from surface to light position\nvec3 VP = ecLightPos - ecPosition;\n// compute distance between surface and light position\nfloat d = length(VP);\n// normalize the vector from surface to light position\nVP = normalize(VP);\n// compute attenuation\nfloat attenuation = 1.0 / dot(vec3(1.0,d,d*d),attenuationVector); // short for constA + liniearA * d + quadraticA * d^2\nvec3 halfVector = normalize(VP + eye);\nfloat nDotVP = max(0.0, dot(normal, VP));\nfloat nDotHV = max(0.0, dot(normal, halfVector));\nfloat pf;\nif (nDotVP <= 0.0){\npf = 0.0;\n} else {\npf = pow(nDotHV, specularExponent);\n}\nbool isLightEnabled = (attenuationVector[0]+attenuationVector[1]+attenuationVector[2])>0.0;\nif (isLightEnabled){\ndiffuse += colorIntensity * nDotVP * attenuation;\nspecular += pf * attenuation;\n}\n}\n}\nvoid main()\n{\nvec4 base = texture2D(mainTexture, v_uv);\nvec3 bump = normalize(texture2D(normalMap, v_uv).xyz * 2.0 - vec3(1.0,1.0,1.0));\nvec3 vVec = normalize(viewVec);\nvec3 reflection = reflect(-vVec, bump);\nvec3 lVec = normalize(lightVec);\nvec3 diffuse;\nfloat specular;\nvec3 colorIntensity = _dLight[1];\ngetDirectionalLight(lVec, bump ,reflection, colorIntensity, specularExponent, diffuse, specular);\nvec3 diffusePoint;\nfloat specularPoint;\ngetPointLight(bump,viewVec,pointLight, _pLights,specularExponent,diffusePoint,specularPoint);\nfloat visibility;\nif (SHADOWS){\nvisibility = computeLightVisibility(vShadowMapCoord);\n} else {\nvisibility = 1.0;\n}\nvec3 color = max((diffuse +diffusePoint)*visibility,_ambient.xyz)*mainColor.xyz;\ngl_FragColor = vec4(base.xyz*color.xyz, 1.0) + vec4((specular +specularPoint)*specularColor.xyz,1.0);\t\n}\n","bumped_specular_vs.glsl":"// Based on\n// http://www.geeks3d.com/20091019/shader-library-bump-mapping-shader-with-multiple-lights-glsl/\nattribute vec4 vertex;\nattribute vec2 uv1;\nattribute vec3 normal;\nattribute vec4 tangent;\nuniform mat3 _norm;\nuniform mat4 _mvProj;\nuniform mat4 _mv;\nuniform mat4 _world2object;\nuniform vec4 _worldCamPos;\nuniform mat4 _lightMat;\nvarying vec2 v_uv;\nvarying vec3 viewVec;\nvarying vec3 lightVec;\nvarying vec4 vShadowMapCoord;\n#pragma include \"light.glsl\"\nvarying vec3 pointLight[LIGHTS];\nvoid main()\n{\nvec3 lightVecDir = _dLight[0]; // light direction in eye coordinates\ngl_Position = _mvProj * vertex;\nv_uv = uv1;\n\tvec3 n = normalize(_norm * normal);\nvec3 t = normalize(_norm * tangent.xyz);\nvec3 b = cross(n, t);\nmat3 tbn = mat3(t,b,n);\nvec3 v;\nvec3 vVertex = vec3(_mv * vertex);\nvec3 lVec = lightVecDir;\nlightVec = lVec * tbn;\nvec3 vVec = -vVertex;\nviewVec = vVec * tbn;\nfor (int i=0;i<LIGHTS;i++){\npointLight[i] = _pLights[i][0] * tbn;\n}\nvShadowMapCoord = _lightMat * v;\n} ","diffuse_fs.glsl":"precision mediump float;\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vEcPosition;\nvarying vec4 vShadowMapCoord;\nuniform vec4 mainColor;\nuniform sampler2D mainTexture;\n#pragma include \"light.glsl\"\n#pragma include \"shadowmap.glsl\"\nvoid main(void)\n{\nvec3 normal = normalize(vNormal);\nvec3 directionalLight = getDirectionalLightDiffuse(normal,_dLight);\nvec3 pointLight = getPointLightDiffuse(normal,vEcPosition, _pLights);\nfloat visibility;\nif (SHADOWS){\nvisibility = computeLightVisibility(vShadowMapCoord);\n} else {\nvisibility = 1.0;\n}\nvec3 color = max((directionalLight+pointLight)*visibility,_ambient.xyz)*mainColor.xyz;\ngl_FragColor = vec4(texture2D(mainTexture,vUv).xyz*color, 1.0);\n}\n","diffuse_vs.glsl":"attribute vec3 vertex;\nattribute vec3 normal;\nattribute vec2 uv1;\nuniform mat4 _mvProj;\nuniform mat4 _mv;\nuniform mat4 _lightMat;\nuniform mat3 _norm;\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec4 vShadowMapCoord;\nvarying vec3 vEcPosition;\nvoid main(void) {\nvec4 v = vec4(vertex, 1.0);\ngl_Position = _mvProj * v;\nvEcPosition = (_mv * v).xyz;\nvUv = uv1;\nvNormal = normalize(_norm * normal);\nvShadowMapCoord = _lightMat * v;\n} ","light.glsl":"vec3 getPointLightDiffuse(vec3 normal, vec3 ecPosition, mat3 pLights[LIGHTS]){\nvec3 diffuse = vec3(0.0);\nfor (int i=0;i<LIGHTS;i++){\nvec3 ecLightPos = pLights[i][0]; // light position in eye coordinates\nvec3 colorIntensity = pLights[i][1];\nvec3 attenuationVector = pLights[i][2];\n// direction from surface to light position\nvec3 VP = ecLightPos - ecPosition;\n// compute distance between surface and light position\nfloat d = length(VP);\n// normalize the vector from surface to light position\nVP = normalize(VP);\n// compute attenuation\nfloat attenuation = 1.0 / dot(vec3(1.0,d,d*d),attenuationVector); // short for constA + liniearA * d + quadraticA * d^2\nfloat nDotVP = max(0.0, dot(normal, VP));\ndiffuse += colorIntensity*nDotVP * attenuation;\n}\nreturn diffuse;\n}\nvoid getPointLight(vec3 normal, vec3 ecPosition, mat3 pLights[LIGHTS],float specularExponent, out vec3 diffuse, out float specular){\ndiffuse = vec3(0.0, 0.0, 0.0);\nspecular = 0.0;\nvec3 eye = vec3(0.0,0.0,1.0);\nfor (int i=0;i<LIGHTS;i++){\nvec3 ecLightPos = pLights[i][0]; // light position in eye coordinates\nvec3 colorIntensity = pLights[i][1];\nvec3 attenuationVector = pLights[i][2];\n// direction from surface to light position\nvec3 VP = ecLightPos - ecPosition;\n// compute distance between surface and light position\nfloat d = length(VP);\n// normalize the vector from surface to light position\nVP = normalize(VP);\n// compute attenuation\nfloat attenuation = 1.0 / dot(vec3(1.0,d,d*d),attenuationVector); // short for constA + liniearA * d + quadraticA * d^2\nvec3 halfVector = normalize(VP + eye);\nfloat nDotVP = max(0.0, dot(normal, VP));\nfloat nDotHV = max(0.0, dot(normal, halfVector));\nfloat pf;\nif (nDotVP <= 0.0){\npf = 0.0;\n} else {\npf = pow(nDotHV, specularExponent);\n}\nbool isLightEnabled = (attenuationVector[0]+attenuationVector[1]+attenuationVector[2])>0.0;\nif (isLightEnabled){\ndiffuse += colorIntensity * nDotVP * attenuation;\nspecular += pf * attenuation;\n}\n}\n}\nvec3 getDirectionalLightDiffuse(vec3 normal, mat3 dLight){\nvec3 ecLightDir = dLight[0]; // light direction in eye coordinates\nvec3 colorIntensity = dLight[1];\nfloat diffuseContribution = max(dot(normal, ecLightDir), 0.0);\nreturn (colorIntensity * diffuseContribution);\n}\n// assumes that normal is normalized\nvoid getDirectionalLight(vec3 normal, mat3 dLight, float specularExponent, out vec3 diffuse, out float specular){\nvec3 ecLightDir = dLight[0]; // light direction in eye coordinates\nvec3 colorIntensity = dLight[1];\nvec3 halfVector = dLight[2];\nfloat diffuseContribution = max(dot(normal, ecLightDir), 0.0);\nfloat specularContribution = max(dot(normal, halfVector), 0.0);\nspecular = pow(specularContribution, specularExponent);\ndiffuse = (colorIntensity * diffuseContribution);\n}\nuniform mat3 _dLight;\nuniform vec3 _ambient;\nuniform mat3 _pLights[LIGHTS];\n","shadowmap.glsl":"uniform sampler2D _shadowMapTexture;\nconst float shadowBias = 0.005;\nvec4 packDepth( const in float depth ) {\nconst vec4 bitShift = vec4( 16777216.0, 65536.0, 256.0, 1.0 );\nconst vec4 bitMask = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );\nvec4 res = fract( depth * bitShift );\nres -= res.xxyz * bitMask;\nreturn res;\n}\nfloat unpackDepth(const in vec4 rgba_depth)\n{\nconst vec4 bit_shift = vec4(1.0/(256.0*256.0*256.0), 1.0/(256.0*256.0), 1.0/256.0, 1.0);\nfloat depth = dot(rgba_depth, bit_shift);\nreturn depth;\n}\nfloat computeLightVisibility(vec4 vShadowMapCoord){\nvec3 shadowCoord = vShadowMapCoord.xyz / vShadowMapCoord.w;\nif (shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0){\nvec4 packedShadowDepth = texture2D(_shadowMapTexture,shadowCoord.xy);\nbool isMaxDepth = dot(packedShadowDepth, vec4(1.0,1.0,1.0,1.0))==4.0;\nif (!isMaxDepth){\nfloat shadowDepth = unpackDepth(packedShadowDepth);\nif (shadowDepth > shadowCoord.z - shadowBias){\nreturn 1.0;\n}\nreturn 0.0;\n}\n}\nreturn 1.0; // if outside shadow map, then not occcluded\n}","skybox_fs.glsl":"precision mediump float;\nuniform vec4 mainColor;\nuniform samplerCube mainTexture;\nvarying vec3 vPos;\nvoid main(void)\n{\ngl_FragColor = textureCube(mainTexture,vPos)*mainColor;\n}","skybox_vs.glsl":"attribute vec4 vertex;\nuniform mat4 _mvProj;\nuniform mat4 _v;\nvarying vec3 vPos;\nvoid main(void) {\ngl_Position = _mvProj * vertex;\nvPos = (vertex * _v).xyz; // inverse view direction * pos\n}","specular_fs.glsl":"precision mediump float;\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vEcPosition;\nvarying vec4 vShadowMapCoord;\nuniform vec4 mainColor;\nuniform float specularExponent;\nuniform vec4 specularColor;\nuniform sampler2D mainTexture;\n#pragma include \"light.glsl\"\n#pragma include \"shadowmap.glsl\"\nvoid main(void)\n{\nvec3 normal = normalize(vNormal);\nvec3 diffuse;\nfloat specular;\ngetDirectionalLight(normal, _dLight, specularExponent, diffuse, specular);\nvec3 diffusePoint;\nfloat specularPoint;\ngetPointLight(normal,vEcPosition, _pLights,specularExponent,diffusePoint,specularPoint);\nfloat visibility;\nif (SHADOWS){\nvisibility = computeLightVisibility(vShadowMapCoord);\n} else {\nvisibility = 1.0;\n}\nvec3 color = max((diffuse+diffusePoint)*visibility,_ambient.xyz)*mainColor.xyz;\ngl_FragColor = vec4(texture2D(mainTexture,vUv).xyz*color.xyz, 1.0)+vec4((specular+specularPoint)*specularColor.xyz,0.0);\n}\n","specular_vs.glsl":"attribute vec3 vertex;\nattribute vec3 normal;\nattribute vec2 uv1;\nuniform mat4 _mvProj;\nuniform mat4 _mv;\nuniform mat4 _lightMat;\nuniform mat3 _norm;\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vEcPosition;\nvarying vec4 vShadowMapCoord;\nvoid main(void) {\nvec4 v = vec4(vertex, 1.0);\ngl_Position = _mvProj * v;\nvUv = uv1;\nvEcPosition = (_mv * v).xyz;\nvNormal= normalize(_norm * normal);\nvShadowMapCoord = _lightMat * v;\n} ","transparent_diffuse_fs.glsl":"precision mediump float;\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vEcPosition;\nuniform vec4 mainColor;\nuniform float specularExponent;\nuniform vec4 specularColor;\nuniform sampler2D mainTexture;\n#pragma include \"light.glsl\"\nvoid main(void)\n{\nvec3 normal = normalize(vNormal);\nvec3 diffuseDirectionalLight = getDirectionalLightDiffuse(normal,_dLight);\nvec3 diffusePointLight = getPointLightDiffuse(normal,vEcPosition, _pLights);\nvec4 color = vec4(max(diffuseDirectionalLight+diffusePointLight,_ambient.xyz),1.0)*mainColor;\ngl_FragColor = texture2D(mainTexture,vUv)*color;\n}\n","transparent_diffuse_vs.glsl":"attribute vec3 vertex;\nattribute vec3 normal;\nattribute vec2 uv1;\nuniform mat4 _mvProj;\nuniform mat3 _norm;\nuniform mat4 _mv;\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vEcPosition;\nvoid main(void) {\nvec4 v = vec4(vertex, 1.0);\n// compute position\ngl_Position = _mvProj * v;\nvEcPosition = (_mv * v).xyz;\nvUv = uv1;\n// compute light info\nvNormal= normalize(_norm * normal);\n} ","transparent_point_sprite_fs.glsl":"precision mediump float;\nuniform sampler2D mainTexture;\nuniform vec4 mainColor;\nvoid main(void)\n{\n\tvec2 UVflippedY = gl_PointCoord;\n\tUVflippedY.y = 1.0 - UVflippedY.y;\ngl_FragColor = texture2D(mainTexture, UVflippedY) * mainColor;\n}\n\t","transparent_point_sprite_vs.glsl":"attribute vec3 vertex;\nuniform mat4 _mvProj;\nuniform float pointSize;\nvoid main(void) {\n\tgl_Position = _mvProj * vec4(vertex, 1.0);\ngl_PointSize = pointSize / gl_Position.w;\n} ","transparent_specular_fs.glsl":"precision mediump float;\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vEcPosition;\nuniform vec4 mainColor;\nuniform float specularExponent;\nuniform vec4 specularColor;\nuniform sampler2D mainTexture;\n#pragma include \"light.glsl\"\nvoid main(void)\n{\nvec3 normal = normalize(vNormal);\nvec3 diffuse;\nfloat specular;\ngetDirectionalLight(normal, _dLight, specularExponent, diffuse, specular);\nvec3 diffusePoint;\nfloat specularPoint;\ngetPointLight(normal,vEcPosition, _pLights,specularExponent,diffusePoint,specularPoint);\nvec4 color = vec4(max(diffuse+diffusePoint,_ambient.xyz),1.0)*mainColor;\ngl_FragColor = texture2D(mainTexture,vUv)*color+vec4((specular+specularPoint)*specularColor.xyz,0.0);\n}\n","transparent_specular_vs.glsl":"attribute vec3 vertex;\nattribute vec3 normal;\nattribute vec2 uv1;\nuniform mat4 _mvProj;\nuniform mat4 _mv;\nuniform mat3 _norm;\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vEcPosition;\nvoid main(void) {\nvec4 v = vec4(vertex, 1.0);\n// compute position\ngl_Position = _mvProj * v;\nvEcPosition = (_mv * v).xyz;\nvUv = uv1;\n// compute light info\nvNormal= normalize(_norm * normal);\n} ","transparent_unlit_fs.glsl":"precision mediump float;\nvarying vec2 vUv;\nuniform vec4 mainColor;\nuniform sampler2D mainTexture;\nvoid main(void)\n{\ngl_FragColor = texture2D(mainTexture,vUv)*mainColor;\n}\n","transparent_unlit_vs.glsl":"attribute vec3 vertex;\nattribute vec2 uv1;\nuniform mat4 _mvProj;\nvarying vec2 vUv;\nvoid main(void) {\ngl_Position = _mvProj * vec4(vertex, 1.0);\nvUv = uv1;\n}","unlit_fs.glsl":"precision highp float;\nvarying vec2 vUv;\nuniform vec4 mainColor;\nuniform sampler2D mainTexture;\nvoid main(void)\n{\ngl_FragColor = vec4(texture2D(mainTexture,vUv).xyz*mainColor.xyz,1.0);\n}\n","unlit_vertex_color_fs.glsl":"precision mediump float;\nvarying vec2 vUv;\nvarying vec4 vColor;\nuniform vec4 mainColor;\nuniform sampler2D mainTexture;\nvoid main(void)\n{\ngl_FragColor = vec4(texture2D(mainTexture,vUv).xyz*mainColor.xyz*vColor.xyz,1.0);\n}\n","unlit_vertex_color_vs.glsl":"attribute vec3 vertex;\nattribute vec2 uv1;\nattribute vec4 color;\nuniform mat4 _mvProj;\nvarying vec2 vUv;\nvarying vec4 vColor;\nvoid main(void) {\ngl_Position = _mvProj * vec4(vertex, 1.0);\nvUv = uv1;\nvColor = color;\n}","unlit_vs.glsl":"attribute vec3 vertex;\nattribute vec2 uv1;\nuniform mat4 _mvProj;\nvarying vec2 vUv;\nvoid main(void) {\ngl_Position = _mvProj * vec4(vertex, 1.0);\nvUv = uv1;\n}"};
});

define('kick/core/BuiltInResourceProvider',["./Util", "kick/mesh/MeshDataFactory", "kick/material/GLSLConstants", "./Constants"], function (Util, MeshDataFactory, GLSLConstants, Constants) {
    

    var ASSERT = true;

    /**
     * Responsible for providing the built-in resources (such as textures, shaders and mesh data).
     * All build-in resources have the prefix kickjs
     * @class BuiltInResourceProvider
     * @namespace kick.core
     * @constructor
     * @extends kick.core.ResourceProvider
     * @param {kick.core.Engine} engine
     * @private
     */
    return function (engine) {
        var gl = engine.gl,
            thisObj = this;
        Object.defineProperties(this, {
            /**
             * Returns kickjs
             * @property protocol
             * @type String
             * @final
             */
            protocol: {
                value: "kickjs://"
            }
        });

        /**
         * <ul>
         * <li><b>Triangle</b> Url: kickjs://mesh/triangle/</li>
         * <li><b>Plane</b> Url: kickjs://mesh/plane/<br></li>
         * <li><b>Disc</b> Url: kickjs://mesh/disc/?slides=20<br></li>
         * <li><b>UVSphere</b> Url: kickjs://mesh/uvsphere/?slides=20&stacks=10&radius=1.0<br>Note that the parameters is optional</li>
         * <li><b>Cube</b> Url: kickjs://mesh/cube/?length=1.0<br>Note that the parameters is optional</li>
         * <li><b>Point</b> Url: kickjs://mesh/point/</li>
         * </ul>
         * @method getMeshData
         * @param {String} url
         * @param {kick.mesh.Mesh} meshDestination
         * @param {ResourceTracker} [resourceTracker]
         */
        this.getMeshData = function (url, meshDestination, resourceTracker) {
            var meshDataObj,
                slices,
                stacks,
                radius,
                length,
                getParameterInt = Util.getParameterInt,
                getParameterFloat = Util.getParameterFloat;
            if (resourceTracker && resourceTracker.resourceLoadingStarted){
                resourceTracker.resourceLoadingStarted(url, meshDestination);
            }
            if (url.indexOf("kickjs://mesh/triangle/") === 0) {
                meshDataObj = MeshDataFactory.createTriangleData();
            } else if (url.indexOf("kickjs://mesh/plane/") === 0) {
                meshDataObj = MeshDataFactory.createPlaneData();
            } else if (url.indexOf("kickjs://mesh/disc/") === 0) {
                slices = getParameterInt(url, "slices");
                meshDataObj = MeshDataFactory.createDiscData(slices);
            } else if (url.indexOf("kickjs://mesh/uvsphere/") === 0) {
                slices = getParameterInt(url, "slices");
                stacks = getParameterInt(url, "stacks");
                radius = getParameterFloat(url, "radius");
                meshDataObj = MeshDataFactory.createUVSphereData(slices, stacks, radius);
            } else if (url.indexOf("kickjs://mesh/cube/") === 0) {
                length = getParameterFloat(url, "length");
                meshDataObj = MeshDataFactory.createCubeData(length);
            } else if (url.indexOf("kickjs://mesh/point/") === 0) {
                meshDataObj = MeshDataFactory.createPointData();
            } else {
                Util.fail("No meshdata found for " + url);
                if (resourceTracker && resourceTracker.resourceLoadingStarted){
                    resourceTracker.resourceLoadingFailed(url, meshDestination);
                }
                return;
            }

            meshDestination.meshData = meshDataObj;
            if (resourceTracker && resourceTracker.resourceLoadingStarted){
                resourceTracker.resourceLoadingFinished(url, meshDestination);
            }
        };

        /**
         * Create a default shader config based on a URL<br>
         * The following shaders are available:
         *  <ul>
         *  <li><b>Default</b> Url: kickjs://shader/default/</li>
         *  <li><b>Specular</b> Url: kickjs://shader/specular/</li>
         *  <li><b>Diffuse</b> Url: kickjs://shader/diffuse/</li>
         *  <li><b>Unlit</b> Url: kickjs://shader/unlit/</li>
         *  <li><b>Unlit_no_depth</b> Url: kickjs://shader/unlit_no_depth/</li>
         *  <li><b>Bumped Specular</b> Url: kickjs://shader/bumped\_specular/</li>
         *  <li><b>Transparent Point Unlit</b> Url: kickjs://shader/point\_transparent\_unlit/</li>
         *  <li><b>Transparent Specular</b> Url: kickjs://shader/transparent\_specular/</li>
         *  <li><b>Transparent Unlit</b> Url: kickjs://shader/transparent\_unlit/</li>
         *  <li><b>Particles</b> Url: kickjs://shader/particles/</li>
         *  <li><b>Skybox</b> Url: kickjs://shader/skybox/</li>
         *  <li><b>Shadowmap</b> Url: kickjs://shader/\_\_shadowmap/</li>
         *  <li><b>Pick</b> Url: kickjs://shader/\_\_pick/</li>
         *  <li><b>Error</b> Url: kickjs://shader/\_\_error/<br></li>
         *  </ul>
         * @method getShaderData
         * @param {String} url
         * @param {kick.material.Shader} shaderDestination
         */
        this.getShaderData = function (url, shaderDestination, resourceTracker) {
            var i, config,
                vertexShaderSrc,
                fragmentShaderSrc,
                blend = false,
                polygonOffsetEnabled = false,
                depthMask = true,
                faceCulling = 1029,
                zTest = 513,
                renderOrder = 1000,
                glslConstants = GLSLConstants,
                defaultUniforms = {},
                compareAndSetShader = function (shaderName) {
                    var res = url.indexOf("kickjs://shader/" + shaderName + "/") === 0;
                    if (res) {
                        vertexShaderSrc = glslConstants[shaderName + "_vs.glsl"];
                        fragmentShaderSrc = glslConstants[shaderName + "_fs.glsl"];
                        if (shaderName.indexOf("transparent_") === 0) {
                            blend = true;
                            depthMask = false;
                            renderOrder = 2000;
                        }

                        else if (shaderName === "__shadowmap") {
                            polygonOffsetEnabled = true;
                        }
                        else if (shaderName === "specular" || shaderName === "transparent_specular") {
                            defaultUniforms = {
                                mainColor: [1, 1, 1, 1],
                                mainTexture: engine.project.load(engine.project.ENGINE_TEXTURE_WHITE),
                                specularColor: [1, 1, 1, 1],
                                specularExponent: 50
                            };
                        }
                        else if (shaderName === "diffuse" ||
                                shaderName === "transparent_diffuse" ||
                                shaderName === "unlit" ||
                                shaderName === "unlit_vertex_color" ||
                                shaderName === "transparent_unlit") {
                            defaultUniforms = {
                                mainColor: [1, 1, 1, 1],
                                mainTexture: engine.project.load(engine.project.ENGINE_TEXTURE_WHITE)
                            };
                        }
                        else if (shaderName === "bumped_specular"){
                            defaultUniforms = {
                                mainColor: [1, 1, 1, 1],
                                mainTexture: engine.project.load(engine.project.ENGINE_TEXTURE_WHITE),
                                normalMap: engine.project.load(engine.project.ENGINE_TEXTURE_DEFAULT_NORMAL),
                                specularColor: [1, 1, 1, 1],
                                specularExponent: 50
                            };
                        }
                        else if (shaderName === "transparent_point_sprite"){
                            defaultUniforms = {
                                mainColor: [1, 1, 1, 1],
                                mainTexture: engine.project.load(engine.project.ENGINE_TEXTURE_WHITE),
                                pointSize: [50]
                            };
                        }
                        else if (shaderName === "particles"){
                            defaultUniforms = {
                                pointSize: [50]
                            };
                            blend = true;
                            depthMask = false;
                            renderOrder = 2000;
                        } else if (shaderName === "skybox"){
                            defaultUniforms = {
                                mainColor: [1, 1, 1, 1],
                                mainTexture: engine.project.load(engine.project.ENGINE_TEXTURE_CUBEMAP_WHITE)
                            };
                            faceCulling = 1028;
                            zTest = 515;
                            renderOrder = 1999;
                        }

                    }
                    return res;
                },
                shaderTypes = [
                    "specular",
                    "diffuse",
                    "__shadowmap",
                    "__error",
                    "__pick",
                    "__pick_normal",
                    "__pick_uv",
                    "transparent_specular",
                    "transparent_diffuse",
                    "unlit",
                    "unlit_no_depth",
                    "unlit_vertex_color",
                    "bumped_specular",
                    "transparent_point_sprite",
                    "transparent_unlit",
                    "particles",
                    "skybox"
                ];
            if (url === "kickjs://shader/default/") {
                url = "kickjs://shader/diffuse/";
            }
            if (url ==="unlit_no_depth"){
                url = "kickjs://shader/unlit/";
            }
            for (i = 0; i < shaderTypes.length; i++) {
                if (compareAndSetShader(shaderTypes[i])) {
                    break;
                }
            }
            if (ASSERT) {
                if (!vertexShaderSrc) {
                    Util.fail("Cannot find shader url '" + url + "'");
                }
            }

            config = {
                blend: blend,
                depthMask: depthMask,
                renderOrder: renderOrder,
                polygonOffsetEnabled: polygonOffsetEnabled,
                vertexShaderSrc: vertexShaderSrc,
                fragmentShaderSrc: fragmentShaderSrc,
                defaultUniforms: defaultUniforms,
                faceCulling: faceCulling,
                zTest: zTest
            };

            Util.applyConfig(shaderDestination, config);
            shaderDestination.apply();
        };

        /**
         * Create a default texture based on a URL.<br>
         * The following default textures exists:
         *  <ul>
         *  <li><b>Black</b> Url: kickjs://texture/black/</li>
         *  <li><b>White</b> Url: kickjs://texture/white/<br></li>
         *  <li><b>Gray</b>  Url: kickjs://texture/gray/<br></li>
         *  <li><b>Default normal</b>  Url: kickjs://texture/default\_normal/<br></li>
         *  <li><b>Checkerboard</b>  Url: kickjs://texture/checkerboard/<br></li>
         *  <li><b>KickJS logo</b>  Url: kickjs://texture/logo/<br></li>
         *  </ul>
         * @method getImageData
         * @param uri
         * @param textureDestination
         */
        this.getImageData = function (uri, textureDestination, resourceTracker) {
            if (resourceTracker && resourceTracker.resourceLoadingStarted){
                resourceTracker.resourceLoadingStarted(uri, textureDestination);
            }
            var data,
                resourceLoadingFailed = function(){
                    if (resourceTracker && resourceTracker.resourceLoadingFailed){
                        resourceTracker.resourceLoadingFailed(uri, textureDestination);
                    }
                },
                img,
                logoResource = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAABACAYAAADS1n9/AAAXgWlDQ1BJQ0MgUHJvZmlsZQAAeAGtWXc8lt/7P/cz8Xisx957Zm+y98jeyXqsx/bYu6wyUiSEKCSSaBohoYVkhKaMFFHRQsT3pvp8P3/8vv/9bi/3/Xad93Wd65zr3Ofc1wUAthueYWFBCDoAgkMiyTZGurxOzi682FcAgn8YgRBg9iRGhOlYWZmD/3n9mIC58DUmuWvrf9L+7wZ6b58IIgCQFdzs5R1BDIbxDQAQt4hh5EgAULv2BGMiw3bxSRgzkmEHYVyzi/1+49Zd7PUbD+5x7Gz0YM40ABTUnp5kPwCol2E5bzTRD7aDpwYAwxDiTQoBgMALY02iv6c3AGweMGdfcHDoLs6FsajXv+z4/Qt7enr9Y9PT0+8f/HsssCbcsT4pIizIM27vj//PW3BQFDxfexczfKcOi9S1gZ+s8LyxkiJN7GDMCGMZ/yhj+z9YP97fznGXC8udQrwsLGHMAGNvYoQePJcAtgNFB4aa7drZ5eR6++gbwBheFVBJRLTtX1wX769n8YfjFOBpuhszGpjT6kmG0e9+74dFWu36sGvzRUiQhfkfvOJLNty1D8sRGJ8IA1sYwz4gOCPJdrty2GeElC/J0ATGcL8I3bCgvTW3y7EhR9nsjkUQxt4+IfZ/dY95e+qbwXJOWF4KzIEe0Ae88D0UBMG/ZEAC3vDzr5z4L7ktiAcfQQjwARGwxh7DnZRK/ouBIfCE9f3gdsk/+rp7Eh8QDWv9+ssbWm5Z/ov/6Hj9o2EI3u7Z+GNBpkFmUWbrL5uX9q9fGAOMPsYYY4gR+yuBe/o9CvKef2bwaHxAFGzLB+77rz//HlXUP4x/S3/Pgc2eViDMIP3tGzjseUb6x5bZPzPzZy5Qwig5lCJKF6WB0kSpAl4UM4odSKIUUCooHZQWSh1uU/3XPP/R+uO/JPDdm6voPe8DwTvYc/itjvSJjYRjBfRCw+LIJD//SF4deLfw2cdrEkKU2scrJyMrB3b3nl0OAF9t9vYUiPnJf2XBTQCokOB15fZfmRe8J7RLwu9ww39lwkXwOx4AwIAgMYoc/dseaveBBlSAFl5pbIAbCABRePxyQAmoA21gAEyBJbADzsANEIE/7C8ZxIBEcARkghxwEpwGpaASVIM60AiugRbQAe6C+2AADINx8BJMg3mwBFbAD7AJQRAWwkMEiA3igYQgCUgOUoE0IQPIHLKBnCEPyA8KgaKgRCgNyoEKoFLoPFQPXYXaoLvQI2gEeg7NQIvQF+gnAomgRjAiuBDCCGmECkIHYYawQxxC+CHCEfGIdEQeogRRhbiMuIW4ixhAjCOmEUuI70iAxCGZkXxISaQKUg9piXRB+iLJyGRkNrIIWYW8gmxHPkCOIaeRy8gNFAZFQPGiJOFYGqPsUURUOCoZlYsqRdWhbqH6UGOoGdQKahuNR3OiJdBqaBO0E9oPHYPORBeha9E30ffQ4+h59A8MBsOMEcEow+vXGROAScDkYs5imjDdmBHMHOY7Fotlw0pgNbCWWE9sJDYTewZ7GXsHO4qdx65T4Ch4KOQoDClcKEIoUimKKC5RdFGMUryn2KSkoxSiVKO0pPSmjKM8QVlD2U75hHKecpOKnkqESoPKjiqA6ghVCdUVqntUr6i+4nA4fpwqzhpHwh3GleCacQ9xM7gNagZqcWo9alfqKOo86ovU3dTPqb/i8XhhvDbeBR+Jz8PX43vxU/h1GgKNFI0JjTdNCk0ZzS2aUZpPtJS0QrQ6tG608bRFtNdpn9Au01HSCdPp0XnSJdOV0bXRTdJ9pyfQy9Jb0gfT59Jfon9Ev8CAZRBmMGDwZkhnqGboZZgjIAkCBD0CkZBGqCHcI8wzYhhFGE0YAxhzGBsZhxhXmBiYFJgcmGKZypg6maaZkczCzCbMQcwnmK8xTzD/ZOFi0WHxYcliucIyyrLGysGqzerDms3axDrO+pONl82ALZAtn62F7TU7il2c3Zo9hr2C/R77MgcjhzoHkSOb4xrHC04EpzinDWcCZzXnIOd3Lm4uI64wrjNcvVzL3Mzc2twB3IXcXdyLPAQeTR4STyHPHZ4PvEy8OrxBvCW8fbwrfJx8xnxRfOf5hvg2+UX47flT+Zv4XwtQCagI+AoUCvQIrAjyCB4QTBRsEHwhRCmkIuQvVCz0QGhNWETYUfiocIvwggiriIlIvEiDyCtRvKiWaLholehTMYyYilig2FmxYXGEuKK4v3iZ+BMJhISSBEnirMTIPvQ+1X0h+6r2TUpSS+pIRks2SM5IMUuZS6VKtUh9khaUdpHOl34gvS2jKBMkUyPzUpZB1lQ2VbZd9oucuBxRrkzuqTxe3lA+Rb5VflVBQsFHoULhmSJB8YDiUcUexV9KykpkpStKi8qCyh7K5cqTKowqViq5Kg9V0aq6qimqHaobakpqkWrX1D6rS6oHql9SX9gvst9nf83+OQ1+DU+N8xrTmryaHprnNKe1+LQ8taq0ZrUFtL21a7Xf64jpBOhc1vmkK6NL1r2pu6anppek162P1DfSz9YfMmAwsDcoNZgy5Df0M2wwXDFSNEow6jZGG5sZ5xtPmnCZEE3qTVZMlU2TTPvMqM1szUrNZs3Fzcnm7QcQB0wPnDrwykLIIsSixRJYmliesnxtJWIVbnXbGmNtZV1m/c5G1ibR5oEtwdbd9pLtDztduxN2L+1F7aPsexxoHVwd6h3WHPUdCxynnaSdkpwGnNmdSc6tLlgXB5dal+8HDQ6ePjjvquia6TpxSORQ7KFHbuxuQW6d7rTunu7XPdAejh6XPLY8LT2rPL97mXiVe60Q9YjFxCVvbe9C70UfDZ8Cn/e+Gr4Fvgt+Gn6n/Bb9tfyL/JdJeqRS0mqAcUBlwFqgZeDFwJ0gx6CmYIpgj+C2EIaQwJC+UO7Q2NCRMImwzLDpcLXw0+ErZDNybQQUcSiiNZIR/sgbjBKNyoiaidaMLotej3GIuR5LHxsSOxgnHpcV9z7eMP5CAiqBmNCTyJd4JHEmSSfpfDKU7JXckyKQkp4yf9jocN0RqiOBRx6nyqQWpH5Lc0xrT+dKP5w+l2GU0ZBJk0nOnDyqfrTyGOoY6dhQlnzWmaztbO/s/hyZnKKcrVxibv9x2eMlx3fyfPOGTiidqDiJORlyciJfK7+ugL4gvmDu1IFTtwp5C7MLv512P/2oSKGospiqOKp4usS8pPWM4JmTZ7ZK/UvHy3TLmso5y7PK1856nx2t0K64UslVmVP58xzp3LPzRudvVQlXFVVjqqOr39U41Dy4oHKhvpa9Nqf218WQi9N1NnV99cr19Zc4L51oQDRENSxedr083Kjf2HpF8sr5JuamnGbQHNX84arH1YlrZtd6rqtcv3JD6Eb5TcLN7FvQrbhbKy3+LdOtzq0jbaZtPe3q7TdvS92+2MHXUdbJ1Hmii6orvWvnTvyd791h3ct3/e7O9bj3vOx16n3aZ903dM/s3sP7hvd7H+g8uPNQ42HHI7VHbf0q/S0DSgO3BhUHbz5WfHxzSGno1hPlJ63DqsPtI/tHuka1Ru+O6Y/df2rydGDcYnxkwn7i2aTr5PQz72cLz4Oer76IfrH58vAr9Kvs13Svi6Y4p6reiL1pmlaa7pzRnxmctZ19OUecW3ob8XZrPv0d/l3Re5739QtyCx2LhovDHw5+mF8KW9pczvxI/7H8k+inG5+1Pw+uOK3Mr5JXd77kfmX7evGbwree71bfp34E/9hcy15nW6/bUNl48NPx5/vNmC3sVskvsV/t22bbr3aCd3bCPMmee98CSPiO8PUF4MtF+DvBGc4BhgGgovmdG+wxAEBCMAfGDpAUtIQ4i3RDCaE+oLsxJdgwChtKAyolnDS1FF6CRoXWjM6DPorhNKGNcYaZmkWHlczWyL7EKcYVwN3Ms86nz39SYFZIVvioyGsxRfGTEsuSBlLV0tuyrnLtCuyKsUrjKvKqeWrL+400zmn+1LbRuaC7oW9mUGq4YKxgkmDaZQ4d0LaIt2y2mrOht9Ww87bPcDjneN3pjnOvS/fBNtemQ7Vu5e4nPVI9w73ciObeyj78vnjfNb8Z/37StYDSwNQgUrBViGIoS+ha2Fh4AzklwjKSJ/JzVFd0XoxrrETsz7j++NIEUqJKEiZpLLkyJeiw7hHBVMY02nS6DPpMuqP4Y5RZqKyd7I2cL7lLx2fzXpwYPTmQ31PQdupKYfXpM0V5xWklCWfiSlPLSspvnh2umK1cPrdyfqVqpfpzzacLH2uXLi7Uva2fuTTXsNpIf0WvKbm55eqba+s3sDcJt3haxFsV27TaTW7bdnh1xnaV3LnbvdCD6iX0sd/jvS/+QPmh7iPdftH+zwPZg2yD5x9rPV4eanxCHlYdgUYej1aMhT81GGcb/zTRO1n8zP+50vOdF90v41/Jv1p+3TgV8Wb/NGZ6dKZ81ndOdm7z7f35wnc+79UWGBY+LHZ9yF1yXOZbXvx49VP8Z90V3Mr4auOXiq83vq398F17saH9s3Bz+pf8duHOzl78BaBmhDOSAfkQlYk2wzBhXmOvU+RSBlHZ4/Sp5fFiNEK0onTS9IoMhgQHxhCmdOZqlj7WJXZ6Dk1OElcp9yDPDp8Kf6TAFcEPwhIi/qJ1YksSkvvIkjelNmS0ZI/IPVDAKZor5SmPqBLUrNTz9vdrYrS0tKN16nRf6uMM1Ay9jLKMG0wGTBfNEQdYLEQs5a3UrNVs5G0F7Wjsvtu/cOh2rHHKdg5xsT2o7MrhunNo1q3PvdYj09PbS5vISVzzHvFp8M3wc/NXJtGRFgLuBBYHhQQbhLCHfAy9E5YX7kLmJy9GNEfGRKlF/YruikmJ1Y5DxT2MP55glUhIHE8qTj4I76wrh3uPVKampYWku2QYZSoc5TtGfWwtazZ7MOdW7rnjx/LIJw6dNM/XKlA8JVUoepq/iLOYpYT+DFUpqnSr7Fv50tnpisnKkXPD58er3lQv1azXIi/S1LHVC16Sadh/2bDR8opzk09z9NXca3XX+25M3VxtgVrp2vja5W8bdhzsDOvKvFPWXX+3saem92Rf5D27+3IP6B+sPnwK702VAxmDgY+th1Se8A3jhtdH5kYfj117WjyeNEGcNHum8JzrBfrF8sunr26/rp46/iZxOmwmcDZ4LvJt0nzmu/z3ZQsXFps/tC/1Lj/++PLT+orqas1X3e+4H9/WF36OblVtO/+JPyd0HCGKGEAGozhQA+hUjCZmHdtJcZTSmUoeR4NboH6Ev05TQXucLo0+niGaEMcYx5TEnMlygvUsWxN7H8czzk/ceB5BXl0+D/40gWrBe0KLIjSismL24gkSlfv6JBel6WWUZV3kEuQrFO4oTiltq3CoqqrZqJP2J2vka1ZrXdXu0Lmn2683qD9g8MDwjtF14yqTbNMQMzNzXvNvB+5bFFuSrFStsdYTNhdsI+y07antJx1qHMOc1J0xzsMupQd9XKVcfxzqcst0t/AgeEx6lsL7BA9x2vucj4cvj+8bv3P+HiQe0lTA2UDnIELQUHBWiEEoFHo7LDJcJPwZ+ViEcsT7yKIo/agv0ediLGI2Y+vjHOIR8U0JBxPRic1JB5PRyc0pbocZD48cKUr1SVNJp0mfz+jMLDwaeEwniyXrY/bdnMJc3+PKeVR50ydaTxbkkwtsTykWshVun35b1F/cVHLqTHSpc5laOTt8Wo5X3KwsO3f8fGZVenVGzdELR2szLibVBdc7XTJoUL+s0Wh2xbMpsbnk6o1rj6/P39i8Rd8i3Lq/zbrd73Zyx+nOS10ddx5099991HOv925f573W+9cfND68+Kiy/8xAwWDu48yhtCcZw/kjdaOPxlbHuSZMJqOfVT0ferHxSvC17dSJN9MzpDnWt9/foxeTl3tXT60L7sb/d41o90zAKAFQC9dBHA4DYA231FkDIFQIl0vaALDCA2CnChCBGQBBvwSgctF/zg8IoAAlXM9gg/NNaaABzMBBOBNPBgWgFtwGI2ARzhfZIQXIEgqEjkIXoF5oFoFACCAM4EwvB9GEeIr4CedzxshwZCmyD/kZXoNGqChUNWoMjUQrwBlZKXoIg8SoYsIwdZhZLCfWCVuIHaWgp7CmOEUxTslG6U5ZS/mJSoUqjWoYx40LwXVTM1IHUN/Fc+Bj8OM0SjRnaHZo/WhH6XTortOL09cyiDA0EdQJg4zujN+YjjOLMw+whLGysPayhbPzs09wHOc05sJw3efO5rHm5eT9yNfHXy2QIxgvFCzsLeIu6ibmIe4jEbwvTjJLqkK6XWZS9oPcJ/m3Ck8Ve5VuKV9RuaRar3ZJvXl/q0af5pjWvPaGLq2emL6hgZ9hjtFV45emWDM5c8cDZIs0yxNWFdYtNi/tKO01HWLg8+6Li8LBWNe7bnh3V496z2Uil7eWj6NvsN8x/2ukj4HKQVnBb0KVwk6Gf4LPt2vRTDGRsf3xLAluiXVJOyn+h2dSPdPeZDhnjh9zztrKWcjLyz9byF5kWhJWWlLeWjF0bqbqxwWai2L1Zg2xje3N3Neqbkq0VLTtdLh23b7L25t9b+Ohf//YY4UnOSNzTw9MDD33eLkxVTyjMvfmXfrC5hL/8vanmhXB1cqvbN+qfmiuvd8o2dTdmtom7+0fEFxzwAEC4AJiQBmuEDnCVZhEkA8ugi4wAT5DVHCNQBdyh5KhCqgLmoZjL4wwRYQhihBdiHdIOqQa0geZj7yD/IjiRB2AM/SrqLdoNrQFOgPdCWffMpggOO7vsEJYX2wddolCmiKKopMSQ2lFeZbyA5UaVQ7VG5wCLgf3llqL+iz1L7wH/h6NJE0xLZo2mnaJjkg3Te9F/4EhjkBLuMRoxLjAlMMsy/yCJZNVgfUdWxm7HQcdxyhnCZcXtzQP4BnnbeTL4vcTMBWUFeIQphDeFPkm+k1sSwK/T0BSU8pDOkumTfaDPKeClWKO0qAKvaqj2hn1MQ1IU1jLUNtX55huo964AcJQzsjX+KzJpBmzucOBIosxKxprI5sU23a7NQclx1inThf0QSvXykNf3E09ajx/Ea3hfeqDn7x/EmkgkCsoPPh+KFdYdPhYhEJkcdRWjHtsVzxrQkji/WSBlOzD66kBaa8zrDJ7jylnNebw55bmsZyozFcr+FjYWlRckloaXu5eYXpOoYqnhubCzsUv9e8anjU+bOq42nb97s0nLa/blm5vdFF18/ao9Tndj3tY1t8+ODz0cvjZ6ODTjonLz86+yH91dCplOm425m3su4SF2A+Hlpk/1n5mWSGtVn8Z/7r2neWH/JrVesTGmZ+Pt7C/rLdr/sQfA/CABX77ZYEuXF/yB0mgEK4hPQCzYAfigvZDh+DYn4fuw1+ZDAg1BBFxHNGKmEcSkDpw5aYaOYGihCtwUajLqHk0D/ogugQ9AVdcHDGlmCmsADYAex27TWFKUUKxAFdMjlPOwTEvpFrBWeKaqQnUcdSzeAt8J40MzQVaHtpyOm66Grhu0cfgTkDA8XZkwjLdZo5kkWFZYb3BlsRuwsHKsczZx3WOO4WHyGvOp8ovLsAnyCPEJywmoiRqIuYuHidRvK9dclaaQcZUNlOuVwGtaK3UqEJQTVFb3U/SWNAK0v6hm6nPadBu5G6CM+0wJ1mgLXOsgU2o7Wt7C4ce+ExqPajq2u1m4T7jGUuk9a72VfDrJpkFTAYRg1dDj4QzkZsiD0StxJyJM02AEluTiSnbR/LSWNOrMiWPdmbZZa/nXskLOSmeP3YqoPBrUVTx9zMxpVvlmRWMlbXn1avGaoJrqS7W1RtfWryce0Wh6e3V89eDbuq38Leh2hc7Rro6uxt7qvpK7xc+zO8/MXhiKGc4adTtqcz498lrz4Nfir16N3Vh2ndWfG51vuN9xqL+h9XlYx+/fDZZyV1t+fL66/K3je9zPx6tFazvX3+3kb6x8TPk59ym0+adLcYt0lbXL8ZfpF9d2xTbVtsl2292RHZCd1p24x/hKy+3e3oAiFoXLj9O7ex8FQYAWwDAr/ydnc2qnZ1f1XCy8QqA7qDf/3fYJWPg+vc59C56xDV3ePf57+s/NEanGZ4R8qcAAAAJcEhZcwAACxMAAAsTAQCanBgAAAFuaVRYdFhNTDpjb20uYWRvYmUueG1wAAAAAAA8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJYTVAgQ29yZSA0LjQuMCI+CiAgIDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+CiAgICAgIDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiCiAgICAgICAgICAgIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyI+CiAgICAgICAgIDxkYzpzdWJqZWN0PgogICAgICAgICAgICA8cmRmOkJhZy8+CiAgICAgICAgIDwvZGM6c3ViamVjdD4KICAgICAgPC9yZGY6RGVzY3JpcHRpb24+CiAgIDwvcmRmOlJERj4KPC94OnhtcG1ldGE+CuU/DUEAAAsCSURBVHgB7Zx1qFTNG8cfu1+7uxtbDOwOTEzExlYs7PgJKuofdiJYKNiKqNhd2N3dit39/vwMzO7s3t179+zdfY1zHljPnKkzM88zT3xnrjH+/UnikG1XIKZtZ+5MXK2AIwA2FwRHABwBsPkK2Hz6jgZwBMDmK2Dz6TsawBEAm6+AzafvaABHAGy+AjafvqMBHAGw+QrYfPqOBnAEwOYrYPPpOxrAEQCbr4DNpx/b5vP/ZdPnHs6TJ08kfvz4EitWLDWOHz9+yKdPnyRBggTyzz//eIyN/CtXrsjLly8lceLEkj9/fkmUKJF8+PBBHj58KLly5fKoH+iLZQEYNWqUHD16VBImTKh+8eLFEybDAD9+/KgG1KpVK2nfvr3PMfTv318uX76s2jLRuHHjqva01b+uXbtKkyZNXO1Pnz4tq1evVpNPly6d9OjRQ1KmTOkqD3Wic+fO8urVK7XQ9P3+/Xv1a9OmjbRu3Tokn+vSpYucOnXKZ18pUqSQbdu2qbL79+8La3727NkIdbNlyyaPHj2Sz58/C/3xs0qWBWDr1q3y/fv3SL+zZcsWvwJw8ODBKNsfPnzYJQBPnz4VGGLS3r17ZceOHWZWyNIIMwLni86cORMyAWDX+qMXL16ootevX0uLFi0Ug8lImjSpNGzYUNKmTSs3btyQzZs3u8p27twZlABYcgLZoVExn4HqCZA2ac+ePZbb37lzx+xCpdmd4SI0mT+KEyeOvyLL+fPnz5eiRYtGaJcxY0ZZvHixyh83bpyLwWRkyZJF+vTpo4Ri2LBhcuDAASlWrJiq+/jxY/W0+k+s//2kQBuxACVLlpQcOXII9sqU4pgxY0qNGjWkXr160rNnT0mePHmEbjNkyCCYjIsXL8rXr189yrFrVatWlWrVqgkmIEmSJKqcBTl58qTHtzAPFSpU8Ggfqhfm2KBBA8UcTNWbN29cXefOnVuN0ZURjQTzQ9WjLU1ix9etW1dlzZgxQ96+fesqRhuuWbNG7t69q/JYz0aNGknZsmWlb9++Eju2ZYUullsUL15c+GELy5Qpo+w3o8mcObOMHz/eNVhfCex9x44dZfny5cqm6jqlSpWSOXPm6NcIz7lz5wrq8MGDB4IPwMKFk/gGv1SpUqnxhutb+EDehG+lifXypufPn8u6devUjzKEEhNZuHBh76oBvVsyAWaP2nPVeezsqOjcuXNSs2ZNDxPRsmXLSJmv+8T+FShQIOzM19/jifYJJ/m6kW/mVa5cOcrPX7t2TQYPHizDhw+Psq6vCkELgHdn5sC9y3hftGiRdOjQwcV8TMbo0aNl4MCBvqr/FnmYuV9JvXr1UiY3kDHgnO/bty+Qqh51LJsAj9YBvmCfcFg0JUuWTGbPni158uTRWX6fkyZNUv4EMS/hDnEwse+IESP8tjELMBtr165VIRdx97dv31TsTRiJRqlfv77ky5fPbGI5jdOG48u80IQIN87yu3fvBLvdvXt3ZU4sd/yzAebvyJEjsnDhQuU74Yj7I/yJihUr+iv2mR9WAbh586b07t1bAR766yw22iAQh+XEiROycuVK3dTjWb58ealSpYpHnvnCwqNhjh07Zma70ggGsTX+CH1NmzbNVWY1gUcfWfSQPn36CKEs3/ClYRAek1Dx+Fr8oPPnzyvHkRDQdFApCyRCo55Jnl8zS6KZhnHYd3adptq1a8vSpUsDYj5tYJI/8rV4ui47Hk/eZD4+S86cOZVKRQhNBwxsAjsaLOGNezPO7MufcODYehO+jqZZs2YJoBpz0aFvoUKFlNnctWuXK1LS9UuXLq2TAT/DogGGDh0q27dv9xgEmqBdu3YeeVG9EFaChAHMEAoGQhs2bIgQjTRt2lQtmnccP3bsWFm/fr3qFiAFExOIM+s9junTp0vbtm1d/o0uJ1wmbNZAFqgdaB0RFIwF0PImExvQoTThdp06daRx48YKCCIfk/rlyxdXc/KYp1UKmQCg0m/fvi0DBgwQE7xhYAAawUgnuxTYF2KHwqTICMjWOxQdNGiQNG/e3GezWrVquQSACrdu3bLsD7ATJ0+e7MF8wJkhQ4YojWN++OrVqwq6pT72+sKFC2axFClSRIE9OhM8gLoQuAla1ZdJzJQpk/IVdDsrz5AJAPYeEMPbDqF2g2G+9yRKlCgRpQDAfJw8TWgQf8ynTpo0aXRVdSBjxRm8d++egKEBD2sCzCKqwbH0RZUqVVJIHkw0mc/BD2X4LCbhVHbr1k2BYOxuDoOOHz8uYAEQWAXtANCCpZAJAOpTE6pWI30MGC/ZqvrXfVl5AjVrQiONHDlSv/p8Zs2aVeHqqVOnVkiaz0pGpsY+0GiAMSaBYE6cONHM8pnGVPCDiBIwOd6myWyozQd5BQsWdJ2RmHWikw6ZAOhBIP2oPxA/VB40c+ZMpQU4wgwX4R2bQsi3TFTN33c3bdrkryhC/qFDh9RuM71vmEeoGgw0jcb41RSyKABJHjNmjFKLnHETVulQD5AILCCcxOmYSXjLoSZifZP59I/J8+XNh/rb4eovZALAWQAHQZpQq6b6wm7169dPF4f8iQNoUjjvC5j3HQhHEXw00J9IIROAGDFiRJg/AsClBU379+8XwrRwkLe6jwwxC/b7ADqrVq1SkQ4wrUbd0HCEuaYJCvYb/3W7kAmAv4HjMJmEo6RBDTM/umnOyk0ipAs1cQqaPXt2V7eEaPrAiGNb7dy5KvwBibALQN68eQUEUBO7pFOnTvo1ZE+Yo710OvV33So6H/SFPgID62Nb/JDoIIrRGVuwbUMmAL5MgB4UiJu+4EEeQBHxbajJdPw4NFqxYkWoPxGhP7AE8ABNgFX6Ro/O+52fQQsAgIt5BByV/fM+9gUf4HjYvPFiZaF8CRw3kUyaOnVqQJoAUIcrVt7kje+b8zXrcsfBBJwIe3UIbNb7HdOWroQxATB5LmRyTAm2rQlGgttzCgf8632tmaNf0C8WWxN1ly1bJqCILDY/BAsIWDMYvPvSpUuyYMECefbsmW6qjoXB2vH2dV2cNNSwtv+o7I0bNyqfg2vT3nE3l0+nTJmi4njaAQzp69XXr19XR7Cgb5oI93Q/hLomYeo4V9D4/O7du13+AeFwMGcMZv/hSsf4KdUB/0eRnMNrzzeyAcEULij4InYKDI+MEAQWkDsAwMi+bK9uDxADI03iTiFHyd6EUCIExO6EpSZsTF2QQ27dNmvWzCVE3n3od66wcZUNwtxwYsepn7/lnDBhglSvXl03/22elkwAoZYGdyKbARi2PwIHL1eunL9ilQ/Dcax4RsZ8KmvI2exw3rx5Cno2nULKAXE4WdMXQ8w23C2A+ZC/41uzvt7p5KENCDv9MZ86gfRJvf+aLEPBHEsCibKTUGt6kdlN+AEAMtSJjDg+5Qx+yZIlSr2jWUzCpmp8nMuO7DD9FzTaLrOL+R535H0RcTk+BqaDMwLuFpgHVZgNwCqOXwF2zEuVCAOYhflNmIswwnjmyk1cTZgsHFDMIIKrN4muT5tgoGLdfziflkxAuAbCzsS+wiBOuLzta6i+i8/CTkV4Yb72HULV/5/Yz28hAH/iwv0tY8YEBOwE/i2TdubhXgEEICKI7y53Un/5CliKAv7ytbDl9BwBsCXb3ZN2BMC9FrZMOQJgS7a7J+0IgHstbJlyBMCWbHdP2hEA91rYMuUIgC3Z7p60IwDutbBlyhEAW7LdPWlHANxrYcuUIwC2ZLt70o4AuNfClilHAGzJdvekHQFwr4UtU44A2JLt7kn/H7HUl9GoOKVWAAAAAElFTkSuQmCC";

            if (uri.indexOf("kickjs://texture/black/") === 0) {
                data = new Uint8Array([0, 0, 0, 255,
                    0,   0,   0, 255,
                    0,   0,   0, 255,
                    0,   0,   0, 255]);
            } else if (uri.indexOf("kickjs://texture/white/") === 0) {
                data = new Uint8Array([255, 255, 255, 255,
                    255,   255,   255, 255,
                    255,   255,   255, 255,
                    255,   255,   255, 255]);
            } else if (uri.indexOf("kickjs://texture/default_normal/") === 0) {
                data = new Uint8Array([127, 127, 255, 255,
                    127,   127,   255, 255,
                    127,   127,   255, 255,
                    127,   127,   255, 255]);
            } else if (uri.indexOf("kickjs://texture/gray/") === 0) {
                data = new Uint8Array([127, 127, 127, 255,
                    127,   127,   127, 255,
                    127,   127,   127, 255,
                    127,   127,   127, 255]);
            } else if (uri.indexOf("kickjs://texture/checkerboard/") === 0) {
                data = new Uint8Array([255, 255, 255, 255,
                    0,   0,   0, 255,
                    0,   0,   0, 255,
                    255, 255, 255, 255]);
            } else if (uri.indexOf("kickjs://texture/logo/") === 0) {
                textureDestination.setTemporaryTexture();
                img = document.createElement("img");
                img.onload = function () {
                    textureDestination.generateMipmaps = true;
                    textureDestination.internalFormat = 6408;
                    textureDestination.magFilter = 9729;
                    textureDestination.minFilter = 9987;
                    textureDestination.setImage(img, uri);
                    if (resourceTracker && resourceTracker.resourceLoadingStarted){
                        resourceTracker.resourceLoadingFinished(uri, textureDestination);
                    }
                };
                img.onerror = function () {
                    resourceLoadingFailed();
                };
                img.src = logoResource;
                return;
            } else {
                Util.fail("Unknown uri " + uri);
                resourceLoadingFailed();
                return null;
            }
            textureDestination.setImageData(2, 2, 0, 5121, data, uri);
            if (resourceTracker && resourceTracker.resourceLoadingStarted){
                resourceTracker.resourceLoadingFinished(uri, textureDestination);
            }
        };
    };
});

define('kick/core/Config',["./Util", "./Constants"], function (Util, Constants) {
    


    /**
     * The global configuration of the engine. Cannot be changed during runtime.
     * @example
     *      <canvas id="3dCanvas" width="50" height="50"></canvas>
     *      <script src="require.js"></script>
     *      <script type="text/javascript">
     *          var req = require.config({
     *                  paths: {
     *                      kick: 'kick-debug' // loads kick-debug.js (must be in same path)
     *                  }
     *              });
     *          req(['kick'],
     *                  function (kick) {
     *                      var config = {
     *                          enableDebugContext: true,
     *                          shadows: true
     *                      };
     *                      var engine = new kick.core.Engine('3dCanvas', config);
     *                      // [...]
     *                  }
     *          );
     *      </script>
     * @class Config
     * @namespace kick.core
     * @constructor
     * @param {Config} config defines one or more properties
     */
    return function (config) {
        /**
         * Adds support for highDPI (such as MacBook Pro retina)
         * Enabling this will create the canvas in high resolution - and wraps the mouse input as well.
         * @property highDPISupport
         * @type {Boolean}
         * @default true
         */
        this.highDPISupport = config.highDPISupport || true;
        /**
         * Use shadow maps to generate realtime shadows.<br>
         * Default value is false.
         * @property shadows
         * @type Boolean
         * @default false
         */
        this.shadows = config.shadows || false;
        /**
         * The maximum distance shadows are displayed from camera (the smaller the better quality of shadow map).
         * Default value is 20
         * @property shadowDistance
         * @type Number
         * @default 20
         */
        this.shadowDistance = config.shadowDistance || 20;
        /**
         * A multiplier that moves the near plane of the shadow map. Default is 2.0
         * @property shadowNearMultiplier
         * @type Number
         * @default 2.0
         */
        this.shadowNearMultiplier = config.shadowNearMultiplier || 2.0;
        /**
         * Shadow map resolution (relative to max texture size). Default is 1.0.
         * Allowed values are 1/2, 1/4, 1/8, etc.
         * @property shadowMapQuality
         * @type Number
         * @default 1.0
         */
        this.shadowMapQuality = config.shadowMapQuality || 1.0;

         /**
         * Maximum number of lights in scene. Default value is 1
         * @property maxNumerOfLights
         * @type Number
         * @default 1
         */
        this.maxNumerOfLights = typeof (config.maxNumerOfLights) === 'number' ? config.maxNumerOfLights : 1;

        /**
         * Checks for WebGL errors after each webgl function is called.
         * Should only be used for debugging.
         * Default value is false.
         * @property enableDebugContext
         * @type Boolean
         * @default false
         */
        this.enableDebugContext = typeof (config.enableDebugContext) === 'boolean' ? config.enableDebugContext  : false;

        /**
         * Allows grabbing the content of the canvas using canvasObj.toDataURL(...).<br>
         * Note that this has a performance penalty when enabled.<br>
         * Default value is false<br>
         * WebGL spec:  If false, once the drawing buffer is presented as described in theDrawing Buffer section,
         * the contents of the drawing buffer are cleared to their default values.
         * All elements of the drawing buffer (color, depth and stencil) are cleared.
         * If the value is true the buffers will not be cleared and will preserve their
         * values until cleared or overwritten by the author.
         * @property preserveDrawingBuffer
         * @type Boolean
         * @default false
         */
        this.preserveDrawingBuffer = config.preserveDrawingBuffer || false;

        /**
         * WebGL spec:  If the value is true, the drawing buffer has an alpha channel for the purposes
         * of performing OpenGL destination alpha operations and compositing with the page. If the value is false, no
         * alpha buffer is available.
         * @property alpha
         * @type Boolean
         * @default true
         */
        this.alpha = typeof (config.alpha) === 'boolean' ? config.alpha : true;

        /**
         * WebGL spec: If the value is true, the drawing buffer has a depth buffer of at least 16 bits.
         * If the value is false, no depth buffer is available.
         * @property alpha
         * @type Boolean
         * @default true
         */
        this.depth = typeof (config.depth) === 'boolean' ? config.depth : true;

        /**
         * WebGL spec: If the value is true, the drawing buffer has a stencil buffer of at least 8 bits.
         * If the value is false, no stencil buffer is available.
         * @property stencil
         * @type Boolean
         * @default false
         */
        this.stencil = typeof (config.stencil) === 'boolean' ? config.stencil : false;

        /**
         * WebGL spec: Default: true. If the value is true and the implementation supports antialiasing the drawing
         * buffer will perform antialiasing using its choice of technique (multisample/supersample) and quality.
         * If the value is false or the implementation does not support antialiasing, no antialiasing is performed.
         * @property antialias
         * @type Boolean
         * @default true
         */
        this.antialias = typeof (config.antialias) === 'boolean' ? config.antialias : true;

        /**
         * WebGL spec: Default: true. If the value is true the page compositor will assume the drawing buffer contains
         * colors with premultiplied alpha. If the value is false the page compositor will assume that colors in the
         * drawing buffer are not premultiplied. This flag is ignored if the alpha flag is false.
         * See Premultiplied Alpha for more information on the effects of the premultipliedAlpha flag.
         * @property premultipliedAlpha
         * @type Boolean
         * @default true
         */
        this.premultipliedAlpha = typeof (config.premultipliedAlpha) === 'boolean' ? config.premultipliedAlpha : true;

        /**
         * Polling of canvas resize. Default is 0 (meaning not polling)
         * @property checkCanvasResizeInterval
         * @type Number
         * @default 32
         * @deprecated
         */
        this.checkCanvasResizeInterval = config.checkCanvasResizeInterval || 32;

        /**
         * function (or function name) with the signature function(domElement) called when WebGL cannot be initialized.
         * Default function replaces the canvas element with an error description with a link to
         * http://get.webgl.org/troubleshooting/
         * @property webglNotFoundFn
         * @type Function | String
         */
        this.webglNotFoundFn = (function () {
            if (config.webglNotFoundFn) {
                if (typeof (config.webglNotFoundFn) === "string") {
                    return Util.namespace(config.webglNotFoundFn);
                } else {
                    return config.webglNotFoundFn;
                }
            }
            return function (domElement) {
                var errorMessage;
                domElement.innerHTML = "";
                errorMessage = document.createElement("div");
                errorMessage.style.cssText = domElement.style.cssText + ";width:" + domElement.width + "px;height:" + domElement.height +
                    "px;display: table-cell;vertical-align: middle;background:#ffeeee;";
                errorMessage.innerHTML = "<div style='padding:12px;text-align: center;'>It doesn't appear your computer can support WebGL.<br><br><a href=\"http://get.webgl.org/troubleshooting/\">Click here for more information.</a></div>";
                domElement.parentNode.replaceChild(errorMessage, domElement);
            };
        }());

        if (true) {
            (function (t) {
                var name,
                    supportedProperties,
                    n2;
                for (name in config) {
                    if (config.hasOwnProperty(name) && !t.hasOwnProperty(name)) {
                        supportedProperties = "Supported properties for kick.core.Config are: ";
                        for (n2 in t){
                            if (t.hasOwnProperty(n2) && typeof t[n2] !== "function") {
                                supportedProperties += "\n - "+n2;
                            }
                        }
                        Util.warn("kick.core.Config does not have any property "+name+"\n"+supportedProperties);
                    }
                }
            }(this));
        }
    };

});

define('kick/core/GLState',["kick/core/Constants", "kick/core/Util"], function (constants, Util) {
    
    var ASSERT = true;
    /**
     * This object should only be used by advanced users.
     * <br>
     * The GLState object contains properties representing the current WebGL states. This object is useful
     * when creating component with custom render methods. It is important that any state modified by such
     * method needs to be reset (set to null).
     * @class GLState
     * @constructor
     * @namespace kick.core
     * @param {kick.core.Engine} engine
     */
    return function (engine) {
        var thisObj = this,
            vertexArrayObjectExt = null,
            standardDerivativesExt = null,
            textureFloatExt = null,
            textureFloatHalfExt = null,
            depthTextureExt = null,
            textureFilterAnisotropicExt = null,
            drawBuffersExt = null,
            elementIndexUIntExt = null,
            colorBufferFloatExt = null,
            colorBufferHalfFloatExt = null,
            instancedArraysExt = null,
            textureFloatLinearExt = null,
            textureHalfFloatLinearExt = null,
            reloadExtensions = function(){
                vertexArrayObjectExt = engine.getGLExtension("OES_vertex_array_object");
                standardDerivativesExt = engine.getGLExtension("OES_standard_derivatives");
                textureFloatExt = engine.getGLExtension("OES_texture_float");
                textureFloatHalfExt = engine.getGLExtension("OES_texture_half_float");
                depthTextureExt = engine.getGLExtension("WEBGL_depth_texture");
                textureFilterAnisotropicExt = engine.getGLExtension("EXT_texture_filter_anisotropic") || engine.getGLExtension("WEBGL_texture_filter_anisotropic");
                drawBuffersExt = engine.getGLExtension("EXT_draw_buffers") || engine.getGLExtension("WEBGL_draw_buffers");
                elementIndexUIntExt = engine.getGLExtension("OES_element_index_uint");
                colorBufferFloatExt = engine.getGLExtension("WEBGL_color_buffer_float") || engine.getGLExtension("EXT_color_buffer_float");
                colorBufferHalfFloatExt = engine.getGLExtension("EXT_color_buffer_half_float");
                instancedArraysExt = engine.getGLExtension("ANGLE_instanced_arrays");
                textureFloatLinearExt = engine.getGLExtension("OES_texture_float_linear");
                textureHalfFloatLinearExt = engine.getGLExtension("OES_texture_half_float_linear");
            },
            clearExtensions = function(){
                vertexArrayObjectExt = null;
                standardDerivativesExt = null;
                textureFloatExt = null;
                textureFloatHalfExt = null;
                depthTextureExt = null;
                textureFilterAnisotropicExt = null;
                drawBuffersExt = null;
                elementIndexUIntExt = null;
                colorBufferFloatExt = null;
                colorBufferHalfFloatExt = null;
                instancedArraysExt = null;
                textureFloatLinearExt = null;
                textureHalfFloatLinearExt = null;
            };
        /**
         * The current clear color
         * @property currentClearColor
         * @type kick.math.Vec4
         */
        this.currentClearColor = null;
        /**
         * Current bound mesh buffer
         * @property meshBuffer
         * @type WebGLBuffer
         */
        this.meshBuffer = null;
        /**
         * The shader bound by the current mesh
         * @property meshShader
         * @type kick.material.Shader
         */
        this.meshShader = null;
        /**
         * Represents the current rendertarget state
         * @property renderTarget
         * @type kick.texture.RenderTexture
         * @deprecated
         */
        this.renderTarget = null;
        Object.defineProperties(this, {
            renderTarget:{
                get:function(){
                    if (ASSERT){
                        Util.warn("GLState.renderTarget Deprecated");
                    }
                },
                set:function(){
                    if (ASSERT){
                        Util.warn("GLState.renderTarget Deprecated");
                    }
                }

            }
        });
        /**
         * Represents the current shader bound
         * @property boundShader
         * @type kick.material.Shader
         */
        this.boundShader = null;
        /**
         * Represent the material used
         * @property currentMaterial
         * @type kick.material.Material
         */
        this.currentMaterial = null;

        /**
         * Represent the state of CULL\_FACE (enabled / disabled) and cullFace (). Values must be one of:
         * GL\_FRONT, GL\_FRONT\_AND\_BACK, GL\_BACK or GL\_NONE. (If none CULL\_FACE is disabled otherwise enabled)
         * @property faceCulling
         * @type Number
         */
        this.faceCulling = null;

        /**
         * Represents the current depthFunc used. Must be one of the following values:
         * GL\_NEVER, GL\_LESS, GL\_EQUAL, GL\_LEQUAL, GL\_GREATER, GL\_NOTEQUAL, GL\_GEQUAL or GL\_ALWAYS.
         * @property zTest
         * @type Number
         */
        this.zTest = null;

        /**
         * Represents the current depthMask state.
         * @property depthMaskCache
         * @type Boolean
         */
        this.depthMaskCache = null;

        /**
         * Represents if blend is enabled and the current s-factor and d-factor
         * @property blendKey
         * @type Object
         */
        this.blendKey = null;

        /**
         * Represents state of polygon offset fill
         * @property polygonOffsetEnabled
         * @type Boolean
         */
        this.polygonOffsetEnabled = null;

        /**
         * The size of the current viewport
         * @property viewportSize
         * @type kick.math.Vec2
         */
        this.viewportSize = new Float32Array(2);

        Object.defineProperties(this, {
            /**
             * The OES\_vertex\_array\_object extension (if available)
             * See http://www.khronos.org/registry/webgl/extensions/OES\_vertex\_array\_object/
             * @property vertexArrayObjectExtension
             * @type Object
             * @final
             */
            vertexArrayObjectExtension:{
                get: function(){
                    return vertexArrayObjectExt;
                },
                enumerable:true
            },
            /**
             * The OES\_standard\_derivatives extension (if available)
             * See http://www.khronos.org/registry/webgl/extensions/OES\_standard\_derivatives/
             * @property standardDerivativesExtension
             * @type Object
             * @final
             */
            standardDerivativesExtension:{
                get: function(){
                    return standardDerivativesExt;
                },
                enumerable:true
            },
            /**
             * The OES\_texture\_float extension (if available)
             * See http://www.khronos.org/registry/webgl/extensions/OES\_texture\_float/
             * @property textureFloatExtension
             * @type Object
             * @final
             */
            textureFloatExtension:{
                get: function(){
                    return textureFloatExt;
                },
                enumerable:true
            },
            /**
             * The OES\_texture\_half\_float extension (if available)
             * See http://www.khronos.org/registry/webgl/extensions/OES\_texture\_half\_float/
             * @property textureFloatHalfExtension
             * @type Object
             * @final
             */
            textureFloatHalfExtension:{
                get: function(){
                    return textureFloatHalfExt;
                },
                enumerable:true
            },
            /**
             * The WEBGL\_depth\_texture extension (if available)
             * See http://www.khronos.org/registry/webgl/extensions/WEBGL\_depth\_texture/
             * @property depthTextureExtension
             * @type Object
             * @final
             */
            depthTextureExtension:{
                get: function(){
                    return depthTextureExt;
                },
                enumerable:true
            },
            /**
             * The EXT\_texture\_filter\_anisotropic extension (if available)
             * See http://www.khronos.org/registry/webgl/extensions/EXT\_texture\_filter\_anisotropic/
             * @property textureFilterAnisotropicExtension
             * @type Object
             * @final
             */
            textureFilterAnisotropicExtension:{
                get: function(){
                    return textureFilterAnisotropicExt;
                },
                enumerable:true
            },
            /**
             * The EXT\_draw\_buffers / WEBGL\_draw\_buffers extension (if available). Also known as multiple render targets.
             * See http://www.khronos.org/registry/webgl/extensions/WEBGL_draw_buffers/
             * @property textureFilterAnisotropicExtension
             * @type Object
             * @final
             */
            drawBuffersExtension:{
                get: function(){
                    return drawBuffersExt;
                },
                enumerable:true
            },
            /**
             * WebGL 1.0 supports drawElements with <type> value of
             * UNSIGNED_BYTE and UNSIGNED_SHORT.  This extension adds
             * support for UNSIGNED_INT <type> values.
             * See http://www.khronos.org/registry/webgl/extensions/OES_element_index_uint/
             * @property elementIndexUIntExtension
             * @type Object
             * @final
             */
            elementIndexUIntExtension:{
                get: function(){
                    return elementIndexUIntExt;
                },
                enumerable:true
            },
            /**
             * Adds support for rendering to 32-bit floating-point color buffers.
             * See http://www.khronos.org/registry/webgl/extensions/WEBGL_color_buffer_float/
             * @property colorBufferFloatExtension
             * @type Object
             * @final
             */
            colorBufferFloatExtension:{
                get: function(){
                    return colorBufferFloatExt;
                },
                enumerable:true
            },
            /**
             * This extension exposes the ANGLE_instanced_arrays functionality to WebGL.
             * See http://www.khronos.org/registry/webgl/extensions/ANGLE_instanced_arrays/
             * @property instancedArraysExtension
             * @type Object
             * @final
             */
            instancedArraysExtension:{
                get: function(){
                    return instancedArraysExt;
                },
                enumerable:true
            },
            /**
             * This extension exposes the EXT_color_buffer_half_float functionality to WebGL.
             * See http://www.khronos.org/registry/webgl/extensions/EXT_color_buffer_half_float/
             * @property colorBufferHalfFloatExtension
             * @type Object
             * @final
             */
            colorBufferHalfFloatExtension:{
                get: function(){
                    return colorBufferHalfFloatExt;
                },
                enumerable:true
            },
            /**
             * This extension exposes the OES_texture_float_linear functionality to WebGL.
             * See http://www.khronos.org/registry/webgl/extensions/OES_texture_float_linear/
             * @property textureFloatLinearExtension
             * @type Object
             * @final
             */
            textureFloatLinearExtension:{
                get: function(){
                    return textureFloatLinearExt;
                },
                enumerable:true
            },
            /**
             * This extension exposes the OES_texture_half_float_linear functionality to WebGL.
             * See http://www.khronos.org/registry/webgl/extensions/OES_texture_half_float_linear/
             * @property textureFloatLinearExtension
             * @type Object
             * @final
             */
            textureHalfFloatLinearExtension:{
                get: function(){
                    return textureHalfFloatLinearExt;
                },
                enumerable:true
            }
        });

        /**
         * Sets all properties to null
         * @method clear
         */
        this.clear = function () {
            var name;
            for (name in thisObj) {
                if (thisObj.hasOwnProperty(name) && name !== "clear") {
                    thisObj[name] = null;
                }
            }
        };

        engine.addEventListener('contextLost', clearExtensions);
        engine.addEventListener('contextRestored', reloadExtensions);
        engine.addEventListener('canvasResized', function(canvasSize){
            thisObj.viewportSize[0] = canvasSize[0];
            thisObj.viewportSize[1] = canvasSize[1];
        });

        reloadExtensions();
        if (ASSERT) {
            Object.preventExtensions(this);
        }
    };
});

define('kick/core/ResourceDescriptor',["require","./Util", "./Constants", "./EngineSingleton"], function (require, Util, constants, EngineSingleton) {
    

    var ASSERT = true;

    /**
     * A project is a container of all resources and assets used in a game.<br>
     *
     * @example
     *     var materialConfig = {
     *         name:"Some material",
     *         shader:"Undefined",
     *         uniforms: {
     *             value:42,
     *             type: 5126
     *         }
     *     };
     *     var resourceDescriptorConfig = {
     *         type: "kick/material/Material",
     *         config: materialConfig,
     *         uid: 132
     *     };
     *     var materialDescriptor = new ResourceDescriptor(resourceDescriptorConfig);
     *
     * @class ResourceDescriptor
     * @namespace kick.core
     * @constructor
     * @param {Object} config an object which attributes matches the properties of ResourceDescriptor
     */
    return function (config) {
        var engine = EngineSingleton.engine,
            _config = config || {},
            type = _config.type,
            uid = _config.uid,
            resourceConfig = _config.config;
        Object.defineProperties(this, {
            /**
             * The name may contain '/' as folder separator. The name property is a shorthand for config.name
             * @property name
             * @type String
             */
            name: {
                get: function () {
                    return resourceConfig.name;
                },
                set: function (newValue) {
                    resourceConfig.name = newValue;
                }
            },
            /**
             * class name of the resource (such as 'kick.material.Material')
             * @property type
             * @type String
             */
            type: {
                value: type
            },
            /**
             * Configuration of the resource.
             * Optional
             * @property config
             * @type Object
             */
            config: {
                get: function () { return resourceConfig; }
            },
            /**
             * @property uid
             * @type Number
             */
            uid: {
                value: uid
            }
        });

        /**
         * Updates the configuration with the one from object. The method will use object.toJSON(filter)
         * (if toJSON method exist - otherwise the object are used directly)
         * @method updateConfig
         * @param {Object} object
         * @param {Function} filter=null Filter with function(object): return boolean, where true means include in export.
         */
        this.updateConfig = function (object, filter) {
            resourceConfig = object.toJSON ? object.toJSON(filter) : object;
        };

        /**
         * Create a instance of the resource by calling the constructor function with
         * uid (but otherwise uninitialized).<br>
         * This method is used during project load.
         * @method instantiate
         * @param {function} onSuccess callback function that returns the resource
         * @param {function} onError=null callback function when error occurs
         */
        this.instantiate = function (onSuccess, onError) {
            if (ASSERT) {
                if (typeof onSuccess !== "function"){
                    console.log("ResourceDescriptor.onSuccess is not a function");
                }
                if (engine === onSuccess){
                    console.log("ResourceDescriptor.onSuccess is not ");
                }
            }
            var typePath = type.replace(/\./g,"/");
            require([typePath], function(ResourceClass) {
                var resource = new ResourceClass({uid: uid});
                onSuccess(resource);
            }, onError);
        };

        /**
         * @method toJSON
         * @return {Object} A json data object
         */
        this.toJSON = function () {
            return {
                type: type,
                uid: uid,
                config: resourceConfig
            };
        };
    };

});

define('kick/core/ProjectAsset',["kick/core/Constants", "./Util", "./EngineSingleton"], function (Constants, Util, EngineSingleton) {
    

    var ASSERT = true;

    /**
     * A project asset is an object that can be serialized into a project and restored at a later state.<br>
     * The class is used to describe the behavior any project asset must implement, but instanceof operator does not work.<br>
     * The constructor must take the following two parameters: kick.core.Engine engine, {Object} config<br>
     * The config parameter is used to initialize the object and the content should match the output of the
     * toJSON method<br>
     * A toJSON method should exist on the object. This method should as a minimum write out the object's uid property.<br>
     * ProjectAsset objects may reference other ProjectAsset objects, however cyclic references are not allowed.
     * @class ProjectAsset
     * @namespace kick.core
     */
    return function (object, config, name) {
        var uid = (config && config.uid)?config.uid:0;

        /**
         * @property uid
         * @type Number
         */
        Object.defineProperty(object, "uid", {
            get: function () {
                return uid;
            },
            set: function (newValue) {
                if (ASSERT) {
                    if (typeof newValue !== "number") {
                        Util.fail("uid must be number");
                    }
                    if (uid !== 0 && newValue !== uid) {
                        Util.fail("uid cannot be reassigned");
                    }
                }
                uid = newValue;
            }
        });

        /**
         * Configures the object using the configuration data.
         * @method init
         * @param config {Object} configuration data in JSON format
         * @param {ResourceTracker} [resourceTracker]
         */
        object.init = function(config, resourceTracker){
            Util.applyConfig(this, config, ["uid"]);
        };

        /**
         * @method toJSON
         * @return {Object} configuration in JSON
         */
        object.toJSON = function(){
            Util.fail("toJSON does not exist for the Asset");
        };

        (function init(){
            EngineSingleton.engine.project.registerObject(object, name);
        }());
    };

});

define('kick/material/UniformDescriptor',[], function () {
    

    /**
     * @class UniformDescriptor
     * @namespace kick.material
     * @constructor
     * @param {String} name
     * @param {Number} type the WebGL Uniform type
     * @param {Number} size
     * @param {WebGLUniformLocation} location
     */
    return function (name, type, size, location) {
        /**
         * @property name
         * @type String
         */
        this.name = name;
        /**
         * the WebGL Uniform type
         * @property type
         * @type Number
         */
        this.type = type;
        /**
         * @property size
         * @type Number
         */
        this.size = size;
        /**
         * @property location
         * @type WebGLUniformLocation
         */
        this.location = location;
        Object.freeze(this);
    };
});

define('kick/math/Mat3',[], function () {
    

    /**
     * Mat3 - 3x3 Matrix
     * @class Mat3
     * @namespace kick.math
     */
    return {
        /**
         * Creates a new identity Mat3 using the default array type<br>
         * Any javascript array containing at least 9 numeric elements can serve as a mat3
         * @method create
         * @return {kick.math.Mat3} New mat3
         * @static
         */
        create: function () {
            var out = new Float32Array(9);

            out[0] = 1;
            out[4] = 1;
            out[8] = 1;
            return out;
        },

        /**
         * Copies the upper-left 3x3 values into the given mat3.
         * @method fromMat4
         * @param {kick.math.Mat3} out the receiving 3x3 matrix
         * @param {kick.math.Mat4} a   the source 4x4 matrix
         * @return {kick.math.Mat3} out
         */
        fromMat4: function(out, a) {
            out[0] = a[0];
            out[1] = a[1];
            out[2] = a[2];
            out[3] = a[4];
            out[4] = a[5];
            out[5] = a[6];
            out[6] = a[8];
            out[7] = a[9];
            out[8] = a[10];
            return out;
        },

        /**
         * Creates a new mat3 initialized with values from an existing matrix
         * @method clone
         * @param {kick.math.Mat3} a matrix to clone
         * @return {kick.math.Mat3} a new 3x3 matrix
         * @static
         */
        clone: function (a) {
            var out = new Float32Array(9);
            out[0] = a[0];
            out[1] = a[1];
            out[2] = a[2];
            out[3] = a[3];
            out[4] = a[4];
            out[5] = a[5];
            out[6] = a[6];
            out[7] = a[7];
            out[8] = a[8];
            return out;
        },

        /**
         * Copies the values of one mat3 to another
         * @method copy
         * @param {kick.math.Mat3} out the receiving matrix
         * @param {kick.math.Mat3} a the source matrix
         * @return {kick.math.Mat3} out
         * @static
         */
        copy: function (out, a) {
            out[0] = a[0];
            out[1] = a[1];
            out[2] = a[2];
            out[3] = a[3];
            out[4] = a[4];
            out[5] = a[5];
            out[6] = a[6];
            out[7] = a[7];
            out[8] = a[8];
            return out;
        },

        /**
         * Sets a mat3 to an identity matrix
         * @method identity
         * @param {kick.math.Mat3} out mat3 to set
         * @return {kick.math.Mat3} dest
         * @static
         */
        identity: function (out) {
            out[0] = 1;
            out[1] = 0;
            out[2] = 0;
            out[3] = 0;
            out[4] = 1;
            out[5] = 0;
            out[6] = 0;
            out[7] = 0;
            out[8] = 1;
            return out;
        },

        /**
         * Transposes a mat3 (flips the values over the diagonal)
         * @method transpose
         * @param {kick.math.Mat3} out the receiving matrix
         * @param {kick.math.Mat3} a the source matrix
         * @return {kick.math.Mat3} out
         * @static
         */
        transpose: function (out, a) {
            // If we are transposing ourselves we can skip a few steps but have to cache some values
            if (out === a) {
                var a01 = a[1], a02 = a[2], a12 = a[5];
                out[1] = a[3];
                out[2] = a[6];
                out[3] = a01;
                out[5] = a[7];
                out[6] = a02;
                out[7] = a12;
            } else {
                out[0] = a[0];
                out[1] = a[3];
                out[2] = a[6];
                out[3] = a[1];
                out[4] = a[4];
                out[5] = a[7];
                out[6] = a[2];
                out[7] = a[5];
                out[8] = a[8];
            }

            return out;
        },

        /**
         * Inverts a Mat3
         * @method invert
         * @param {kick.math.Mat3} out the receiving matrix
         * @param {kick.math.Mat3} a the source matrix
         * @return {kick.math.Mat3} out
         * @static
         */
        invert: function (out, a) {
            var a00 = a[0], a01 = a[1], a02 = a[2],
                a10 = a[3], a11 = a[4], a12 = a[5],
                a20 = a[6], a21 = a[7], a22 = a[8],

                b01 = a22 * a11 - a12 * a21,
                b11 = -a22 * a10 + a12 * a20,
                b21 = a21 * a10 - a11 * a20,

            // Calculate the determinant
                det = a00 * b01 + a01 * b11 + a02 * b21;

            if (!det) {
                return null;
            }
            det = 1.0 / det;

            out[0] = b01 * det;
            out[1] = (-a22 * a01 + a02 * a21) * det;
            out[2] = (a12 * a01 - a02 * a11) * det;
            out[3] = b11 * det;
            out[4] = (a22 * a00 - a02 * a20) * det;
            out[5] = (-a12 * a00 + a02 * a10) * det;
            out[6] = b21 * det;
            out[7] = (-a21 * a00 + a01 * a20) * det;
            out[8] = (a11 * a00 - a01 * a10) * det;
            return out;
        },
        /**
         * Calculates the adjugate of a mat3
         * @method adjoint
         * @param {kick.math.Mat3} out the receiving matrix
         * @param {kick.math.Mat3} a the source matrix
         * @return {kick.math.Mat3} out
         * @static
         */
        adjoint: function (out, a) {
            var a00 = a[0], a01 = a[1], a02 = a[2],
                a10 = a[3], a11 = a[4], a12 = a[5],
                a20 = a[6], a21 = a[7], a22 = a[8];

            out[0] = (a11 * a22 - a12 * a21);
            out[1] = (a02 * a21 - a01 * a22);
            out[2] = (a01 * a12 - a02 * a11);
            out[3] = (a12 * a20 - a10 * a22);
            out[4] = (a00 * a22 - a02 * a20);
            out[5] = (a02 * a10 - a00 * a12);
            out[6] = (a10 * a21 - a11 * a20);
            out[7] = (a01 * a20 - a00 * a21);
            out[8] = (a00 * a11 - a01 * a10);
            return out;
        },

        /**
         * Calculates the determinant of a Mat3
         * @method determinant
         * @param {kick.math.Mat3} a the source matrix
         * @return {Number} determinant of a matrix
         * @static
         */
        determinant: function (a) {
            var a00 = a[0], a01 = a[1], a02 = a[2],
                a10 = a[3], a11 = a[4], a12 = a[5],
                a20 = a[6], a21 = a[7], a22 = a[8];

            return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
        },

        /**
         * Copies the elements of a mat3 into the upper 3x3 elements of a mat4
         * @method toMat4
         * @param {kick.math.Mat4} out  mat4 receiving copied values
         * @param {kick.math.Mat3} mat mat3 containing values to copy
         * @return {kick.math.Mat4} out
         * @static
         */
        toMat4: function (out, mat) {
            out[15] = 1;
            out[14] = 0;
            out[13] = 0;
            out[12] = 0;

            out[11] = 0;
            out[10] = mat[8];
            out[9] = mat[7];
            out[8] = mat[6];

            out[7] = 0;
            out[6] = mat[5];
            out[5] = mat[4];
            out[4] = mat[3];

            out[3] = 0;
            out[2] = mat[2];
            out[1] = mat[1];
            out[0] = mat[0];

            return out;
        },

        /**
         * Multiplies two mat3's
         * @method multiply
         * @param {kick.math.Mat3} out the receiving matrix
         * @param {kick.math.Mat3} a the first operand
         * @param {kick.math.Mat3} b the second operand
         * @return {kick.math.Mat3} out
         * @static
         */
        multiply: function (out, a, b) {
            var a00 = a[0], a01 = a[1], a02 = a[2],
                a10 = a[3], a11 = a[4], a12 = a[5],
                a20 = a[6], a21 = a[7], a22 = a[8],

                b00 = b[0], b01 = b[1], b02 = b[2],
                b10 = b[3], b11 = b[4], b12 = b[5],
                b20 = b[6], b21 = b[7], b22 = b[8];

            out[0] = b00 * a00 + b01 * a10 + b02 * a20;
            out[1] = b00 * a01 + b01 * a11 + b02 * a21;
            out[2] = b00 * a02 + b01 * a12 + b02 * a22;

            out[3] = b10 * a00 + b11 * a10 + b12 * a20;
            out[4] = b10 * a01 + b11 * a11 + b12 * a21;
            out[5] = b10 * a02 + b11 * a12 + b12 * a22;

            out[6] = b20 * a00 + b21 * a10 + b22 * a20;
            out[7] = b20 * a01 + b21 * a11 + b22 * a21;
            out[8] = b20 * a02 + b21 * a12 + b22 * a22;
            return out;
        },

        /**
         * Translate a mat3 by the given vector
         * @method translate
         * @param {kick.math.Mat3} out the receiving matrix
         * @param {kick.math.Mat3} a the matrix to translate
         * @param {kick.math.Vec2} v vector to translate by
         * @return {kick.math.Mat3} out
         * @static
         */
        translate: function(out, a, v) {
            var a00 = a[0], a01 = a[1], a02 = a[2],
                a10 = a[3], a11 = a[4], a12 = a[5],
                a20 = a[6], a21 = a[7], a22 = a[8],
                x = v[0], y = v[1];

            out[0] = a00;
            out[1] = a01;
            out[2] = a02;

            out[3] = a10;
            out[4] = a11;
            out[5] = a12;

            out[6] = x * a00 + y * a10 + a20;
            out[7] = x * a01 + y * a11 + a21;
            out[8] = x * a02 + y * a12 + a22;
            return out;
        },

        /**
         * Rotates a mat3 by the given angle
         * @method rotate
         * @param {kick.math.Mat3} out the receiving matrix
         * @param {kick.math.Mat3} a the matrix to rotate
         * @param {Number} rad the angle to rotate the matrix by
         * @return {kick.math.Mat3} out
         * @static
         */
        rotate: function (out, a, rad) {
            var a00 = a[0], a01 = a[1], a02 = a[2],
                a10 = a[3], a11 = a[4], a12 = a[5],
                a20 = a[6], a21 = a[7], a22 = a[8],

                s = Math.sin(rad),
                c = Math.cos(rad);

            out[0] = c * a00 + s * a10;
            out[1] = c * a01 + s * a11;
            out[2] = c * a02 + s * a12;

            out[3] = c * a10 - s * a00;
            out[4] = c * a11 - s * a01;
            out[5] = c * a12 - s * a02;

            out[6] = a20;
            out[7] = a21;
            out[8] = a22;
            return out;
        },

        /**
         * Scales the mat3 by the dimensions in the given vec2
         * @method scale
         * @param {kick.math.Mat3} out the receiving matrix
         * @param {kick.math.Mat3} a the matrix to rotate
         * @param {kick.math.Vec2} v the vec2 to scale the matrix by
         * @return {kick.math.Mat3} out
         * @static
         **/
        scale: function(out, a, v) {
            var x = v[0], y = v[2];

            out[0] = x * a[0];
            out[1] = x * a[1];
            out[2] = x * a[2];

            out[3] = y * a[3];
            out[4] = y * a[4];
            out[5] = y * a[5];

            out[6] = a[6];
            out[7] = a[7];
            out[8] = a[8];
            return out;
        },

        /**
         * Copies the values from a mat2d into a mat3
         * @method fromMat2d
         * @param {kick.math.Mat3} out the receiving matrix
         * @param {kick.math.Mat3} a the matrix to rotate
         * @return {kick.math.Mat3} out
         * @static
         **/
        fromMat2d: function(out, a) {
            out[0] = a[0];
            out[1] = a[1];
            out[2] = 0;

            out[3] = a[2];
            out[4] = a[3];
            out[5] = 0;

            out[6] = a[4];
            out[7] = a[5];
            out[8] = 1;
            return out;
        },

        /**
        * Calculates a 3x3 matrix from the given quaternion
        * @method fromQuat
        * @param {kick.math.Mat3} out mat3 receiving operation result
        * @param {kick.math.Quat} q Quaternion to create matrix from
        *
        * @return {kick.math.Mat3} out
        * @static
        */
        fromQuat: function (out, q) {
            var x = q[0], y = q[1], z = q[2], w = q[3],
                x2 = x + x,
                y2 = y + y,
                z2 = z + z,

                xx = x * x2,
                xy = x * y2,
                xz = x * z2,
                yy = y * y2,
                yz = y * z2,
                zz = z * z2,
                wx = w * x2,
                wy = w * y2,
                wz = w * z2;

            out[0] = 1 - (yy + zz);
            out[1] = xy + wz;
            out[2] = xz - wy;

            out[3] = xy - wz;
            out[4] = 1 - (xx + zz);
            out[5] = yz + wx;

            out[6] = xz + wy;
            out[7] = yz - wx;
            out[8] = 1 - (xx + yy);

            return out;
        },


        /**
         * Transform a mat3 into a rotation (quaternion).
         * @method toQuat
         * @param {kick.math.Quat} out
         * @param {kick.math.Mat3} mat
         * @return {kick.math.Quat}
         * @static
         */
        toQuat: function (out, mat) {
            // Code based on http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm
            var m00 = mat[0], m10 = mat[1], m20 = mat[2],
                m01 = mat[3], m11 = mat[4], m21 = mat[5],
                m02 = mat[6], m12 = mat[7], m22 = mat[8],
                trace = m00 + m11 + m22,  // trace of matrix
                s;

            if (!out) {
                out = new Float32Array(4);
            }
            if (trace > 0) {
                s = 0.5 / Math.sqrt(trace + 1.0);
                out[0] = (m21 - m12) * s;
                out[1] = (m02 - m20) * s;
                out[2] = (m10 - m01) * s;
                out[3] = 0.25 / s;
            } else {
                if (m00 > m11 && m00 > m22) {
                    s = 2.0 * Math.sqrt(1.0 + m00 - m11 - m22);
                    out[0] = 0.25 * s;
                    out[1] = (m01 + m10) / s;
                    out[2] = (m02 + m20) / s;
                    out[3] = (m21 - m12) / s;
                } else if (m11 > m22) {
                    s = 2.0 * Math.sqrt(1.0 + m11 - m00 - m22);
                    out[0] = (m01 + m10) / s;
                    out[1] = 0.25 * s;
                    out[2] = (m12 + m21) / s;
                    out[3] = (m02 - m20) / s;
                } else {
                    s = 2.0 * Math.sqrt(1.0 + m22 - m00 - m11);
                    out[0] = (m02 + m20) / s;
                    out[1] = (m12 + m21) / s;
                    out[2] = 0.25 * s;
                    out[3] = (m10 - m01) / s;
                }
            }
            return out;
        },

        /**
         * Returns a string representation of a mat3
         * @method str
         * @param {kick.math.Mat3} mat mat3 to represent as a string
         * @return {String} string representation of mat
         * @static
         */
        str: function (mat) {
            return '[' + mat[0] + ', ' + mat[1] + ', ' + mat[2] +
                ', ' + mat[3] + ', ' + mat[4] + ', ' + mat[5] +
                ', ' + mat[6] + ', ' + mat[7] + ', ' + mat[8] + ']';
        },

        /**
         * Returns a string representation of a mat3 printed as a 4x4 matrix (on 3 lines)
         * @method strPretty
         * @param {kick.math.Mat3} mat mat3 to represent as a string
         * @return {String} string representation of mat
         * @static
         */
        strPretty: function (mat) {
            return '[' + mat[0] + ', ' + mat[3] + ', ' + mat[6] + '\n' +
                ', ' + mat[1] + ', ' + mat[4] + ', ' + mat[7] + '\n' +
                ', ' + mat[2] + ', ' + mat[5] + ', ' + mat[8] + ']';
        }
    };
});

define('kick/core/Observable',["kick/core/Util", "kick/core/Constants"], function (Util, constants) {
    
    var ASSERT = true;
    /**
     * Mixin class that allows listening for specific events on a class.
     * Inspired by the observer pattern ( http://en.wikipedia.org/wiki/Observer_pattern ), where the Observable class
     * has the role of the Subject class from the pattern.
     * Note that there is no Observer objects - only observer functions (observerFn).
     * The observable creates a fixed number of event listener queues for the class, which can be accessed using the
     * methods addEventListener, removeEventListener and getObservers. Events can be fired using fireEvent.
     *
     * To use the class as mixin: kick.core.Observable.call(observableObject,["Foo"]);
     * @example
     *     // 'raw usage'
     *     var observable = new kick.core.Observable(["Foo"]);
     *     var fooValue = 0;
     *     var eventListener = function(v){fooValue = v;};
     *     // register event listener for event "Foo"
     *     observable.addEventListener("Foo", eventListener);
     *     observable.fireEvent("Foo", 1);
     *     // foo value is now 1
     *     observable.removeEventListener("Foo", eventListener);
     *     observable.fireEvent("Foo", 2);
     *     // foo value is still 1, since the listener has been removed
     * @example
     *     // Use observer
     *     var SomeClass = function(){
     *         kick.core.Observable.call(this,["Foo"]);
     *         // [...] rest of class
     *     };
     *     var o = new SomeClass();
     *     o.addEventListener("Foo", function(){ console.log("Some foo!"); });
     *
     * @class Observable
     * @abstract
     * @constructor
     * @namespace kick.core
     * @param {String} eventNames
     */
    return function (eventNames) {
        var observers = {},
            thisObj = this,
            getObservers = function(eventName){
                if (ASSERT){
                    if (typeof eventName !== "string"){
                        Util.fail("eventName must be a string");
                    }
                    if (!observers[eventName]){
                        Util.fail("Event name "+eventName+" not found");
                    }
                }
                return observers[eventName];
            },
            i;

        for (i=0;i<eventNames.length;i++){
            observers[eventNames[i]] = [];
            if (ASSERT){
                (function(name,obj){
                    var value;
                    Object.defineProperty(obj, name, {
                        get: function(){
                            return value;
                        },
                        set: function(newValue){
                            if (value){
                                thisObj.removeEventListener(name, value);
                            }
                            value = newValue;
                            if (value){
                                thisObj.addEventListener(name, value);
                            }
                        }
                    });
                }(eventNames[i], this));
            }
        }
        /**
         * Gets or creates a list of observers bound to the eventName
         * @method getObservers
         * @param {String} eventName
         * @return Array of observer functions
         *
         */
        this.getObservers = getObservers;

        /**
         * Add an observer function
         * @method addEventListener
         * @param {String} eventName
         * @param {Function} observerFn
         */
        this.addEventListener = function(eventName, observerFn){
            if (ASSERT){
                if (typeof observerFn !== "function"){
                    Util.fail("observerFn must be a function");
                }
                if (typeof eventName !== "string"){
                    Util.fail("eventName must be a string");
                }
            }
            var observers = getObservers(eventName);
            observers.push(observerFn);
        };

        /**
         * @method removeEventListener
         * @param {String} eventName
         * @param {Function} observerFn
         */
        this.removeEventListener = function(eventName, observerFn){
            if (ASSERT){
                if (typeof observerFn !== "function"){
                    Util.fail("observerFn must be a function");
                }
                if (typeof eventName !== "string"){
                    Util.fail("eventName must be a string");
                }
            }
            var observers = thisObj.getObservers(eventName);
            Util.removeElementFromArray(observers, observerFn);
        };

        /**
         * Note that fire events should not be called from other classes
         * @method fireEvent
         * @param {String} eventName
         * @param {Object} obj
         * @protected
         */
        this.fireEvent = function(eventName, obj){
            if (ASSERT){
                if (typeof eventName !== "string"){
                    Util.fail("eventName must be a string");
                }
                if (!observers[eventName]){
                    Util.fail("Event name "+eventName+" not found");
                }
            }
            var observerList = observers[eventName],
                i;
            for (i=0;i<observerList.length;i++){
                observerList[i](obj);
            }
        };
    };
});

define('kick/material/Shader',["kick/core/ProjectAsset", "kick/core/Constants", "./GLSLConstants", "kick/core/Util", "./UniformDescriptor", "kick/math/Vec3", "kick/math/Vec4", "kick/math/Mat4", "kick/math/Mat3", "kick/core/EngineSingleton", "kick/core/Observable"],
    function (ProjectAsset, Constants, GLSLConstants, Util, UniformDescriptor, Vec3, Vec4, Mat4, Mat3, EngineSingleton, Observable) {
        

        var Shader,
            shaderUniqueVersionCounter = 0,
            shaderUniqueNameCounter = 0,
            vec3Zero = Vec3.create(),
            tmpVec4 = Vec4.create(),
            tempMat4 = Mat4.create(),
            tempMat3 = Mat3.create(),
            ASSERT = true,
            isMaterialUniformName = function (name) {return name.charAt(0) !== "_"; };

        /**
         * GLSL Shader object<br>
         * The shader basically encapsulates a GLSL shader programs, but makes sure that the correct
         * WebGL settings are set when the shader is bound (such as if blending is enabled or not).<br>
         * The Shader extend the default WebGL GLSL in the following way:
         * <ul>
         *     <li>
         *         <code>#pragma include &lt;filename&gt;</code> includes of the following KickJS file as a string:
         *         <ul>
         *             <li>light.glsl</li>
         *             <li>shadowmap.glsl</li>
         *         </ul>
         *     </li>
         *     <li>Auto binds the following uniform variables:
         *      <ul>
         *          <li><code>_mvProj</code> (mat4) Model view projection matrix</li>
         *          <li><code>_m</code> (mat4) Model matrix</li>
         *          <li><code>_mv</code> (mat4) Model view matrix</li>
         *          <li><code>_v</code> (mat4) View matrix</li>
         *          <li><code>_worldCamPos</code> (vec4) Camera position in world coordinate</li>
         *          <li><code>_world2object</code> (mat4) World to Object coordinate transformation</li>
         *          <li><code>_norm</code> (mat3) Normal matrix (the inverse transpose of the upper 3x3 model view matrix - needed when scaling is scaling is non-uniform)</li>
         *          <li><code>_time</code> (float) Run time of engine</li>
         *          <li><code>_ambient</code> (vec3) Ambient light</li>
         *          <li><code>_dLight</code> (mat3) Directional light matrix. </li>
         *          <li><code>_dLight[0]</code> (vec3) Directional light direction in eye coordinates.</li>
         *          <li><code>_dLight[1]</code> (vec3) Directional light color intensity</li>
         *          <li><code>_dLight[2]</code> (vec3) Directional light half vector</li>
         *          <li><code>_dLightWorldDir</code> (vec3) Directional light world direction</li>
         *          <li><code>_pLights[n]</code> (mat3) Point light matrix</li>
         *          <li><code>_pLights[n][0]</code> (mat3) Point light id n position</li>
         *          <li><code>_pLights[n][1]</code> (mat3) Point light id n color intensity</li>
         *          <li><code>_pLights[n][2]</code> (mat3) Point light id n attenuation vector [const, linear, quadratic]</li>
         *
         *      </ul>
         *     </li>
         *     <li>Defines <code>SHADOW</code> (Boolean) and <code>LIGHTS</code> (Integer) based on the current configuration of the engine (cannot be modified runtime). </li>
         * </ul>
         * @example
         *      var diffuseShader = project.load(project.ENGINE_SHADER_DIFFUSE);
         * @example
         *      var vertexShaderStr = "attribute vec3 vertex;\n"+
         *          "uniform mat4 _mvProj;\n"+
         *          "void main(void) {\n"+
         *          "    gl_Position = _mvProj * vec4(vertex, 1.0);\n"+
         *          "}";
         *      var fragmentShaderStr = "uniform highp float _time;\n"+
         *          "void main(void) {\n"+
         *          "  highp float fraction = mod(_time/1000.0,1.0);\n"+
         *          "  gl_FragColor = vec4(fraction,fraction,fraction, 1.0);\n"+
         *          "}";
         *      var shader = new kick.material.Shader( {
         *              vertexShaderSrc: vertexShaderStr,
         *              fragmentShaderSrc: fragmentShaderStr
         *          });
         * @class Shader
         * @namespace kick.material
         * @constructor
         * @param {Object} config
         * @extends kick.core.ProjectAsset
         */
        Shader = function (config) {
            // extend ProjectAsset
            ProjectAsset(this, config, "kick.material.Shader");
            if (ASSERT){
                if (config === EngineSingleton.engine){
                    Util.fail("Shader constructor changed - engine parameter is removed");
                }
            }
            var engine = EngineSingleton.engine,
                gl = engine.gl,
                glState = engine.glState,
                thisObj = this,
                _shaderProgramId = -1,
                _depthMask = true,
                _faceCulling = 1029,
                _zTest = 513,
                _blend = false,
                _blendSFactorRGB = 770,
                _blendDFactorRGB = 771,
                _blendSFactorAlpha = 770,
                _blendDFactorAlpha = 771,
                _polygonOffsetEnabled = false,
                _polygonOffsetFactor = 2.5,
                _polygonOffsetUnits = 10.0,
                _renderOrder = 1000,
                _dataURI =  "memory://void",
                _name = "",
                blendKey,
                _activeUniforms = [],
                _engineUniforms = [],
                _materialUniforms = [],
                _lookupUniform = {},
                glslConstants = GLSLConstants,
                _vertexShaderSrc = glslConstants["__error_vs.glsl"],
                _fragmentShaderSrc = glslConstants["__error_fs.glsl"],
                _defaultUniforms,
                _errorLog = Util.fail,
                uniqueVersionCounter = -1,
                /**
                 * Updates the blend key that identifies blend+blendSFactor+blendDFactor<br>
                 * The key is used to fast determine if the blend settings needs to be updated
                 * @method updateBlendKey
                 * @private
                 */
                updateBlendKey = function () {
                    blendKey = (_blendSFactorRGB + (_blendDFactorRGB << 10) + (_blendSFactorAlpha << 20) + (_blendDFactorAlpha << 30)) * (_blend ? -1 : 1);
                },
                /**
                 * Invoke shader compilation
                 * @method compileShader
                 * @param {String} str
                 * @param {Boolean} isFragmentShader
                 * @private
                 */
                compileShader = function (str, isFragmentShader) {
                    var shader,
                        infoLog,
                        c = Constants;
                    str = Shader.getPrecompiledSource(str);
                    if (isFragmentShader) {
                        shader = gl.createShader(35632);
                    } else {
                        shader = gl.createShader(35633);
                    }

                    gl.shaderSource(shader, str);
                    gl.compileShader(shader);

                    if (!gl.getShaderParameter(shader, 35713)) {
                        infoLog = gl.getShaderInfoLog(shader);
                        if (typeof _errorLog === "function") {
                            _errorLog(infoLog);
                        }
                        if (isFragmentShader) {
                            thisObj.fireEvent('fragmentShaderError', infoLog);
                        } else {
                            thisObj.fireEvent('vertexShaderError', infoLog);
                        }
                        return null;
                    }

                    return shader;
                },
                updateCullFace = function () {
                    var currentFaceCulling = glState.faceCulling;
                    if (currentFaceCulling !== _faceCulling) {
                        if (_faceCulling === 0) {
                            gl.disable(2884);
                        } else {
                            if (!currentFaceCulling || currentFaceCulling === 0) {
                                gl.enable(2884);
                            }
                            gl.cullFace(_faceCulling);
                        }
                        glState.faceCulling = _faceCulling;
                    }
                },
                updateDepthProperties = function () {
                    if (glState.zTest !== _zTest) {
                        gl.depthFunc(_zTest);
                        glState.zTest = _zTest;
                    }
                    if (glState.depthMaskCache !== _depthMask) {
                        gl.depthMask(_depthMask);
                        glState.depthMaskCache = _depthMask;
                    }
                },
                updateBlending = function () {
                    if (glState.blendKey !== blendKey) {
                        glState.blendKey = blendKey;
                        if (_blend) {
                            gl.enable(3042);
                            gl.blendFuncSeparate(_blendSFactorRGB, _blendDFactorRGB,_blendSFactorAlpha, _blendDFactorAlpha);
                        } else {
                            gl.disable(3042);
                        }
                    }
                },
                updatePolygonOffset = function () {
                    if (glState.polygonOffsetEnabled !== _polygonOffsetEnabled) {
                        glState.polygonOffsetEnabled = _polygonOffsetEnabled;
                        if (_polygonOffsetEnabled) {
                            gl.enable(32823);
                        } else {
                            gl.disable(32823);
                        }
                    }
                    if (_polygonOffsetEnabled) {
                        gl.polygonOffset(_polygonOffsetFactor, _polygonOffsetUnits);
                    }
                },
                getDefaultUniform = function (type, size) {
                    switch (type) {
                    case 5126:
                        return new Float32Array(size);
                    case 35674:
                        return new Float32Array(4 * size);
                    case 35675:
                        return new Float32Array(9 * size);
                    case 35676:
                        return new Float32Array(16 * size);
                    case 35664:
                        return new Float32Array(2 * size);
                    case 35665:
                        return new Float32Array(3 * size);
                    case 35666:
                        return new Float32Array(4 * size);
                    case 5124:
                        return new Int32Array(size);
                    case 35667:
                        return new Int32Array(2 * size);
                    case 35668:
                        return new Int32Array(3 * size);
                    case 35669:
                        return new Int32Array(4 * size);
                    case 35680:
                        if (size !== 1) {
                            Util.fail("Texture arrays not currently supported");
                        }
                        return engine.project.load(engine.project.ENGINE_TEXTURE_CUBEMAP_WHITE);
                    case 35678:
                        if (size !== 1) {
                            Util.fail("Texture arrays not currently supported");
                        }
                        return engine.project.load(engine.project.ENGINE_TEXTURE_WHITE);
                    default:
                        Util.fail("Unknown type");
                    }
                },
                updateActiveUniforms = function (numberOfActiveUniforms) {
                    var uniform,
                        uniformDescriptor,
                        uniformLocation,
                        oldDefaultUniforms = _defaultUniforms,
                        i,
                        defaultValue;
                    _activeUniforms = [];
                    _lookupUniform = {};
                    _defaultUniforms = {};

                    _materialUniforms.length = 0;
                    _engineUniforms.length = 0;

                    for (i = 0; i < numberOfActiveUniforms; i++) {
                        uniform = gl.getActiveUniform(_shaderProgramId, i);
                        uniformLocation = gl.getUniformLocation(_shaderProgramId, uniform.name);
                        if (true) {
                            uniformLocation.shader = thisObj;
                            uniformLocation.shaderVersion = uniqueVersionCounter;
                        }
                        uniformDescriptor = new UniformDescriptor(uniform.name, uniform.type, uniform.size, uniformLocation);
                        Object.freeze(uniformDescriptor);
                        _activeUniforms[i] = uniformDescriptor;
                        _lookupUniform[uniform.name] = uniformDescriptor;
                        if (isMaterialUniformName(uniform.name)) {
                            defaultValue = getDefaultUniform(uniform.type, uniform.size);
                            _defaultUniforms[uniform.name] = defaultValue;
                            _materialUniforms.push(uniformDescriptor);
                        } else {
                            _engineUniforms.push(uniformDescriptor);
                        }
                    }
                    // restore the old default uniforms (if any)
                    if (oldDefaultUniforms) {
                        thisObj.defaultUniforms = oldDefaultUniforms;
                    }
                };

            Observable.call(this, [
            /**
             * Fired when shader is updated
             * @event shaderUpdated
             * @param {kick.material.Shader} shaderInstance
             */
                "shaderUpdated",
            /**
             * Fired when vertex shader is unable to compile
             * @event vertexShaderError
             * @param {string} errorMessage
             */
                "vertexShaderError",
            /**
             * Fired when fragment shader is unable to compile
             * @event fragmentShaderError
             * @param {string} errorMessage
             */
                "fragmentShaderError",
            /**
             * Fired when shader is unable to link
             * @event linkerError
             * @param {string} errorMessage
             */
                "linkerError"
            ]
            );

            /**
             * Registers a listener to the shader.
             * @method addListener
             * @param {Function} listenerFn a function called when shader is updated
             * @deprecated Use addEventListener('shaderUpdated', listenerFn) instead
             */
            this.addListener = function (listenerFn) {
                Util.fail("Use addEventListener('shaderUpdated', listenerFn) instead");
                if (ASSERT) {
                    if (typeof listenerFn !== "function") {
                        Util.warn("Shader.addListener: listenerFn not function");
                    }
                }
                thisObj.addEventListener("shaderUpdated", listenerFn);

            };

            /**
             * Removes a listener to the shader.
             * @method removeListener
             * @param {Function} listenerFn a function called when shader is updated
             * @deprecated Use removeEventListener('shaderUpdated', listenerFn) instead
             */
            this.removeListener = function (listenerFn) {
                Util.fail("Use addEventListener('shaderUpdated', listenerFn) instead");
                if (ASSERT) {
                    if (typeof listenerFn !== "function") {
                        Util.warn("Shader.removeListener: listenerFn not function");
                    }
                }
                thisObj.removeEventListener("shaderUpdated", listenerFn);
            };

            /**
             * @method contextLost
             * @protected
             */
            this.contextLost = function () {
                gl = null;
                _shaderProgramId = -1;
                _activeUniforms.length = 0;
                _engineUniforms.length = 0;
                _materialUniforms.length = 0;
            };

            /**
             * This method is public and may be called multiple times (both from materials using the shader and from the engine)
             * @method contextRestored
             * @protected
             */
            this.contextRestored = function (newGL) {
                if (!gl) {
                    gl = newGL;
                    thisObj.apply();
                }
            };

            engine.addEventListener('contextLost', this.contextLost);
            engine.addEventListener('contextRestored', this.contextRestored);

            Object.defineProperties(this, {
                /**
                 * Lookup of uniform based on name.
                 * for each name a kick.material.UniformDescriptor object exist
                 * @property lookupUniform
                 * @type Object
                 */
                lookupUniform: {
                    get: function () { return _lookupUniform; }
                },
                /**
                 * Array of Object with size,type, name and index properties
                 * @property activeUniforms
                 * @type Array_kick.material.UniformDescriptor
                 */
                activeUniforms: {
                    get: function () { return _activeUniforms; }
                },
                /**
                 * Array of Object with size,type, name and index properties
                 * @property engineUniforms
                 * @type Array Array_kick.material.UniformDescriptor
                 */
                engineUniforms: {
                    get: function () { return _engineUniforms; }
                },
                /**
                 * Array of Object with size,type, name and index properties
                 * @property materialUniforms
                 * @type Array Array_kick.material.UniformDescriptor
                 */
                materialUniforms: {
                    get: function () { return _materialUniforms; }
                },
                /**
                 * @property name
                 * @type String
                 */
                name: {
                    get: function () { return _name; },
                    set: function (newValue) { _name = newValue; }
                },
                /**
                 * When dataURI is specified the shader is expected to have its content from the dataURI.
                 * This means when serializing the object only dataURI and name will be saved
                 * @property dataURI
                 * @type String
                 */
                dataURI: {
                    get: function () { return _dataURI; },
                    set: function (newValue) {
                        if (_dataURI !== newValue) {
                            _dataURI = newValue;
                            if (_dataURI) { // load resource if not null
                                engine.resourceLoader.getShaderData(_dataURI, thisObj);
                            }
                        }
                    }
                },
                /**
                 * Get the gl context of the shader
                 * @property gl
                 * @type Object
                 */
                gl: {
                    value: gl
                },
                /**
                 * Get the gl state
                 * @property glState
                 * @type Object
                 */
                glState: {
                    value: glState
                },
                /**
                 * Get default configuration of shader uniforms
                 * @property defaultUniforms
                 * @type Object
                 */
                defaultUniforms: {
                    get: function () { return _defaultUniforms; },
                    set: function (value) {
                        var name, type;
                        for (name in _defaultUniforms ) {
                            if (_defaultUniforms.hasOwnProperty(name) && value.hasOwnProperty(name)) {
                                type = _lookupUniform[name].type;
                                _defaultUniforms[name] = Shader.convertUniformValue(type, value[name], engine);
                            }
                        }
                    }
                },
                /**
                 * @property vertexShaderSrc
                 * @type string
                 */
                vertexShaderSrc: {
                    get: function () { return _vertexShaderSrc; },
                    set: function (value) {
                        if (typeof value !== "string") {
                            Util.fail("Shader.vertexShaderSrc must be a string");
                        }
                        _vertexShaderSrc = value;
                    }
                },
                /**
                 * @property fragmentShaderSrc
                 * @type string
                 */
                fragmentShaderSrc: {
                    get: function () { return _fragmentShaderSrc; },
                    set: function (value) {
                        if (typeof value !== "string") {
                            Util.fail("Shader.fragmentShaderSrc must be a string");
                        }
                        _fragmentShaderSrc = value;
                    }
                },
                /**
                 * Render order. Default value 1000. The following ranges are predefined:<br>
                 * 0-999: Background. Mainly for skyboxes etc<br>
                 * 1000-1998 Opaque geometry  (default)<br>
                 * 1999-1999 Skybox<br>
                 * 2000-2999 Transparent. This queue is sorted in a back to front order before rendering.<br>
                 * 3000-3999 Overlay
                 * @property renderOrder
                 * @type Number
                 */
                renderOrder: {
                    get: function () { return _renderOrder; },
                    set: function (value) {
                        if (typeof value !== "number") {
                            Util.fail("Shader.renderOrder must be a number");
                        }
                        _renderOrder = value;
                        thisObj.fireEvent('shaderUpdated', thisObj);
                    }
                },
                /**
                 * Function that will be invoked in case of error
                 * @property errorLog
                 * @type Function
                 */
                errorLog: {
                    get: function () {
                        return _errorLog;
                    },
                    set: function (value) {
                        if (ASSERT) {
                            if (value && typeof value !== 'function') {
                                Util.fail("Shader.errorLog should be a function (or null)");
                            }
                        }
                        _errorLog = value;
                    }
                },
                /**
                 * A reference to the engine object
                 * @property engine
                 * @type kick.core.Engine
                 */
                engine: {
                    value: engine
                },
                /**
                 * @property shaderProgramId
                 * @type ShaderProgram
                 */
                shaderProgramId: {
                    get: function () { return _shaderProgramId; }
                },
                /**
                 * (From http://www.opengl.org/)<br>
                 * When GL\_POLYGON\_OFFSET\_FILL, GL\_POLYGON\_OFFSET\_LINE, or GL\_POLYGON\_OFFSET\_POINT is enabled, each
                 * fragment's depth value will be offset after it is interpolated from the depth values of the appropriate
                 * vertices. The value of the offset is factor  DZ + r  units , where DZ is a measurement of the change
                 * in depth relative to the screen area of the polygon, and r is the smallest value that is guaranteed to
                 * produce a resolvable offset for a given implementation. The offset is added before the depth test is
                 * performed and before the value is written into the depth buffer.<br><br>
                 *
                 * glPolygonOffset is useful for rendering hidden-line images, for applying decals to surfaces, and for
                 * rendering solids with highlighted edges.<br><br>
                 * Possible values:<br>
                 * true or false<br>
                 * Default false
                 * @property polygonOffsetEnabled
                 * @type boolean
                 * @default false
                 */
                polygonOffsetEnabled: {
                    get: function () {
                        return _polygonOffsetEnabled;
                    },
                    set: function (value) {
                        _polygonOffsetEnabled = value;
                    }
                },
                /**
                 * @property polygonOffsetFactor
                 * @type Number
                 * @default 2.5
                 */
                polygonOffsetFactor: {
                    get: function () {
                        return _polygonOffsetFactor;
                    },
                    set: function (value) {
                        _polygonOffsetFactor = value;
                    }
                },
                /**
                 * @property polygonOffsetUnits
                 * @type Number
                 * @default 10.0
                 */
                polygonOffsetUnits: {
                    get: function () {
                        return _polygonOffsetUnits;
                    },
                    set: function (value) {
                        _polygonOffsetUnits = value;
                    }
                },
                /**
                 * Must be set to kick.core.Constants.GL\_FRONT, kick.core.Constants.GL\_BACK (default),
                 * kick.core.Constants.GL\_FRONT\_AND\_BACK, kick.core.Constants.NONE<br>
                 * Note that in faceCulling = GL\_FRONT, GL\_BACK or GL\_FRONT\_AND\_BACK with face culling enabled<br>
                 * faceCulling = GL\_NONE means face culling disabled
                 * @property faceCulling
                 * @type Object
                 * @default 1029
                 */
                faceCulling: {
                    get: function () { return _faceCulling; },
                    set: function (newValue) {
                        if (ASSERT) {
                            if (newValue !== 1028 &&
                                    newValue !== 1032 &&
                                    newValue !== 1029 &&
                                    newValue !== 0) {
                                Util.fail("Shader.faceCulling must be kick.material.Shader.FRONT, " +
                                    "kick.material.Shader.BACK (default), kick.material.Shader.NONE");
                            }
                        }
                        _faceCulling = newValue;
                    }
                },
                /**
                 * Enable or disable writing into the depth buffer
                 * @property depthMask
                 * @type Boolean
                 * @default true
                 */
                depthMask: {
                    get: function () { return _depthMask; },
                    set: function (newValue) {
                        if (ASSERT) {
                            if (typeof newValue !== 'boolean') {
                                Util.fail("Shader.depthMask must be a boolean. Was " + (typeof newValue));
                            }
                        }
                        _depthMask = newValue;
                    }
                },
                /**
                 * The depth test function. Must be one of
                 * kick.core.Constants.GL\_NEVER,
                 * kick.core.Constants.GL\_LESS,
                 * kick.core.Constants.GL\_EQUAL,
                 * kick.core.Constants.GL\_LEQUAL,
                 * kick.core.Constants.GL\_GREATER,
                 * kick.core.Constants.GL\_NOTEQUAL,
                 * kick.core.Constants.GL\_GEQUAL,
                 * kick.core.Constants.GL\_ALWAYS
                 * @property zTest
                 * @type Object
                 * @default 513
                 */
                zTest: {
                    get: function () { return _zTest; },
                    set: function (newValue) {
                        if (ASSERT) {
                            if (newValue !== 512 &&
                                    newValue !== 513 &&
                                    newValue !== 514 &&
                                    newValue !== 515 &&
                                    newValue !== 516 &&
                                    newValue !== 517 &&
                                    newValue !== 518 &&
                                    newValue !== 519) {
                                Util.fail("Shader.zTest must be 512, " +
                                    "513,514,515," +
                                    "516,517,518, " +
                                    "or 519");
                            }
                        }
                        _zTest = newValue;
                    }
                },
                /**
                 * Enables/disables blending (default is false).<br>
                 * "In RGBA mode, pixels can be drawn using a function that blends the incoming (source) RGBA values with the
                 * RGBA values that are already in the frame buffer (the destination values)"
                 * (From <a href="http://www.opengl.org/sdk/docs/man/xhtml/glBlendFunc.xml">www.Opengl.org</a>)
                 * @property blend
                 * @type Boolean
                 */
                blend: {
                    get: function () { return _blend; },
                    set: function (value) {
                        if (ASSERT) {
                            if (typeof value !== 'boolean') {
                                Util.fail("Shader.blend must be a boolean");
                            }
                        }
                        _blend = value;
                        updateBlendKey();
                    }
                },
                /**
                 * Specifies the blend source-factor for the RGB channel<br>
                 * Initial value GL\_SRC\_ALPHA
                 * Must be set to one of: GL\_ZERO, GL\_ONE, GL\_SRC\_COLOR, GL\_ONE\_MINUS\_SRC\_COLOR, GL\_DST\_COLOR,
                 * GL\_ONE\_MINUS\_DST\_COLOR, GL\_SRC\_ALPHA, GL\_ONE\_MINUS\_SRC\_ALPHA, GL\_DST\_ALPHA, GL\_ONE\_MINUS\_DST\_ALPHA,
                 * GL\_CONSTANT\_COLOR, GL\_ONE\_MINUS\_CONSTANT\_COLOR, GL\_CONSTANT\_ALPHA, GL\_ONE\_MINUS\_CONSTANT\_ALPHA, and
                 * GL\_SRC\_ALPHA\_SATURATE.<br>
                 * See <a href="http://www.opengl.org/sdk/docs/man/xhtml/glBlendFunc.xml">glBlendFunc on opengl.org</a>
                 * @property blendSFactorRGB
                 * @type Number
                 * @default 770
                 */
                blendSFactorRGB:{
                    get: function(){
                        return _blendSFactorRGB;
                    },
                    set: function(value){
                        if (ASSERT) {
                            var c = Constants;
                            if (value !== 0 &&
                                value !== 1 &&
                                value !== 768 &&
                                value !== 769 &&
                                value !== 774 &&
                                value !== 775 &&
                                value !== 770 &&
                                value !== 771 &&
                                value !== 772 &&
                                value !== 773 &&
                                value !== 32769 &&
                                value !== 32770 &&
                                value !== 32771 &&
                                value !== 32772 &&
                                value !== 776) {
                                Util.fail("Shader.blendSFactor must be a one of GL_ZERO, GL_ONE, GL_SRC_COLOR, " +
                                    "GL_ONE_MINUS_SRC_COLOR, GL_DST_COLOR, GL_ONE_MINUS_DST_COLOR, GL_SRC_ALPHA, " +
                                    "GL_ONE_MINUS_SRC_ALPHA, GL_DST_ALPHA, GL_ONE_MINUS_DST_ALPHA, GL_CONSTANT_COLOR, " +
                                    "GL_ONE_MINUS_CONSTANT_COLOR, GL_CONSTANT_ALPHA, GL_ONE_MINUS_CONSTANT_ALPHA, and " +
                                    "GL_SRC_ALPHA_SATURATE.");
                            }
                        }
                        _blendSFactorRGB = value;
                        updateBlendKey();
                    }
                },
                /**
                 * Specifies the blend source-factor for the alpha channel<br>
                 * Initial value GL\_SRC\_ALPHA
                 * Must be set to one of: GL\_ZERO, GL\_ONE, GL\_SRC\_COLOR, GL\_ONE\_MINUS\_SRC\_COLOR, GL\_DST\_COLOR,
                 * GL\_ONE\_MINUS\_DST\_COLOR, GL\_SRC\_ALPHA, GL\_ONE\_MINUS\_SRC\_ALPHA, GL\_DST\_ALPHA, GL\_ONE\_MINUS\_DST\_ALPHA,
                 * GL\_CONSTANT\_COLOR, GL\_ONE\_MINUS\_CONSTANT\_COLOR, GL\_CONSTANT\_ALPHA, GL\_ONE\_MINUS\_CONSTANT\_ALPHA, and
                 * GL\_SRC\_ALPHA\_SATURATE.<br>
                 * See <a href="http://www.opengl.org/sdk/docs/man/xhtml/glBlendFunc.xml">glBlendFunc on opengl.org</a>
                 * @property blendSFactorAlpha
                 * @type Number
                 * @default 770
                 */
                blendSFactorAlpha:{
                    get: function(){
                        return _blendSFactorAlpha;
                    },
                    set: function(value){
                        if (ASSERT) {
                            var c = Constants;
                            if (value !== 0 &&
                                value !== 1 &&
                                value !== 768 &&
                                value !== 769 &&
                                value !== 774 &&
                                value !== 775 &&
                                value !== 770 &&
                                value !== 771 &&
                                value !== 772 &&
                                value !== 773 &&
                                value !== 32769 &&
                                value !== 32770 &&
                                value !== 32771 &&
                                value !== 32772 &&
                                value !== 776) {
                                Util.fail("Shader.blendSFactorAlpha must be a one of GL_ZERO, GL_ONE, GL_SRC_COLOR, " +
                                    "GL_ONE_MINUS_SRC_COLOR, GL_DST_COLOR, GL_ONE_MINUS_DST_COLOR, GL_SRC_ALPHA, " +
                                    "GL_ONE_MINUS_SRC_ALPHA, GL_DST_ALPHA, GL_ONE_MINUS_DST_ALPHA, GL_CONSTANT_COLOR, " +
                                    "GL_ONE_MINUS_CONSTANT_COLOR, GL_CONSTANT_ALPHA, GL_ONE_MINUS_CONSTANT_ALPHA, and " +
                                    "GL_SRC_ALPHA_SATURATE.");
                            }
                        }
                        _blendSFactorAlpha = value;
                        updateBlendKey();
                    }
                },
                /**
                 * Short for blendSFactorAlpha and blendSFactorRGB
                 * Specifies the blend s-factor<br>
                 * Initial value GL\_SRC\_ALPHA
                 * Must be set to one of: GL\_ZERO, GL\_ONE, GL\_SRC\_COLOR, GL\_ONE\_MINUS\_SRC\_COLOR, GL\_DST\_COLOR,
                 * GL\_ONE\_MINUS\_DST\_COLOR, GL\_SRC\_ALPHA, GL\_ONE\_MINUS\_SRC\_ALPHA, GL\_DST\_ALPHA, GL\_ONE\_MINUS\_DST\_ALPHA,
                 * GL\_CONSTANT\_COLOR, GL\_ONE\_MINUS\_CONSTANT\_COLOR, GL\_CONSTANT\_ALPHA, GL\_ONE\_MINUS\_CONSTANT\_ALPHA, and
                 * GL\_SRC\_ALPHA\_SATURATE.<br>
                 * See <a href="http://www.opengl.org/sdk/docs/man/xhtml/glBlendFunc.xml">glBlendFunc on opengl.org</a>
                 * @property blendSFactor
                 * @type Number
                 */
                blendSFactor: {
                    get: function () { return _blendSFactorRGB; },
                    set: function (value) {
                        thisObj.blendSFactorAlpha = value;
                        thisObj.blendSFactorRGB = value;
                    }
                },
                /**
                 * Specifies the blend d-factor for the RGB channel<br>
                 * Initial value GL\_SRC\_ALPHA
                 * Must be set to one of: GL\_ZERO, GL\_ONE, GL\_SRC\_COLOR, GL\_ONE\_MINUS\_SRC\_COLOR, GL\_DST\_COLOR,
                 * GL\_ONE\_MINUS\_DST\_COLOR, GL\_SRC\_ALPHA, GL\_ONE\_MINUS\_SRC\_ALPHA, GL\_DST\_ALPHA, GL\_ONE\_MINUS\_DST\_ALPHA,
                 * GL\_CONSTANT\_COLOR, GL\_ONE\_MINUS\_CONSTANT\_COLOR, GL\_CONSTANT\_ALPHA, GL\_ONE\_MINUS\_CONSTANT\_ALPHA, and
                 * GL\_ONE\_MINUS\_SRC\_ALPHA.<br>
                 * See <a href="http://www.opengl.org/sdk/docs/man/xhtml/glBlendFunc.xml">glBlendFunc on opengl.org</a>
                 * @property blendDFactorRGB
                 * @type Number
                 * @default 771
                 */
                blendDFactorRGB: {
                    get: function(){
                        return _blendDFactorRGB;
                    },
                    set: function(value){
                        if (ASSERT) {
                            var c = Constants;
                            if (value !== 0 &&
                                value !== 1 &&
                                value !== 768 &&
                                value !== 769 &&
                                value !== 774 &&
                                value !== 775 &&
                                value !== 770 &&
                                value !== 771 &&
                                value !== 772 &&
                                value !== 773 &&
                                value !== 32769 &&
                                value !== 32770 &&
                                value !== 32771 &&
                                value !== 32772) {
                                Util.fail("Shader.blendDFactorRGB must be a one of GL_ZERO, GL_ONE, GL_SRC_COLOR, " +
                                    "GL_ONE_MINUS_SRC_COLOR, GL_DST_COLOR, GL_ONE_MINUS_DST_COLOR, GL_SRC_ALPHA, " +
                                    "GL_ONE_MINUS_SRC_ALPHA, GL_DST_ALPHA, GL_ONE_MINUS_DST_ALPHA, GL_CONSTANT_COLOR, " +
                                    "GL_ONE_MINUS_CONSTANT_COLOR, GL_CONSTANT_ALPHA, and GL_ONE_MINUS_CONSTANT_ALPHA.");
                            }
                        }
                        _blendDFactorRGB = value;
                        updateBlendKey();
                    }
                },
                /**
                 * Specifies the blend d-factor for the alpha channel<br>
                 * Initial value GL\_SRC\_ALPHA
                 * Must be set to one of: GL\_ZERO, GL\_ONE, GL\_SRC\_COLOR, GL\_ONE\_MINUS\_SRC\_COLOR, GL\_DST\_COLOR,
                 * GL\_ONE\_MINUS\_DST\_COLOR, GL\_SRC\_ALPHA, GL\_ONE\_MINUS\_SRC\_ALPHA, GL\_DST\_ALPHA, GL\_ONE\_MINUS\_DST\_ALPHA,
                 * GL\_CONSTANT\_COLOR, GL\_ONE\_MINUS\_CONSTANT\_COLOR, GL\_CONSTANT\_ALPHA, GL\_ONE\_MINUS\_CONSTANT\_ALPHA, and
                 * GL\_ONE\_MINUS\_SRC\_ALPHA.<br>
                 * See <a href="http://www.opengl.org/sdk/docs/man/xhtml/glBlendFunc.xml">glBlendFunc on opengl.org</a>
                 * @property blendDFactorAlpha
                 * @type Number
                 * @default 771
                 */
                blendDFactorAlpha: {
                    get: function(){
                        return _blendDFactorAlpha;
                    },
                    set: function(value){
                        if (ASSERT) {
                            var c = Constants;
                            if (value !== 0 &&
                                value !== 1 &&
                                value !== 768 &&
                                value !== 769 &&
                                value !== 774 &&
                                value !== 775 &&
                                value !== 770 &&
                                value !== 771 &&
                                value !== 772 &&
                                value !== 773 &&
                                value !== 32769 &&
                                value !== 32770 &&
                                value !== 32771 &&
                                value !== 32772) {
                                Util.fail("Shader.blendDFactorAlpha must be a one of GL_ZERO, GL_ONE, GL_SRC_COLOR, " +
                                    "GL_ONE_MINUS_SRC_COLOR, GL_DST_COLOR, GL_ONE_MINUS_DST_COLOR, GL_SRC_ALPHA, " +
                                    "GL_ONE_MINUS_SRC_ALPHA, GL_DST_ALPHA, GL_ONE_MINUS_DST_ALPHA, GL_CONSTANT_COLOR, " +
                                    "GL_ONE_MINUS_CONSTANT_COLOR, GL_CONSTANT_ALPHA, and GL_ONE_MINUS_CONSTANT_ALPHA.");
                            }
                        }
                        _blendDFactorAlpha = value;
                        updateBlendKey();
                    }
                },
                /**
                 * Short for blendDFactorAlpha and blendDFactorRGB
                 * Initial value GL\_SRC\_ALPHA
                 * Must be set to one of: GL\_ZERO, GL\_ONE, GL\_SRC\_COLOR, GL\_ONE\_MINUS\_SRC\_COLOR, GL\_DST\_COLOR,
                 * GL\_ONE\_MINUS\_DST\_COLOR, GL\_SRC\_ALPHA, GL\_ONE\_MINUS\_SRC\_ALPHA, GL\_DST\_ALPHA, GL\_ONE\_MINUS\_DST\_ALPHA,
                 * GL\_CONSTANT\_COLOR, GL\_ONE\_MINUS\_CONSTANT\_COLOR, GL\_CONSTANT\_ALPHA, GL\_ONE\_MINUS\_CONSTANT\_ALPHA, and
                 * GL\_ONE\_MINUS\_SRC\_ALPHA.<br>
                 * See <a href="http://www.opengl.org/sdk/docs/man/xhtml/glBlendFunc.xml">glBlendFunc on opengl.org</a>
                 * @property blendDFactor
                 * @type Number
                 */
                blendDFactor: {
                    get: function () { return _blendDFactorRGB; },
                    set: function (value) {
                        thisObj.blendDFactorAlpha = value;
                        thisObj.blendDFactorRGB = value;
                    }
                },
                /**
                 * Unique shader version (this number will change whenever apply is invoked). The value may be different after serialization.
                 * @property shaderVersion
                 * @type Number
                 */
                shaderVersion : {
                    get: function () {
                        return uniqueVersionCounter;
                    }
                }
            });

            /**
             * Flush the current shader bound - this force the shader to be reloaded (and its uniforms and vertex attributes
             * are reassigned)
             * @method markUniformUpdated
             */
            this.markUniformUpdated = function () {
                glState.boundShader = -1;
                glState.meshShader = -1;
            };

            /**
             * Updates the shader (must be called after any shader state is changed to apply changes)
             * @method apply
             * @return {Boolean} shader created successfully
             */
            this.apply = function () {
                var errorLog = _errorLog || console.log,
                    vertexShader = compileShader(_vertexShaderSrc, false, errorLog),
                    fragmentShader = compileShader(_fragmentShaderSrc, true, errorLog),
                    compileError = fragmentShader === null || vertexShader === null,
                    i,
                    numberOfActiveUniforms,
                    activeAttributes,
                    attribute;
                if (compileError) {
                    vertexShader = compileShader(glslConstants["__error_vs.glsl"], false, errorLog);
                    fragmentShader = compileShader(glslConstants["__error_fs.glsl"], true, errorLog);
                }

                _shaderProgramId = gl.createProgram();

                gl.attachShader(_shaderProgramId, vertexShader);
                gl.attachShader(_shaderProgramId, fragmentShader);
                gl.linkProgram(_shaderProgramId);
                gl.deleteShader(vertexShader);
                gl.deleteShader(fragmentShader);

                if (!gl.getProgramParameter(_shaderProgramId, 35714)) {
                    compileError = gl.getProgramInfoLog(_shaderProgramId);
                    errorLog(compileError);
                    thisObj.fireEvent('linkerError', compileError);
                    return false;
                }

                uniqueVersionCounter = (shaderUniqueVersionCounter++);

                gl.useProgram(_shaderProgramId);
                glState.boundShader = _shaderProgramId;
                numberOfActiveUniforms = gl.getProgramParameter(_shaderProgramId, 35718);
                updateActiveUniforms(numberOfActiveUniforms);

                activeAttributes = gl.getProgramParameter(_shaderProgramId, 35721);
                /**
                 * Array of JSON data with size,type and name
                 * @property activeAttributes
                 * @type Array_Object
                 */
                thisObj.activeAttributes = [];
                /**
                 * Lookup of attribute location based on name.
                 * @property lookupAttribute
                 * @type Object
                 */
                thisObj.lookupAttribute = {};
                for (i = 0; i < activeAttributes; i++) {
                    attribute = gl.getActiveAttrib(_shaderProgramId, i);
                    thisObj.activeAttributes[i] = {
                        size: attribute.size,
                        type: attribute.type,
                        name: attribute.name
                    };
                    thisObj.lookupAttribute[attribute.name] = i;
                }

                thisObj.markUniformUpdated();

                thisObj.fireEvent('shaderUpdated', thisObj);

                return !compileError;
            };

            /**
             * Deletes the shader program from memory.
             * A destroyed shader can be used again if update shader is called
             * @method destroy
             */
            this.destroy = function () {
                if (_shaderProgramId !== -1) {
                    engine.removeEventListener('contextLost', thisObj.contextLost);
                    engine.removeEventListener('contextRestored', thisObj.contextRestored);
                    gl.deleteProgram(_shaderProgramId);
                    _shaderProgramId = -1;
                    engine.project.removeResourceDescriptor(thisObj.uid);
                }
            };

            /**
             * Return true if the shader compiled successfully and is not destroyed
             * @method isValid
             * @return {Boolean} is shader valid
             */
            this.isValid = function () {
                return _shaderProgramId !== -1;
            };

            /**
             * @method bind
             */
            this.bind = function () {
                if (ASSERT) {
                    if (!(thisObj.isValid)) {
                        Util.fail("Cannot bind a shader that is not valid");
                    }
                }
                if (glState.boundShader !== _shaderProgramId) {
                    glState.boundShader = _shaderProgramId;
                    gl.useProgram(_shaderProgramId);
                    updateCullFace();
                    updateDepthProperties();
                    updateBlending();
                    updatePolygonOffset();
                }
            };

            /**
             * Serializes the data into a JSON object (that can be used as a config parameter in the constructor)<br>
             * Note errorLog are not serialized
             * @method toJSON
             * @return {Object} config element
             */
            this.toJSON = function () {
                if (_dataURI) {
                    return {
                        uid: thisObj.uid,
                        name: _name,
                        dataURI: _dataURI
                    };
                }
                return {
                    uid: thisObj.uid,
                    name: _name,
                    blend: _blend,
                    blendSFactorRGB: _blendSFactorRGB,
                    blendDFactorRGB: _blendDFactorRGB,
                    blendSFactorAlpha: _blendSFactorAlpha,
                    blendDFactorAlpha: _blendDFactorAlpha,
                    dataURI: _dataURI,
                    depthMask: _depthMask,
                    faceCulling: _faceCulling,
                    fragmentShaderSrc: _fragmentShaderSrc,
                    vertexShaderSrc: _vertexShaderSrc,
                    polygonOffsetEnabled: _polygonOffsetEnabled,
                    polygonOffsetFactor: _polygonOffsetFactor,
                    polygonOffsetUnits: _polygonOffsetUnits,
                    renderOrder: _renderOrder,
                    zTest: _zTest,
                    defaultUniforms: _defaultUniforms
                };
            };

            this.init = function(config){
                Util.applyConfig(thisObj, config, ["uid"]);
                if (_dataURI && _dataURI.indexOf("memory://") !== 0) {
                    engine.resourceLoader.getShaderData(_dataURI, thisObj);
                } else {
                    updateBlendKey();
                    thisObj.apply();
                }
                if (_name === "") {
                    _name = "Shader_" + shaderUniqueNameCounter;
                    shaderUniqueNameCounter++;
                }
            };
            this.init(config);
        };


        /**
         * @method getPrecompiledSource
         * @param {String} sourcecode
         * @return {String} sourcecode after precompiler
         * @static
         */
        Shader.getPrecompiledSource = function (sourcecode) {
            var engine = EngineSingleton.engine,
                name,
                source,
                version = "#version 100",
                lineOffset = 1,
                regExpSearch,
                indexOfNewline;
            if (true) {
                if (sourcecode === engine){
                    Util.fail("Shader.getPrecompiledSource() - engine parameter removed");
                    return null;
                }
                (function () {
                    // insert #line nn after each #pragma include to give meaning full lines in error console
                    var linebreakPosition = [],
                        position = sourcecode.indexOf('\n'),
                        i,
                        nextPosition;
                    while (position !== -1) {
                        position++;
                        linebreakPosition.push(position);
                        position = sourcecode.indexOf('\n', position);
                    }
                    for (i = linebreakPosition.length - 2; i >= 0; i--) {
                        position = linebreakPosition[i];
                        nextPosition = linebreakPosition[i + 1];
                        if (sourcecode.substring(position).indexOf("#pragma include") === 0) {
                            sourcecode = sourcecode.substring(0, nextPosition) + ("#line  " + (i + 2) + "\n") + sourcecode.substring(nextPosition);
                        }
                    }
                }());
            }
            function escapeRegExp(str) {
                return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
            }
            for (name in GLSLConstants) {
                if (GLSLConstants.hasOwnProperty(name)) {
                    if (typeof name === "string") {
                        source = GLSLConstants[name];
                        regExpSearch = "^\\s*#\\s*pragma\\s+include\\s*"+escapeRegExp("\"" + name + "\"")+".*$";
                        sourcecode = sourcecode.replace(new RegExp(regExpSearch, "gm"), source);
                    }
                }
            }

            // remove commented out usages of #pragma include
            regExpSearch = "//\\s*pragma\\s+include.*$";
            sourcecode = sourcecode.replace(new RegExp(regExpSearch, "gm"), "");

            // if shader already contain version tag, then reuse this version information
            if (sourcecode.indexOf("#version ") === 0) {
                indexOfNewline = sourcecode.indexOf('\n');
                version = sourcecode.substring(0, indexOfNewline); // save version info
                sourcecode = sourcecode.substring(indexOfNewline + 1); // strip version info
                lineOffset = 2;
            }
            sourcecode =
                version + "\n" +
                    "#define SHADOWS " + (engine.config.shadows === true) + "\n" +
                    "#define LIGHTS " + (engine.config.maxNumerOfLights) + "\n" +
                    "#line " + lineOffset + "\n" +
                    sourcecode;
            return sourcecode;
        };

        /**
         * Update the material uniform
         * @method bindMaterialUniform
         * @param material
         * @param engineUniforms
         */
        Shader.prototype.bindMaterialUniform = function (material, engineUniforms) {
            // lookup uniforms
            var gl = this.gl,
                glState = this.glState,
                timeObj,
                sceneLights = engineUniforms.sceneLights,
                ambientLight,
                lookupUniforms = this.lookupUniform,
                proj = lookupUniforms._proj,
                directionalLightUniform = lookupUniforms._dLight,
                directionalLightWorldUniform = lookupUniforms._dLightWorldDir,
                pointLightUniform = lookupUniforms["_pLights[0]"],
                time = lookupUniforms._time,
                viewport = lookupUniforms._viewport,
                lightUniformAmbient =  lookupUniforms._ambient,
                currentTexture = 0,
                ambientLlightValue;

            currentTexture = material.bind(currentTexture);

            if (proj) {
                gl.uniformMatrix4fv(proj.location, false, engineUniforms.projectionMatrix);
            }
            if (lightUniformAmbient) {
                ambientLight = sceneLights.ambientLight;
                ambientLlightValue = ambientLight !== null ? ambientLight.colorIntensity : vec3Zero;
                gl.uniform3fv(lightUniformAmbient.location, ambientLlightValue);
            }

            if (directionalLightUniform) {
                gl.uniformMatrix3fv(directionalLightUniform.location, false, sceneLights.directionalLightData);
            }
            if (directionalLightWorldUniform) {
                gl.uniform3fv(directionalLightWorldUniform.location, sceneLights.directionalLightWorld);
            }

            if (pointLightUniform) {
                gl.uniformMatrix3fv(pointLightUniform.location, false, sceneLights.pointLightData);
            }
            if (time) {
                timeObj = this.engine.time;
                gl.uniform1f(time.location, timeObj.time);
            }
            if (viewport) {
                gl.uniform2fv(viewport.location, glState.viewportSize);
            }
            return currentTexture;
        };

        /**
         * Binds the uniforms to the current shader.
         * The uniforms is expected to be in a valid format.
         * The method will call Shader.bindMaterialUniform if material uniforms needs to be changed.
         * @method bindUniform
         * @param {kick.material.Material} material
         * @param {Object} engineUniforms
         * @param {kick.scene.Transform} transform
         */
        Shader.prototype.bindUniform = function (material, engineUniforms, transform) {
            var lookupUniform = this.lookupUniform,
                gl = this.gl,
                glState = this.glState,
                modelMatrix = lookupUniform._m,
                mv = lookupUniform._mv,
                v = lookupUniform._v,
                worldCamPos = lookupUniform._worldCamPos,
                world2object = lookupUniform._world2object,
                mvProj = lookupUniform._mvProj,
                norm = lookupUniform._norm,
                gameObjectUID = lookupUniform._gameObjectUID,
                shadowMapTexture = lookupUniform._shadowMapTexture,
                _lightMat = lookupUniform._lightMat,
                sceneLights = engineUniforms.sceneLights,
                directionalLight = sceneLights.directionalLight,
                globalTransform,
                i,
                uidAsVec4,
                modelView,
                normalMatrix,
                currentTexture = 0;
            if (glState.currentMaterial !== material) {
                glState.currentMaterial = material;
                currentTexture = this.bindMaterialUniform(material, engineUniforms);
            }

            // mesh instance uniforms
            if (modelMatrix || mv || norm) {
                globalTransform = transform.getGlobalMatrix();
                if (modelMatrix) {
                    gl.uniformMatrix4fv(modelMatrix.location, false, globalTransform);
                }
                modelView = Mat4.multiply(tempMat4, engineUniforms.viewMatrix, globalTransform);
                if (mv) {
                    gl.uniformMatrix4fv(mv.location, false, modelView);
                }
                if (norm) {
                    // note this can be simplified to
                    // var normalMatrix = math.Mat4.toMat3(math.Mat3.create(), finalModelView);
                    // if the modelViewMatrix is orthogonal (non-uniform scale is not applied)
                    //var normalMatrix = mat3.transpose(mat4.toInverseMat3(finalModelView));
                    normalMatrix = Mat4.toNormalMat3(tempMat3, modelView);
                    if (ASSERT) {
                        if (!normalMatrix) {
                            Util.fail("Singular matrix");
                        }
                    }
                    gl.uniformMatrix3fv(norm.location, false, normalMatrix);
                }
            }
            if (v){
                gl.uniformMatrix4fv(v.location, false, engineUniforms.viewMatrix);
            }
            if (worldCamPos) {
                gl.uniform3fv(worldCamPos.location, engineUniforms.currentCameraTransform.position);
            }
            if (world2object) {
                gl.uniformMatrix4fv(world2object.location, false, transform.getGlobalTRSInverse());
            }
            if (mvProj) {
                globalTransform = globalTransform || transform.getGlobalMatrix();
                gl.uniformMatrix4fv(mvProj.location, false, Mat4.multiply(tempMat4, engineUniforms.viewProjectionMatrix, globalTransform));
            }
            if (gameObjectUID) {
                uidAsVec4 = Util.uint32ToVec4(transform.gameObject.uid, tmpVec4);
                if (this.engine.time.frame < 3) {
                    console.log("transform.gameObject.uid " + transform.gameObject.uid);
                }
                gl.uniform4fv(gameObjectUID.location, uidAsVec4);
            }
            if (shadowMapTexture && directionalLight && directionalLight.shadowTexture) {
                directionalLight.shadowTexture.bind(currentTexture);
                gl.uniform1i(shadowMapTexture.location, currentTexture);
                currentTexture++;
            }
            if (_lightMat) {
                globalTransform = transform.getGlobalMatrix();
                gl.uniformMatrix4fv(_lightMat.location, false, Mat4.multiply(tempMat4, engineUniforms.lightMatrix, globalTransform));
            }
        };

        /*
         * If the uniform value is not in a valid format, the uniformValue is converted
         * @method convertUniformValue
         * @param {Number} type
         * @param {Object} uniformValue
         * @param {kick.core.Engine} engine
         * @static
         */
        Shader.convertUniformValue = function (type, uniformValue, engine) {
            if (type === 35678 || type === 35680) {
                if (uniformValue && typeof uniformValue.ref === 'number') {
                    return engine.project.load(uniformValue.ref);
                }
            }
            if (Array.isArray(uniformValue) || typeof uniformValue === 'number') {
                var array = uniformValue;
                if (typeof array === 'number') {
                    array = [array];
                }
                if (type === 5124 || type === 35667 || type === 35668 || type === 35669) {
                    return new Int32Array(array);
                } else {
                    return new Float32Array(array);
                }
            }
            return uniformValue;
        };

        Object.freeze(Shader);

        return Shader;
    });

define('kick/texture/Texture',["kick/core/ProjectAsset", "kick/core/Constants", "kick/core/Util", "kick/math/Vec2", "kick/core/EngineSingleton"],
    function (ProjectAsset, Constants, Util, Vec2, EngineSingleton) {
        

        var DEBUG = true;

        /**
         * Encapsulate a texture object and its configuration. Note that the texture configuration
         * must be set prior to assigning the texture (using either init, setImage or setImageData).<br>
         *
         * Cubemaps must have dimensions width = height * 6 and the order of the cubemap is
         * positiveX, negativeX, positiveY, negativeY, positiveZ, negativeZ
         * @class Texture
         * @namespace kick.texture
         * @constructor
         * @param {Object} [config]
         * @extends kick.core.ProjectAsset
         */
        return function (config) {
            // extend ProjectAsset
            ProjectAsset(this, config, "kick.texture.Texture");
            if (true) {
                if (config === EngineSingleton.engine) {
                    Util.fail("Texture constructor changed - engine parameter is removed");
                }
            }
            var engine = EngineSingleton.engine,
                gl = engine.gl,
                glState = engine.glState,
                texture0 = 33984,
                createImageFunction,
                createImageFunctionParameters,
                _textureId = gl.createTexture(),
                _name = "Texture",
                _wrapS =  10497,
                _wrapT = 10497,
                _minFilter = 9729,
                _magFilter = 9729,
                _generateMipmaps = true,
                _autoRescale = true,
                _isMipMapGenerated = false,
                _hasDataOnGPU = false,
                _dataURI =  "memory://void",
                _flipY =  true,
                _type,
                _intFormat = 6408,
                _textureType = 3553,
                _boundTextureType = null,
                thisObj = this,
                _dimension = Vec2.create(),
                /**
                 * @method recreateTextureIfDifferentType
                 * @private
                 */
                recreateTextureIfDifferentType = function () {
                    if (_boundTextureType !== null && _boundTextureType !== _textureType) {
                        gl.deleteTexture(_textureId);
                        _textureId = gl.createTexture();
                    }
                    _boundTextureType = _textureType;
                },
                createMipmaps = function () {
                    gl.generateMipmap(_textureType);
                    _isMipMapGenerated = true;
                },

                contextLost = function () {
                    gl = null;
                },
                contextRestored = function (newGl) {
                    gl = newGl;
                    _textureId = gl.createTexture();
                    if (createImageFunction) {
                        createImageFunction.apply(thisObj, createImageFunctionParameters);
                    }
                };

            /**
             * Trigger getImageData if dataURI is defined
             * @method init
             */
            this.init = function () {
                if (_dataURI) {
                    engine.resourceLoader.getImageData(_dataURI, thisObj);
                }
            };

            /**
             * Applies the texture settings
             * @method apply
             */
            this.apply = function () {
                if (DEBUG) {
                    if (!_generateMipmaps) {
                        if (_minFilter !== 9728 &&
                                _minFilter !== 9729) {
                            Util.warn("When generateMipmaps is false min filter must be either GL_NEAREST or GL_LINEAR");
                        }
                    }
                }

                thisObj.bind(0); // bind to texture slot 0
                if (_textureType === 3553) {
                    gl.texParameteri(3553, 10242, _wrapS);
                    gl.texParameteri(3553, 10243, _wrapT);
                }
                gl.texParameteri(_textureType, 10240, _magFilter);
                gl.texParameteri(_textureType, 10241, _minFilter);
            };

            /**
             * Bind the current texture
             * @method bind
             */
            this.bind = function (textureSlot) {
                gl.activeTexture(texture0 + textureSlot);
                gl.bindTexture(_textureType, _textureId);
            };

            /**
             * Deallocate the texture from memory
             * @method destroy
             */
            this.destroy = function () {
                if (_textureId !== null) {
                    gl.deleteTexture(_textureId);
                    _textureId = null;
                    engine.project.removeResourceDescriptor(thisObj.uid);
                }
                createImageFunction = null;
                createImageFunctionParameters = null;
                engine.removeEventListener('contextLost', contextLost);
                engine.removeEventListener('contextRestored', contextRestored);
            };

            /**
             * Verifies the current texture configuration and returns the texture error (if any)
             * @method getTextureError
             * @return {String|null}
             */
            this.getTextureError = function(){
                var isPowerOfTwo = Util.isPowerOfTwo(_dimension[0]) &&
                    Util.isPowerOfTwo(_dimension[1]);
                if (!_autoRescale){
                    if (_generateMipmaps && !isPowerOfTwo){
                        return "Mipmaps is only suported by power of two textures";
                    }

                }
                if (_generateMipmaps && (_type===5126 || _type=== 36193)){
                    return "Mipmaps not supported for floating point textures";
                }

                return null;
            };

            /**
             * Set texture image based on a image object.<br>
             * The image is automatically resized nearest power of two<br>
             * When a textureType == TEXTURE\_CUBE\_MAP the image needs to be in the following format:
             * <ul>
             *     <li>width = 6*height</li>
             *     <li>Image needs to be ordered: [Right, Left, Top, Bottom, Front, Back] (As in <a href="http://www.cgtextures.com/content.php?action=tutorial&name=cubemaps">NVidia DDS Exporter</a>)</li>
             * </ul>
             * @method setImage
             * @param {Image} imageObj image object to import
             * @param {String} dataURI String representing the image
             */
            this.setImage = function (imageObj, dataURI) {
                createImageFunction = thisObj.setImage;
                createImageFunctionParameters = arguments;
                var width, height, cubemapOrder, srcWidth, srcHeight, canvas, ctx, i;
                _dataURI = dataURI;
                recreateTextureIfDifferentType();
                thisObj.bind(0); // bind to texture slot 0
                if (_textureType === 3553) {
                    if (_autoRescale){
                        if (!Util.isPowerOfTwo(imageObj.width) || !Util.isPowerOfTwo(imageObj.height)) {
                            width = Util.nextHighestPowerOfTwo(imageObj.width);
                            height = Util.nextHighestPowerOfTwo(imageObj.height);
                            imageObj = Util.scaleImage(imageObj, width, height);
                        }
                    }
                    if (_flipY) {
                        gl.pixelStorei(37440, true);
                    } else {
                        gl.pixelStorei(37440, false);
                    }
                    gl.pixelStorei(3317, 1);
                    gl.texImage2D(3553, 0, _intFormat, _intFormat, 5121, imageObj);
                    Vec2.copy(_dimension, [imageObj.width, imageObj.height]);
                } else {
                    cubemapOrder = [
                        34069,
                        34070,
                        34071,
                        34072,
                        34073,
                        34074
                    ];
                    srcWidth = imageObj.width / 6;
                    srcHeight = imageObj.height;
                    height = Util.nextHighestPowerOfTwo(imageObj.height);
                    //noinspection JSSuspiciousNameCombination
                    width = height;
                    canvas = document.createElement("canvas");
                    canvas.width = width;
                    canvas.height = height;
                    ctx = canvas.getContext("2d");
                    for (i = 0; i < 6; i++) {
                        ctx.drawImage(imageObj,
                            i * srcWidth, 0, srcWidth, srcHeight,
                            0, 0, width, height);
                        gl.pixelStorei(37440, false);
                        gl.pixelStorei(3317, 1);
                        gl.texImage2D(cubemapOrder[i], 0, _intFormat, _intFormat, 5121, canvas);
                    }
                    Vec2.copy(_dimension, [width, height]);
                }
                _type = 5121;
                thisObj.apply();
                if (_generateMipmaps) {
                    createMipmaps();
                }
                _hasDataOnGPU = true;
                glState.currentMaterial = null; // for material to rebind
            };

            /**
             * Calling this function has the side effect of enabling floating point texture (in available on platform)
             * Use GLState.depthTextureExtension instead
             * @method isFPTexturesSupported
             * @return {Boolean}
             * @deprecated
             */
            this.isFPTexturesSupported = function () {
                var res = gl.isTexFloatEnabled;
                if (typeof res !== 'boolean') {
                    res = gl.getExtension("OES_texture_float"); // this has the side effect of enabling the extension
                    gl.isTexFloatEnabled = res;
                }
                return res;
            };

            /**
             * Updates a subset of the texture
             * Note the type of pixels is assumed to be the same as in setImageData
             * @example
             *     var texture = new kick.texture.Texture();
             *     texture.setImageData(2,2,0,5121,null);
             *     texture.setSubImageData(0, 0, 1, 1, new Uint8Array([255,255,255,255]));
             * @method setSubImageData
             * @param {Number} xoffset
             * @param {Number} yoffset
             * @param {Number} width
             * @param {Number} height
             * @param {ArrayBufferView} pixels
             */
            this.setSubImageData = function (xoffset, yoffset, width, height, pixels) {
                if (true) {
                    if (!_textureType) {
                        Util.fail("Texture.textureType not set");
                        return;
                    }
                    if (!_hasDataOnGPU){
                        Util.fail("Texture.setSubImageData must be called after Texture.setImageData or Texture.setImage");
                    }
                    if (width <=0 || height <=0){
                        Util.fail("Texture.setSubImageData width and height must be larger than 0");
                    }
                    if (xoffset + width > _dimension[0]){
                        Util.fail("Texture.setSubImageData xoffset ("+xoffset+") + width ("+width+") must be less than / equal to texture width ("+_dimension[0]+")");
                    }
                    if (yoffset + height > _dimension[1]){
                        Util.fail("Texture.setSubImageData xoffset ("+yoffset+") + width ("+height+") must be less than / equal to texture width ("+_dimension[1]+")");
                    }
                }
                var i,
                    textureSides = _textureType === 3553 ?
                        [3553] :
                        [34069,
                            34070,
                            34071,
                            34072,
                            34073,
                            34074];
                thisObj.bind(0); // bind to texture slot 0
                glState.currentMaterial = null; // for material to rebind
                gl.pixelStorei(3317, 1);
                for (i = 0; i < textureSides.length; i++) {
                    gl.texSubImage2D(textureSides[i], 0, xoffset, yoffset, width, height, _intFormat, _type, pixels);
                }
            };

            /**
             * Set a image using a raw bytearray in a specified format.
             * GL\_FLOAT / GL\_HALF\_FLOAT\_OES should only be used if extension is supported (See GLState.textureFloatExtension / GLState.textureFloatHalfExtension).
             * If only one of GL\_FLOAT/GL\_HALF\_FLOAT\_OES is supported, then the engine will silently use the supported type.
             * If used on cubemap-texture then all 6 sides of the cube is assigned
             * @example
             *     texture = new kick.texture.Texture();
             *     var data = new Uint8Array([
             *         255,255,255,255, 255,0,0,255,
             *         0,255,0,255, 0,0,255,255
             *     ]);
             *     texture.setImageData(2,2,0,5121,data);
             * @method setImageData
             * @param {Number} width image width in pixels
             * @param {Number} height image height in pixels
             * @param {Number} border image border in pixels
             * @param {Object} type GL\_FLOAT, GL\_HALF\_FLOAT_OES, GL\_UNSIGNED\_BYTE, GL\_UNSIGNED\_SHORT\_4\_4\_4\_4, GL\_UNSIGNED\_SHORT\_5\_5\_5\_1 or GL\_UNSIGNED\_SHORT\_5\_6\_5
             * @param {ArrayBufferView} pixels array of pixels (may be null)
             * @param {String} dataURI String representing the image
             * @param {Number} [cubemapIndex] The cubemap index (only for cubemaps) [+x,-x,+y,-y,+z,-z]. Default is all cubemaps.
             */
            this.setImageData = function (width, height, border, type, pixels, dataURI, cubemapIndex) {
                createImageFunction = thisObj.setImageData;
                createImageFunctionParameters = arguments;
                var textureSides = _textureType === 3553 ?
                            [3553] :
                            [34069,
                                34070,
                                34071,
                                34072,
                                34073,
                                34074];
                recreateTextureIfDifferentType();
                if (type === 5126) {
                    if (!glState.depthTextureExtension) {
                        if (glState.textureFloatHalfExtension) {
                            type = 36193;
                        } else {
                            Util.fail("OES_texture_float unsupported on the platform. Using GL_UNSIGNED_BYTE instead of GL_FLOAT.");
                            type = 5121;
                        }
                    }
                }
                if (type === 36193){
                    if (!glState.textureFloatHalfExtension) {
                        if (glState.depthTextureExtension) {
                            type = 5126;
                        } else {
                            Util.fail("OES_texture_half_float unsupported on the platform. Using GL_UNSIGNED_BYTE instead of GL_HALF_FLOAT_OES.");
                            type = 5121;
                        }
                    }
                }
                if (true) {
                    if (type !== 5126 &&
                            type !== 5121 &&
                            type !== 32819  &&
                            type !== 32820 &&
                            type !== 33635) {
                        Util.fail("Texture.setImageData (type) should be either GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_5_5_5_1 or GL_UNSIGNED_SHORT_5_6_5");
                    }
                }
                if (!_textureType) {
                    Util.fail("Texture.textureType not set");
                    return;
                }


                Vec2.copy(_dimension, [width, height]);
                _dataURI = dataURI;

                thisObj.bind(0); // bind to texture slot 0
                gl.pixelStorei(3317, 1);
                if (typeof cubemapIndex !== "undefined" || _textureType === 3553){
                    gl.texImage2D(textureSides[cubemapIndex || 0], 0, _intFormat, width, height, border, _intFormat, type, pixels);
                } else {
                    for (var i = 0; i < textureSides.length; i++) {
                        gl.texImage2D(textureSides[i], 0, _intFormat, width, height, border, _intFormat, type, pixels);
                    }
                }

                gl.texParameteri(_textureType, 10240, _magFilter);
                gl.texParameteri(_textureType, 10241, _minFilter);
                gl.texParameteri(_textureType, 10242, _wrapS);
                gl.texParameteri(_textureType, 10243, _wrapT);
                _type = type;
                if (_generateMipmaps) {
                    createMipmaps();
                }
                _hasDataOnGPU = true;
                glState.currentMaterial = null; // for material to rebind
            };

            /**
             * Creates a 2x2 temporary image (white)
             * @method setTemporaryTexture
             */
            this.setTemporaryTexture = function () {
                var whiteImage = new Uint8Array([255, 255, 255, 255,
                        255, 255, 255,255,
                        255, 255, 255,255,
                        255, 255, 255,255]),
                    oldIntFormat = _intFormat;
                this.internalFormat = 6408;
                this.setImageData(2, 2, 0, 5121, whiteImage, "kickjs://texture/white/");
                _intFormat = oldIntFormat;
            };

            /**
             * Allows setting the dataURI without reloading the image
             * @method setDataURI
             * @param newValue
             * @param automaticGetTextureData
             */
            this.setDataURI = function (newValue, automaticGetTextureData) {
                if (newValue !== _dataURI) {
                    _dataURI = newValue;
                    if (automaticGetTextureData) {
                        engine.resourceLoader.getImageData(_dataURI, thisObj);
                    }
                }
            };

            Object.defineProperties(this, {
                /**
                 * @property engine
                 * @type kick.core.Engine
                 */
                engine: {
                    value: engine
                },
                /**
                 * @property textureId
                 * @type Number
                 * @protected
                 */
                textureId: {
                    value: _textureId
                },
                /**
                 * @property name
                 * @type String
                 */
                name: {
                    get: function () {
                        return _name;
                    },
                    set: function (newValue) {
                        _name = newValue;
                    }
                },
                /**
                 * Dimension of texture [width,height].<br>
                 * Note for cube maps the size is for one face
                 * @property dimension
                 * @type {vec2}
                 */
                dimension: {
                    get: function () {
                        return _dimension;
                    }
                },
                /**
                 * URI of the texture. This property does not load any texture. To load a texture, set this property and
                 * call the init function (or load the image manually and call the setImage() function).<br>
                 * If texture is not on same server, then the web server must support CORS<br>
                 * See http://hacks.mozilla.org/2011/11/using-cors-to-load-webgl-textures-from-cross-domain-images/
                 * @property dataURI
                 * @type String
                 */
                dataURI: {
                    get: function () {
                        return _dataURI;
                    },
                    set: function (newValue) {
                        thisObj.setDataURI(newValue, true);
                    }
                },
                /**
                 * Texture.wrapS should be either GL\_CLAMP\_TO\_EDGE or GL\_REPEAT<br>
                 * @property wrapS
                 * @type Object
                 * @default GL_REPEAT
                 */
                wrapS: {
                    get: function () {
                        return _wrapS;
                    },
                    set: function (value) {
                        if (true) {
                            if (value !== 33071 && value !== 10497) {
                                Util.fail("Texture.wrapS should be either GL_CLAMP_TO_EDGE or GL_REPEAT");
                            }
                        }
                        _wrapS = value;
                    }
                },
                /**
                 * Texture.wrapT should be either GL\_CLAMP\_TO\_EDGE or GL\_REPEAT<br>
                 * @property wrapT
                 * @type Object
                 * @default GL_REPEAT
                 */
                wrapT: {
                    get: function () {
                        return _wrapT;
                    },
                    set: function (value) {
                        if (true) {
                            if (value !== 33071 && value !== 10497) {
                                Util.fail("Texture.wrapT should be either GL_CLAMP_TO_EDGE or GL_REPEAT");
                            }
                        }
                        _wrapT = value;
                    }
                },
                /**
                 * Texture.minFilter should be either GL\_NEAREST, GL\_LINEAR, GL\_NEAREST\_MIPMAP\_NEAREST, <br>
                 * GL\_LINEAR\_MIPMAP\_NEAREST, GL\_NEAREST\_MIPMAP\_LINEAR, GL\_LINEAR\_MIPMAP\_LINEAR<br>
                 * @property minFilter
                 * @type Object
                 * @default GL_LINEAR
                 */
                minFilter: {
                    get: function () {
                        return _minFilter;
                    },
                    set: function (value) {
                        if (true) {
                            if (value !== 9728 &&
                                    value !== 9729 &&
                                    value !== 9984 &&
                                    value !== 9985 &&
                                    value !== 9986 &&
                                    value !== 9987) {
                                Util.fail("Texture.minFilter should be either GL_NEAREST, GL_LINEAR, GL_NEAREST_MIPMAP_NEAREST, GL_LINEAR_MIPMAP_NEAREST, GL_NEAREST_MIPMAP_LINEAR, GL_LINEAR_MIPMAP_LINEAR");
                            }
                        }
                        _minFilter = value;
                    }
                },
                /**
                 * Texture.magFilter should be either GL\_NEAREST or GL\_LINEAR. <br>
                 * @property magFilter
                 * @type Object
                 * @default GL_LINEAR
                 */
                magFilter: {
                    get: function () {
                        return _magFilter;
                    },
                    set: function (value) {
                        if (true) {
                            if (value !== 9728 && value !== 9729) {
                                Util.fail("Texture.magFilter should be either GL_NEAREST or GL_LINEAR");
                            }
                        }
                        _magFilter = value;
                    }
                },
                /**
                 * Autogenerate mipmap levels<br>
                 * When an existing texture (without mipmaps) has generateMipmaps=true, then mipmaps are created instantly.
                 * @property generateMipmaps
                 * @type Boolean
                 * @default true
                 */
                generateMipmaps: {
                    get: function () {
                        return _generateMipmaps;
                    },
                    set: function (value) {
                        if (true) {
                            if (typeof value !== 'boolean') {
                                Util.fail("Texture.generateMipmaps was not a boolean");
                            }
                        }
                        _generateMipmaps = value;
                        if (_generateMipmaps && !_isMipMapGenerated && _hasDataOnGPU) {
                            thisObj.bind(0);
                            createMipmaps();
                        }
                    }
                },
                /**
                 * When importing image flip the Y direction of the image
                 * <br>
                 * This property is ignored for cube maps.
                 * @property flipY
                 * @type Boolean
                 * @default true
                 */
                flipY: {
                    get: function () {
                        return _flipY;
                    },
                    set: function (value) {
                        if (true) {
                            if (typeof value !== 'boolean') {
                                Util.fail("Texture.flipY was not a boolean");
                            }
                        }
                        _flipY = value;
                    }
                },
                /**
                 * Specifies the internal format of the image (format on GPU)<br>
                 * Must be one of the following:
                 * GL\_ALPHA,
                 * GL\_RGB,
                 * GL\_RGBA,
                 * GL\_LUMINANCE,
                 * GL\_LUMINANCE_ALPHA
                 * @property internalFormat
                 * @type Number
                 * @default GL_RGBA
                 */
                internalFormat: {
                    get: function () {
                        return _intFormat;
                    },
                    set: function (value) {
                        if (value !== 6406 &&
                                value !== 6407  &&
                                value !== 6408 &&
                                value !== 6409 &&
                                value !== 6410) {
                            Util.fail("Texture.internalFormat should be either GL_ALPHA, GL_RGB, GL_RGBA, GL_LUMINANCE, or LUMINANCE_ALPHA");
                        }
                        _intFormat = value;
                    }
                },
                autoRescale: {
                    get: function(){
                        return _autoRescale;
                    },
                    set: function(newValue){
                        _autoRescale = newValue;
                    }
                },
                /**
                 * Specifies the texture type<br>
                 * Default is GL\_TEXTURE_2D<br>
                 * Must be one of the following:
                 * GL\_TEXTURE_2D,
                 * GL\_TEXTURE_CUBE_MAP
                 * @property textureType
                 * @type Number
                 * @default GL_TEXTURE_2D
                 */
                textureType: {
                    get: function () {
                        return _textureType;
                    },
                    set: function (value) {
                        if (value !== 3553 && value !== 34067) {
                            Util.fail("Texture.textureType should be either GL_TEXTURE_2D or GL_TEXTURE_CUBE_MAP");
                        }
                        _textureType = value;
                    }
                }
            });

            /**
             * Serializes the data into a JSON object (that can be used as a config parameter in the constructor)<br>
             * Note that the texture data is not serialized in the json format. <br>
             * This means that either setImage() or setImageData() must be called before the texture can be bound<br>
             * @method toJSON
             * @return {Object} config element
             */
            this.toJSON = function () {
                return {
                    uid: thisObj.uid,
                    wrapS: _wrapS,
                    wrapT: _wrapT,
                    minFilter: _minFilter,
                    magFilter: _magFilter,
                    autoRescale: _autoRescale,
                    name: _name,
                    generateMipmaps: _generateMipmaps,
                    flipY: _flipY,
                    internalFormat: _intFormat,
                    textureType: _textureType,
                    dataURI: _dataURI
                };
            };

            this.init = function (config) {
                // apply
                Util.applyConfig(thisObj, config, ["uid", "dataURI"]);
                if (config && config.dataURI) {
                    // set dataURI last to make sure that object is configured before initialization
                    thisObj.dataURI = config.dataURI;
                }
            };
            this.init(config);

            engine.addEventListener('contextLost', contextLost);
            engine.addEventListener('contextRestored', contextRestored);
        };

    }
);

define('kick/mesh/Mesh',["kick/core/ProjectAsset", "kick/core/Constants", "kick/core/Util", "./MeshData", "kick/core/EngineSingleton"], function (ProjectAsset, Constants, Util, MeshData, EngineSingleton) {
    


    /**
     * @module kick.mesh
     */
    var ASSERT = true;

    /**
     * A Mesh object allows you to bind and render a MeshData object
     * @class Mesh
     * @namespace kick.mesh
     * @constructor
     * @param {Object} config
     * @extends kick.core.ProjectAsset
     */
    return function (config) {
        // extend ProjectAsset
        ProjectAsset(this, config, "kick.mesh.Mesh");
        if (ASSERT){
            if (config === EngineSingleton.engine){
                Util.fail("Mesh constructor changed - engine parameter is removed");
            }
        }
        var engine = EngineSingleton.engine,
            gl = engine.gl,
            glState = engine.glState,
            vertexArrayObjectExtension = glState.vertexArrayObjectExtension,
            vertexArrayObject = {},
            meshVertexAttBuffer,
            interleavedArrayFormat,
            interleavedArrayFormatArray = [],
            meshVertexIndexBuffer = 0,
            meshVertexBufferOffsetBytes = [],
            _name,
            _meshData,
            _dataURI = "memory://void",
            _aabb = null,
            thisObj = this,
            c = Constants,
            vertexAttrLength = 0,
            meshType,
            meshElements = [],
            deleteVertexArrayObjects = function () {
                var name;
                for (name in vertexArrayObject){
                    if (vertexArrayObject.hasOwnProperty(name)) {
                        vertexArrayObjectExtension.deleteVertexArrayOES(vertexArrayObject[name]);
                    }
                }
                vertexArrayObject = {};
            },
            deleteBuffersAndVertexArrayObjects = function () {
                deleteVertexArrayObjects();
                if (meshVertexIndexBuffer){
                    gl.deleteBuffer(meshVertexIndexBuffer);
                    meshVertexIndexBuffer = 0;
                }
                meshVertexBufferOffsetBytes.length = 0;
                if (meshVertexAttBuffer) {
                    gl.deleteBuffer(meshVertexAttBuffer);
                    meshVertexAttBuffer = null;
                }
                meshElements.length = 0;
            },
            createInterleavedArrayFormatArray = function () {
                var obj,
                    descName;
                interleavedArrayFormatArray.length = 0;
                for (descName in interleavedArrayFormat) {
                    if (interleavedArrayFormat.hasOwnProperty(descName)) {
                        obj = interleavedArrayFormat[descName];
                        if (!obj.name) {
                            obj.name = descName;
                        }
                        interleavedArrayFormatArray.push(obj);
                    }
                }
            },
            /**
             * Copy data to the vertex buffer object (VBO)
             * @method updateData
             * @private
             * @param {Boolean} updateVertexData
             * @param {Boolean} updateIndices
             * @param {Boolean} updateVertexStructure
             */
            updateData = (function(){
                var meshVertexAttBufferLength = -1,
                    meshVertexIndexBufferLength = -1,
                    indicesSize = 0;
                return function (updateVertexData, updateIndices, updateVertexStructure) {
                    var subMeshes = _meshData.subMeshes,
                        i,
                        indexLen,
                        interleavedData = _meshData.interleavedArray,
                        meshVertexIndexBufferConcat,
                        SIZE_OF_SHORT = 2;
                    if (vertexArrayObjectExtension) {
                        vertexArrayObjectExtension.bindVertexArrayOES(null);
                    }

                    if (updateVertexStructure){
                        deleteVertexArrayObjects();
                        interleavedArrayFormat = _meshData.interleavedArrayFormat;
                        createInterleavedArrayFormatArray();
                        vertexAttrLength = _meshData.vertexAttrLength;
                        meshType = _meshData.meshType;
                        meshVertexBufferOffsetBytes.length = 0;
                        meshElements.length = 0;
                        indicesSize = 0;
                        for (i = 0; i < subMeshes.length; i++) {
                            meshVertexBufferOffsetBytes.push(indicesSize * SIZE_OF_SHORT);
                            indexLen = subMeshes[i].length;
                            meshElements[i] = indexLen;
                            indicesSize += indexLen;
                        }
                    }

                    if (updateVertexData){
                        if (interleavedData.length !== meshVertexAttBufferLength || !meshVertexAttBuffer){
                            if (meshVertexAttBuffer){
                                gl.deleteBuffer(meshVertexAttBuffer);
                            }
                            meshVertexAttBuffer = gl.createBuffer();
                        }
                        gl.bindBuffer(34962, meshVertexAttBuffer);
                        gl.bufferData(34962, interleavedData, _meshData.usage);
                        meshVertexAttBufferLength = interleavedData.length;
                    }

                    if (updateIndices){
                        meshVertexIndexBufferConcat = new Uint16Array(indicesSize);
                        for (i = 0; i < subMeshes.length; i++) {
                            meshVertexIndexBufferConcat.set(subMeshes[i], meshVertexBufferOffsetBytes[i] / 2);
                        }
                        if (meshVertexIndexBufferConcat.length !== meshVertexIndexBufferLength || !meshVertexIndexBuffer){
                            if (meshVertexIndexBuffer){
                                gl.deleteBuffer(meshVertexIndexBuffer);
                            }
                            meshVertexIndexBuffer = gl.createBuffer();
                        }
                        gl.bindBuffer(34963, meshVertexIndexBuffer);
                        gl.bufferData(34963, meshVertexIndexBufferConcat, _meshData.usage);
                        meshVertexIndexBufferLength = meshVertexIndexBufferConcat.length;
                    }
                    glState.meshBuffer = null;
                }}()),
            contextLost = function () {
                meshVertexIndexBuffer = 0;
                meshVertexAttBuffer = null;
                gl = null;
            },
            contextRestored = function (newGl) {
                gl = newGl;
                vertexArrayObject = {};
                vertexArrayObjectExtension = glState.vertexArrayObjectExtension,
                updateData(true, true, true);
            },
            bindBuffers = function(shader){
                var i,
                    interleavedDataDescriptor,
                    name,
                    shaderAttribute,
                    activeAttribute,
                    attributeIndex;
                gl.bindBuffer(34962, meshVertexAttBuffer);
                for (i = 0; i < interleavedArrayFormatArray.length; i++) {
                    interleavedDataDescriptor = interleavedArrayFormatArray[i];
                    name = interleavedDataDescriptor.name;
                    shaderAttribute = shader.lookupAttribute[name];
                    if (typeof (shaderAttribute) !== 'undefined') {
                        gl.enableVertexAttribArray(shaderAttribute);
                        gl.vertexAttribPointer(shaderAttribute, interleavedDataDescriptor.size,
                            interleavedDataDescriptor.type, false, vertexAttrLength, interleavedDataDescriptor.pointer);
                    }
                }
                gl.bindBuffer(34963, meshVertexIndexBuffer);
                if (ASSERT) {
                    for (i = shader.activeAttributes.length - 1; i >= 0; i--) {
                        activeAttribute = shader.activeAttributes[i];
                        if (interleavedArrayFormat && !(interleavedArrayFormat[activeAttribute.name])) {
                            Util.fail("Shader wants " + activeAttribute.name + " but mesh does not have it.");
                            attributeIndex = shader.lookupAttribute[activeAttribute.name];
                            gl.disableVertexAttribArray(attributeIndex);
                            switch (activeAttribute.type) {
                            case 5126:
                                gl.vertexAttrib1f(attributeIndex, 0.0);
                                break;
                            case 35664:
                                gl.vertexAttrib2f(attributeIndex, 0.0, 0.0);
                                break;
                            case 35665:
                                gl.vertexAttrib3f(attributeIndex, 0.0, 0.0, 0.0);
                                break;
                            case 35666:
                                gl.vertexAttrib4f(attributeIndex, 0.0, 0.0, 0.0, 0.0);
                                break;
                            default:
                                Util.fail("Shader wants " + activeAttribute.name + " no default value for type.");
                                break;
                            }
                        }
                    }
                }
            };

        engine.addEventListener('contextLost', contextLost);
        engine.addEventListener('contextRestored', contextRestored);

        Object.defineProperties(this, {
            /**
             * Axis aligned bounding box.
             * Readonly.
             * @property aabb
             * @type kick.math.Aabb
             */
            aabb: {
                get: function () {
                    if (!_aabb && _meshData) {
                        _aabb = _meshData.aabb;
                    }
                    return _aabb;
                }
            },
            /**
             * @property name
             * @type String
             */
            name: {
                get: function () {
                    return _name;
                },
                set: function (newValue) {
                    _name = newValue || "Mesh";
                }
            },
            /**
             * Setting this property to something will update the data in WebGL. Note that
             * changing a MeshData object will not itself update anything.
             * @property meshData
             * @type kick.mesh.MeshData
             */
            meshData: {
                get: function () {
                    return _meshData;
                },
                set: function (newValue) {
                    if (ASSERT) {
                        if (newValue && !(newValue instanceof MeshData)) {
                            Util.fail("Mesh.meshData must be instanceof kick.mesh.MeshData");
                        }
                    }
                    _meshData = newValue;
                    _aabb = null;
                    updateData(true, true, true);
                }
            },
            /**
             * The resource url of the mesh. Setting this property will try to load the meshData.
             * @property dataURI
             * @type String
             */
            dataURI: {
                get: function () {
                    return _dataURI;
                },
                set: function (newValue) {
                    thisObj.setDataURI(newValue, true);
                }
            }
        });

        /**
         * Gives more control over what parts of mesh data is uploaded to the GPU.
         * @example
         *      // Usual use case: Only update vertex data when updating an existing mesh
         *      mesh.setMeshData(meshData, true);
         * @method updateMeshData
         * @param {kick.mesh.MeshData} meshData
         * @param {Boolean} updateVertexData
         * @param {Boolean} updateIndices
         * @param {Boolean} updateVertexStructure
         * @param {Boolean} updateBoundingbox
         */
        this.updateMeshData = function(meshData, updateVertexData, updateIndices, updateVertexStructure, updateBoundingbox){
            if (ASSERT) {
                if (!(meshData instanceof MeshData)) {
                    Util.fail("meshData must be instanceof kick.mesh.MeshData");
                }
            }
            var updateAll = !_meshData; // if no mesh data update all
            _meshData = meshData;
            if (updateBoundingbox) {
                _aabb = null;
            }
            updateData(updateVertexData || updateAll, updateIndices || updateAll, updateVertexStructure || updateAll);
        };

        /**
         * @method setDataURI
         * @param {String} newValue
         * @param {Boolean} automaticGetMeshData optional. if true the mesh data is attempted to be loaded by resourceLoader.getMeshData
         * @param resourceTracker {ResourceTracker} Optional
         */
        this.setDataURI = function (newValue, automaticGetMeshData, resourceTracker) {
            if (newValue !== _dataURI) {
                _dataURI = newValue;
                if (automaticGetMeshData) {
                    engine.resourceLoader.getMeshData(newValue, thisObj, resourceTracker);
                }
            }
        };

        Util.applyConfig(this, config, ["uid"]);


        /**
         * This function verifies that the mesh has the vertex attributes (normals, uvs, tangents) that the shader uses.
         * @method verify
         * @param {kick.material.Shader} shader
         * @return {Array_String} list of missing vertex attributes in mesh or null if no missing attributes
         */
        this.verify = function (shader) {
            var missingVertexAttributes = [],
                found,
                attName;
            for (attName in shader.lookupAttribute) {
                if (typeof (attName) === "string") {
                    found = interleavedArrayFormat[attName];
                    if (!found) {
                        missingVertexAttributes.push(attName);
                    }
                }
            }
            if (missingVertexAttributes.length === 0) {
                return null;
            }
            return null;
        };

        /**
         * Bind the vertex attributes of the mesh to the shader
         * @method bind
         * @param {kick.material.Shader} shader
         */
        this.bind = vertexArrayObjectExtension ?
            function bindUsingVAO(shader) {
                shader.bind();

                if (glState.meshBuffer !== meshVertexAttBuffer || glState.meshShader !== shader) {
                    glState.meshBuffer = meshVertexAttBuffer;
                    glState.meshShader = shader;
                    var vao = vertexArrayObject[shader.uid];
                    if (!vao){
                        vao = vertexArrayObjectExtension.createVertexArrayOES();
                        vertexArrayObjectExtension.bindVertexArrayOES(vao);
                        vertexArrayObject[shader.uid] = vao;
                        bindBuffers(shader);
                    } else {
                        vertexArrayObjectExtension.bindVertexArrayOES(vao);
                    }
                }
            }:
            function bindDefault(shader) {
                shader.bind();

                if (glState.meshBuffer !== meshVertexAttBuffer || glState.meshShader !== shader) {
                    glState.meshBuffer = meshVertexAttBuffer;
                    glState.meshShader = shader;
                    bindBuffers(shader);
                }
            };

        /**
         * Renders the current mesh.
         * Assumes that the Mesh.bind(shader) has been called prior to this, to setup the mesh with the shader.
         * @method render
         * @param {Number} submeshIndex
         */
        this.render = function (submeshIndex) {
            gl.drawElements(meshType, meshElements[submeshIndex], 5123, meshVertexBufferOffsetBytes[submeshIndex]);
        };

        /**
         * Destroys the mesh data and deletes the associated resources
         * After this the mesh cannot be bound
         * @method destroy
         */
        this.destroy = function () {
            if (meshVertexAttBuffer !== null) {
                deleteBuffersAndVertexArrayObjects();
                engine.removeEventListener('contextLost', contextLost);
                engine.removeEventListener('contextRestored', contextRestored);
                engine.project.removeResourceDescriptor(thisObj.uid);
            }

        };

        /**
         * @method toJSON
         * @return {Object} data object
         */
        this.toJSON = function () {
            if (ASSERT) {
                if (!_dataURI) {
                    Util.fail("_dataURI not defined");
                }
            }
            return {
                uid: thisObj.uid,
                name: _name,
                dataURI: _dataURI
            };
        };

        this.init = function(config, resourceTracker){
            Util.applyConfig(this, config, ["uid", "dataURI"]);
            if (config.dataURI){
                thisObj.setDataURI(config.dataURI, true, resourceTracker);
            }
        };
    };
});

define('kick/material/MaterialUniform',["kick/core/Util", "kick/core/Constants", "kick/texture/Texture"], function (Util, Constants, Texture) {
    

    var ASSERT = true;

    /**
     * Material material uniform object
     * @class MaterialUniform
     * @namespace kick.material
     * @constructor
     * @param {Object} configuration
     * @protected
     */
    return function (configuration) {
        var value,
            thisObj = this;
        configuration = configuration || {};
        value = configuration.value;

        /**
         * WebGL Uniform location
         * @property location
         * @type WebGLUniformLocation
         */
        this.location = null;

        /**
         * WebGL type
         * @property type
         * @type Number
         */
        this.type = null;
        /**
         * Name of the Uniform
         * @property name
         * @type String
         */
        this.name = configuration.name;

        Object.defineProperties(this,
            {
                /**
                 * @property value
                 * @type Float32Array|Int32Array|kick.texture.Texture
                 */
                value: {
                    get: function () {
                        return value;
                    },
                    set: function (newValue) {
                        value = newValue;
                    }
                }
            });


        /**
         * Returns a JSON representation of the material<br>
         * @method toJSON
         * @return {string}
         */
        this.toJSON = function () {
            var value = thisObj.value;
            if (value instanceof Float32Array || value instanceof Int32Array) {
                value = Util.typedArrayToArray(value);
            } else {
                if (ASSERT) {
                    if (!value instanceof Texture) {
                        Util.fail("Unknown uniform value type. Expected Texture");
                    }
                }
                value = Util.getJSONReference(value);
            }
            return {
                name: thisObj.name,
                value: value
            };
        };
    };
});

define('kick/material/Material',["kick/core/ProjectAsset", "kick/core/Util", "kick/core/Constants", "./Shader", "./MaterialUniform", "kick/core/EngineSingleton", "kick/core/Observable"],
    function (ProjectAsset, Util, Constants, Shader, MaterialUniform, EngineSingleton, Observable) {
        

        /**
         * @module kick.material
         */
        var ASSERT = true,
            fail = Util.fail;

        /**
         * Material configuration. Stores a material configuration and a shader.
         * @example
         *      var material = new KICK.material.Material({
         *      shader: project.load(project.ENGINE_SHADER_DIFFUSE),
         *          uniformData:{
         *              mainColor:[1.0,0.0,0.9,0.5],
         *              mainTexture: project.load(project.ENGINE_TEXTURE_WHITE)
         *          }
         *      });
         * @class Material
         * @namespace kick.material
         * @constructor
         * @param {Object} config
         * @extends kick.core.ProjectAsset
         */
        return function (config) {
            // extend ProjectAsset
            ProjectAsset(this, config, "kick.material.Material");
            if (ASSERT){
                if (config === EngineSingleton.engine){
                    Util.fail("Material constructor changed - engine parameter is removed");
                }
            }
            var engine = EngineSingleton.engine,
                _name = "Material",
                _shader = null,
                _uniforms = [],
                thisObj = this,
                gl = engine.gl,
                _renderOrder = 0,
                contextRestored= function (newGL) {
                    gl = newGL;
                    // force shader update (will re-initialize uniforms)
                    if (_shader) {
                        _shader.contextRestored(newGL);
                        var s = _shader;
                        _shader = null;
                        thisObj.shader = s;
                    }
                },
                notifyShaderChange = function(){
                    thisObj.fireEvent('shaderChanged', _shader);
                },
                /**
                 * Called when a shader is set or changed.
                 * Add location and type information to each uniform.
                 * Besides it checks that the uniforms exists in the shader
                 * (if not the default uniforms are added).
                 * @method decorateUniforms
                 * @private
                 */
                decorateUniforms = function () {
                    _renderOrder = _shader.renderOrder;
                    notifyShaderChange();
                    var i, uniform,
                        foundUniformNames = {},
                        name,
                        element;
                    for (i = _uniforms.length - 1; i >= 0; i--) {
                        uniform = _shader.lookupUniform[_uniforms[i].name];
                        if (uniform) {
                            _uniforms[i].type = uniform.type;
                            _uniforms[i].location = uniform.location;
                            foundUniformNames[_uniforms[i].name] = true;
                        } else {
                            _uniforms.splice(i, 1); // remove element from array
                        }
                    }
                    // add items not found
                    for (i = 0; i < _shader.materialUniforms.length; i++) {
                        uniform = _shader.materialUniforms[i];
                        name = uniform.name;
                        if (!foundUniformNames.hasOwnProperty(name)) {
                            // add default name
                            element = thisObj.setUniform(name, _shader.defaultUniforms[name]);
                            element.location = uniform.location;
                            element.type = uniform.type;
                        }
                    }
                };

            Observable.call(this, [
            /**
             * Fired when shader is changed (set to a new instance)
             * @event shaderChanged
             * @param {kick.material.Shader} shaderInstance
             */
                "shaderChanged"
            ]
            );

            Object.defineProperties(this, {
                /**
                 * @property engine
                 * @type kick.core.Engine
                 */
                engine: {
                    value: engine
                },
                /**
                 * @property name
                 * @type String
                 */
                name: {
                    get: function () { return _name; },
                    set: function (newValue) { _name = newValue; }
                },
                /**
                 * @property shader
                 * @type kick.material.Shader
                 */
                shader: {
                    get: function () {
                        return _shader;
                    },
                    set: function (newValue) {
                        if (!newValue instanceof Shader) {
                            Util.fail("kick.material.Shader expected");
                        }
                        if (_shader !== newValue) {
                            if (_shader) {
                                _shader.removeEventListener("shaderUpdated", decorateUniforms);
                            }
                            _shader = newValue;
                            if (_shader) {
                                _renderOrder = _shader.renderOrder;
                                decorateUniforms();
                                _shader.addEventListener("shaderUpdated", decorateUniforms);
                            }
                        }
                    }
                },
                /**
                 * Instead call setUniform
                 * @deprecated
                 * @property uniforms
                 * @type Object
                 */
                uniforms: {
                    value: null
                },
                /**
                 * @property renderOrder
                 * @type Number
                 */
                renderOrder: {
                    get: function () {
                        return _renderOrder;
                    }
                }
            });

            /**
             * Listener is notified whenever shader is changed
             * @method addShaderChangeListeners
             * @param {Function} listenerFn
             * @deprecated
             */
            this.addShaderChangeListener = function (listenerFn) {
                if (ASSERT) {
                    if (typeof listenerFn !== "function") {
                        Util.warn("Material.addShaderChangeListener: listenerFn not function");
                    }
                }

                Util.fail("Use addEventListener('shaderChanged', listenerFn) instead");

                thisObj.addEventListener("shaderChanged", listenerFn);
            };

            /**
             * @method removeShaderChangeListener
             * @param {Function} listenerFn
             * @deprecated
             */
            this.removeShaderChangeListener = function (listenerFn) {
                if (ASSERT) {
                    if (typeof listenerFn !== "function") {
                        Util.warn("Material.removeShaderChangeListener: listenerFn not function");
                    }
                }
                Util.fail("Use removeEventListener('shaderChanged', listenerFn) instead");

                thisObj.removeEventListener("shaderChanged", listenerFn);
            };

            /**
             * Bind material uniforms
             * @method bind
             * @param {Number} currentTexture
             * @protected
             * @return {Number}
             */
            this.bind = function (currentTexture) {
                var i,
                    value,
                    location;
                for (i = 0; i < _uniforms.length; i++) {
                    value = _uniforms[i].value;
                    location = _uniforms[i].location;
                    switch (_uniforms[i].type) {
                    case 5126:
                        gl.uniform1fv(location, value);
                        break;
                    case 35674:
                        gl.uniformMatrix2fv(location, false, value);
                        break;
                    case 35675:
                        gl.uniformMatrix3fv(location, false, value);
                        break;
                    case 35676:
                        gl.uniformMatrix4fv(location, false, value);
                        break;
                    case 35664:
                        gl.uniform2fv(location, value);
                        break;
                    case 35665:
                        gl.uniform3fv(location, value);
                        break;
                    case 35666:
                        gl.uniform4fv(location, value);
                        break;
                    case 5124:
                        gl.uniform1iv(location, value);
                        break;
                    case 35667:
                        gl.uniform2iv(location, value);
                        break;
                    case 35668:
                        gl.uniform3iv(location, value);
                        break;
                    case 35669:
                        gl.uniform4iv(location, value);
                        break;
                    case 35680:
                    case 35678:
                        value.bind(currentTexture);
                        gl.uniform1i(location, currentTexture);
                        currentTexture++;
                        break;
                    }
                }
                return currentTexture;
            };

            /**
             * Bind material uniforms. Returns undefined or null if value is undefined or null (or uniform not found)
             * @method setUniform
             * @param {String} name
             * @param {Float32Array|Int32Array|kick.texture.Texture} value
             * @return {kick.material.MaterialUniform}
             */
            this.setUniform = function (name, value) {
                if (value === undefined || value === null) {
                    return null;
                }

                if (ASSERT && typeof value === "number"){
                    fail("setUniform(name,value) expect a value as a Float32Array|Int32Array|kick.texture.Texture - but was a number.");
                }
                var foundElement,
                    i;
                for (i = 0; i < _uniforms.length && !foundElement; i++) {
                    if (_uniforms[i].name === name) {
                        foundElement = _uniforms[i];
                        foundElement.value = value;
                    }
                }

                if (foundElement && _shader) {
                    _shader.markUniformUpdated();
                } else if (!foundElement) {
                    foundElement = new MaterialUniform({
                        name: name,
                        value: value
                    });
                    _uniforms.push(foundElement);
                }
                if (ASSERT) {
                    if (_shader) {
                        if (value === undefined) {
                            Util.fail("Type of value is undefined");
                        }
                    }
                }
                return foundElement;
            };

            /**
             * @method getUniform
             * @param name
             * @return {Float32Array|Int32Array|kick.texture.Texture}
             */
            this.getUniform = function (name) {
                var i;
                for (i = 0; i < _uniforms.length; i++) {
                    if (_uniforms[i].name === name) {
                        return _uniforms[i].value;
                    }
                }
                return null;
            };

            /**
             * @method destroy
             */
            this.destroy = function () {
                thisObj.shader = null;
                engine.project.removeResourceDescriptor(thisObj.uid);
                engine.removeEventListener('contextRestored', contextRestored);
            };

            /**
             * Returns a JSON representation of the material<br>
             * @method toJSON
             * @return {string}
             */
            this.toJSON = function () {
                var i,
                    serializedUniforms = {};
                for (i = 0; i < _uniforms.length; i++) {
                    serializedUniforms[_uniforms[i].name] = _uniforms[i].toJSON().value;
                }
                return {
                    uid: thisObj.uid,
                    name: _name,
                    shader: Util.getJSONReference(_shader),
                    uniformData: serializedUniforms // uniformData only used during serialization
                };
            };

            this.init = function(config) {
                var conf = config || {},
                    uniformData = conf.uniformData,
                    name,
                    value,
                    configCopy = {
                        uid: conf .uid || 0,
                        name: conf.name,
                        shader: conf.shader
                    };
                engine.addEventListener('contextRestored', contextRestored);
                Util.applyConfig(thisObj, configCopy, ["uid"]);
                if (!_shader || !_shader.isValid()) {
                    if (conf.shader) {
                        Util.warn("Problem using shader in material. ", conf.shader);
                    }
                    thisObj.shader = engine.project.load(engine.project.ENGINE_SHADER___ERROR);
                }
                if (uniformData) {
                    for (name in uniformData) {
                        if (uniformData.hasOwnProperty(name)) {
                            if (_shader.lookupUniform[name]) { // if found in shader
                                value = uniformData[name];
                                value = Shader.convertUniformValue(_shader.lookupUniform[name].type, value, engine);
                                thisObj.setUniform(name, value);
                            } else {
                                Util.warn("Cannot find uniform " + name + " in shader. ");
                            }
                        }
                    }
                }
                decorateUniforms();
            };
            this.init(config);
        };

    });

define('kick/core/Project',["./Constants", "./ResourceDescriptor", "kick/material/Shader", "./Util", "kick/texture/Texture", "kick/mesh/Mesh", "kick/material/Material"],
    function (constants, ResourceDescriptor, Shader, Util, Texture, Mesh, Material) {
        

        var ASSERT = true,
            DEBUG = true,
            /**
             * A project is a container of all resources and assets used in a game.
             *
             * When a project is loaded then all it's assets are initialized (except for built-in assets with uid less
             * than 0, which are lazy-loaded).
             *
             * All assets initialized should be registered in the project. This is done by calling Project.registerObject()
             * (Note for built-in kickjs assets, this happens automatically when the objects are constructed).
             * @example
             *      // load shader
             *      var shader = engine.project.load(engine.project.ENGINE_SHADER_DIFFUSE);
             * @class Project
             * @namespace kick.core
             * @constructor
             * @param {kick.core.Engine} engine
             */
            Project = function (engine) {
                var resourceDescriptorsByUID = {},
                    resourceCache = {},
                    thisObj = this,
                    _maxUID = 0,
                    verifyMaxUID = function(){
                        var uid;
                        for (uid in resourceDescriptorsByUID){
                            if (_maxUID < uid){
                                Util.fail("MaxUID invalid");
                            }
                        }
                    },
                    refreshResourceDescriptor = function (uid, filter) {
                        if (resourceDescriptorsByUID[uid] instanceof ResourceDescriptor) {
                            var liveObject = resourceCache[uid];
                            if (liveObject) {
                                resourceDescriptorsByUID[uid].updateConfig(liveObject, filter);
                            }
                        }
                    },
                    getUrlAsResourceName = function (url) {
                        var name = url.split('/');
                        if (name.length > 2) {
                            name = name[name.length - 2];
                            name = name.substring(0, 1).toUpperCase() + name.substring(1);
                        } else {
                            name = url;
                        }
                        return name;
                    },
                    loadEngineAsset = function (uid) {
                        var res,
                            url,
                            isCubemap,
                            canvas,
                            shader,
                            ctx;
                        if (uid <= Project.ENGINE_SHADER_DEFAULT && uid >= Project.ENGINE_SHADER___UNLIT_NO_DEPTH_TEST) {
                            switch (uid) {
                            case Project.ENGINE_SHADER_DEFAULT:
                                url = "kickjs://shader/default/";
                                break;
                            case Project.ENGINE_SHADER_SPECULAR:
                                url = "kickjs://shader/specular/";
                                break;
                            case Project.ENGINE_SHADER_DIFFUSE:
                                url = "kickjs://shader/diffuse/";
                                break;
                            case Project.ENGINE_SHADER_UNLIT:
                                url = "kickjs://shader/unlit/";
                                break;
                            case Project.ENGINE_SHADER___UNLIT_NO_DEPTH_TEST:
                                url = "kickjs://shader/unlit_no_depth/";
                                break;
                            case Project.ENGINE_SHADER_UNLIT_VERTEX_COLOR:
                                url = "kickjs://shader/unlit_vertex_color/";
                                break;
                            case Project.ENGINE_SHADER_TRANSPARENT_SPECULAR:
                                url = "kickjs://shader/transparent_specular/";
                                break;
                            case Project.ENGINE_SHADER_TRANSPARENT_DIFFUSE:
                                url = "kickjs://shader/transparent_diffuse/";
                                break;
                            case Project.ENGINE_SHADER_TRANSPARENT_UNLIT:
                                url = "kickjs://shader/transparent_unlit/";
                                break;
                            case Project.ENGINE_SHADER___SHADOWMAP:
                                url = "kickjs://shader/__shadowmap/";
                                break;
                            case Project.ENGINE_SHADER___PICK_UV:
                                url = "kickjs://shader/__pick_uv/";
                                break;
                            case Project.ENGINE_SHADER___PICK_NORMAL:
                                url = "kickjs://shader/__pick_normal/";
                                break;
                            case Project.ENGINE_SHADER___PICK:
                                url = "kickjs://shader/__pick/";
                                break;
                            case Project.ENGINE_SHADER___ERROR:
                                url = "kickjs://shader/__error/";
                                break;
                            case Project.ENGINE_SHADER_TRANSPARENT_POINT_SPRITE:
                                url = "kickjs://shader/transparent_point_sprite/";
                                break;
                            case Project.ENGINE_SHADER_BUMPED_SPECULAR:
                                url = "kickjs://shader/bumped_specular/";
                                break;
                            case Project.ENGINE_SHADER_SKYBOX:
                                url = "kickjs://shader/skybox/";
                                break;
                            case Project.ENGINE_SHADER_PARTICLES:
                                url = "kickjs://shader/particles/";
                                break;
                            default:
                                if (ASSERT) {
                                    Util.fail("uid not mapped " + uid);
                                }
                                return null;
                            }
                            res = new Shader({
                                dataURI: url,
                                name: getUrlAsResourceName(url),
                                uid: uid
                            });
                        } else if (uid <= Project.ENGINE_TEXTURE_BLACK && uid >= Project.ENGINE_TEXTURE_DEFAULT_NORMAL) {
                            isCubemap = uid === Project.ENGINE_TEXTURE_CUBEMAP_WHITE;
                            switch (uid) {
                            case Project.ENGINE_TEXTURE_BLACK:
                                url = "kickjs://texture/black/";
                                break;
                            case Project.ENGINE_TEXTURE_WHITE:
                                url = "kickjs://texture/white/";
                                break;
                            case Project.ENGINE_TEXTURE_GRAY:
                                url = "kickjs://texture/gray/";
                                break;
                            case Project.ENGINE_TEXTURE_LOGO:
                                url = "kickjs://texture/logo/";
                                break;
                            case Project.ENGINE_TEXTURE_CUBEMAP_WHITE:
                                // do nothing
                                break;
                            case Project.ENGINE_TEXTURE_DEFAULT_NORMAL:
                                url = "kickjs://texture/default_normal/";
                                break;
                            default:
                                if (ASSERT) {
                                    Util.fail("uid not mapped " + uid);
                                }
                                return null;
                            }
                            if (isCubemap) {
                                res = new Texture(
                                    {
                                        name: "cubemap_white",
                                        minFilter: 9728,
                                        magFilter: 9728,
                                        generateMipmaps: false,
                                        uid: uid,
                                        textureType: 34067
                                    });

                                // create white image
                                canvas = document.createElement("canvas");
                                canvas.width = 12;
                                canvas.height = 2;
                                ctx = canvas.getContext("2d");

                                ctx.fillStyle = "rgb(255,255,255)";
                                ctx.fillRect(0, 0, 12, 2);
                                res.setImage(canvas, "memory://cubemap_white/");

                            } else {
                                res = new Texture(
                                    {
                                        name: getUrlAsResourceName(url),
                                        minFilter: 9728,
                                        magFilter: 9728,
                                        generateMipmaps: false,
                                        uid: uid,
                                        textureType: 3553,
                                        dataURI: url
                                    });
                            }

                        } else if (uid <= Project.ENGINE_MESH_TRIANGLE && uid >= Project.ENGINE_MESH_POINT) {
                            switch (uid) {
                            case Project.ENGINE_MESH_TRIANGLE:
                                url = "kickjs://mesh/triangle/";
                                break;
                            case Project.ENGINE_MESH_PLANE:
                                url = "kickjs://mesh/plane/";
                                break;
                            case Project.ENGINE_MESH_UVSPHERE:
                                url = "kickjs://mesh/uvsphere/";
                                break;
                            case Project.ENGINE_MESH_CUBE:
                                url = "kickjs://mesh/cube/";
                                break;
                            case Project.ENGINE_MESH_POINT:
                                url = "kickjs://mesh/point/";
                                break;
                            default:
                                if (ASSERT) {
                                    Util.fail("uid not mapped " + uid);
                                }
                                return null;
                            }
                            res = new Mesh(
                                {
                                    dataURI: url,
                                    name: getUrlAsResourceName(url),
                                    uid: uid
                                });
                        } else if (uid <= Project.ENGINE_MATERIAL_DEFAULT) {
                            shader = loadEngineAsset(Project.ENGINE_SHADER_UNLIT);
                            res = new Material({
                                shader: shader,
                                name: "Default material"
                            });
                        }

                        resourceCache[uid] = res;
                        return res;
                    };

                Util.copyStaticPropertiesToObject(thisObj, Project);


                Object.defineProperties(this, {
                    /**
                     * The maximum UID used in the project
                     * @property maxUID
                     * @type Number
                     */
                    maxUID: {
                        get: function () {
                            return _maxUID;
                        },
                        set: function (newValue) {
                            _maxUID = newValue;
                            if (ASSERT){
                                verifyMaxUID();
                            }
                        }
                    },
                    /**
                     * List the asset uids of project
                     * @property resourceDescriptorUIDs
                     * @type Array_Number
                     */
                    resourceDescriptorUIDs: {
                        get: function () {
                            var uids = [],
                                uid;
                            for (uid in resourceDescriptorsByUID) {
                                if (resourceDescriptorsByUID.hasOwnProperty(uid)) {
                                    uids.push(uid);
                                }
                            }
                            return uids;
                        }
                    }
                });

                /**
                 * Creates a new empty project.
                 * @method newProject
                 */
                this.newProject = function () {
                    thisObj.loadProject({maxUID: 0, resourceDescriptors: []});
                };

                /**
                 * Loads a project by URL. This call is asynchronous, and onSuccess or onFail will be called when the loading is
                 * complete.
                 * @method loadProjectByURL
                 * @param {String} url
                 * @param {Function} onSuccess
                 * @param {Function} onFail
                 */
                this.loadProjectByURL = function (url, onSuccess, onError) {
                    var voidFunction = function () {
                            if (DEBUG) {
                                console.log(arguments);
                            }
                        },
                        oXHR;
                    onSuccess = onSuccess || voidFunction;
                    onError = onError || voidFunction;

                    oXHR = new XMLHttpRequest();
                    oXHR.open("GET", url, true);
                    oXHR.onreadystatechange = function (oEvent) {
                        if (oXHR.readyState === 4) {
                            if (oXHR.status === 200) {
                                var value = JSON.parse(oXHR.responseText);
                                try {
                                    thisObj.loadProject(value, onSuccess, onError);
                                } catch (e) {
                                    onError(e);
                                }
                            } else {
                                onError();
                            }
                        }
                    };
                    oXHR.send(null);
                };

                /**
                 * Load a project of the form {maxUID:number,resourceDescriptors:[kick.core.ResourceDescriptor],activeScene:number}
                 * @method loadProject
                 * @param {object} config
                 * @param {Function} onSuccess
                 * @param {Function} [onFail=null]
                 */
                this.loadProject = function (config, onSuccess, onError) {
                    if (_maxUID > 0) {
                        thisObj.closeProject();
                    }
                    if (typeof onSuccess !== "function" && ASSERT){
                        Util.fail("Project.loadProject - onSuccess parameter not a function");
                    }
                    config = config || {};
                    var resourceDescriptors = config.resourceDescriptors || [],
                        i,
                        uid,
                        createConfigInitialized = function (config) {
                            var res = {},
                                name,
                                value,
                                reftype,
                                ref;
                            for (name in config) {
                                if (Util.hasProperty(config, name)) {
                                    value = config[name];
                                    reftype = value ? value.reftype : null;
                                    ref = value ? value.ref : null;
                                    if (value && ref && reftype) {
                                        if (reftype === "resource") {
                                            value = engine.resourceLoader[value.refMethod](ref);
                                        } else if (reftype === "project") {
                                            value = engine.project.load(ref);
                                        }
                                    }
                                    res[name] = value;
                                }
                            }
                            return res;
                        },
                        onComplete = function () {
                            var initCount = 1,
                                decrementInitCount = function (url) {
                                    initCount--;
                                    if (initCount === 0) {
                                        _maxUID = config.maxUID || 0; // reset maxUID
                                        if (config.activeScene) {
                                            engine.activeScene = thisObj.load(config.activeScene);
                                        } else {
                                            engine.activeScene = null;
                                        }
                                        if (onSuccess) {
                                            onSuccess(thisObj);
                                        }
                                    }
                                },
                                resourceTracker = {
                                    resourceLoadingStarted: function () {
                                        initCount++;
                                    },
                                    resourceLoadingFinished: decrementInitCount,
                                    resourceLoadingFailed: onError
                                };
                            // instantiate config
                            for (uid in resourceDescriptorsByUID) {
                                if (resourceDescriptorsByUID.hasOwnProperty(uid)) {
                                    resourceCache[uid].init(createConfigInitialized(resourceDescriptorsByUID[uid].config), resourceTracker);
                                }
                            }
                            decrementInitCount();

                        },
                        resourceCount = resourceDescriptors.length,
                        instantiateCount = 0,
                        instantiateSuccess = function (object) {
                            if (resourceCache[object.uid] !== object) {
                                onError("Did not restore uid correct for " + object.uid + ".");
                                return;
                            }

                            instantiateCount++;
                            if (instantiateCount === resourceCount){
                                onComplete();
                            }
                        };
                    _maxUID = config.maxUID || 0;
                    for (i = 0; i < resourceCount; i++) {
                        thisObj.addResourceDescriptor(resourceDescriptors[i]);
                    }

                    // preload all resources

                    for (uid in resourceDescriptorsByUID) {
                        if (resourceDescriptorsByUID.hasOwnProperty(uid)) {
                            resourceDescriptorsByUID[uid].instantiate(instantiateSuccess, onError);
                        }
                    }
                };

                /**
                 * Close all resources in the project and remove all resource descriptors
                 * @method closeProject
                 */
                this.closeProject = function () {
                    var uid;
                    for (uid in resourceDescriptorsByUID) {
                        if (resourceDescriptorsByUID.hasOwnProperty(uid)) {
                            thisObj.removeResourceDescriptor(uid);
                        }
                    }
                    resourceDescriptorsByUID = {};
                    resourceCache = {};
                };

                /**
                 * Load a resource from the project.
                 * @method load
                 * @param {String} uid
                 */
                this.load = function (uid, callback, onError) {
                    var resourceObject = resourceCache[uid];
                    if (resourceObject) {
                        return resourceObject;
                    }

                    return loadEngineAsset(uid);
                };

                /**
                 * Remove cache references to an object. Next time load(uid) is called a new object is
                 * initialized from the resource config
                 * @method removeCacheReference
                 * @param {Number} uid
                 */
                this.removeCacheReference = function (uid) {
                    if (resourceCache[uid]) {
                        delete resourceCache[uid];
                    }
                };

                /**
                 * Load a resource from the configuration (or cache).
                 * Also increases the resource reference counter.
                 * If more objects exist with the same name, the first object is returned
                 * @method loadByName
                 * @param {String} name
                 * @param {String} type=null limit the search to a specific type
                 * @return {kick.core.ProjectAsset} resource or null if resource is not found
                 */
                this.loadByName = function (name, type) {
                    var uid,
                        resource;
                    for (uid in resourceDescriptorsByUID) {
                        if (resourceDescriptorsByUID.hasOwnProperty(uid)) {
                            resource = resourceDescriptorsByUID[uid];
                            if (resource.name === name) {
                                if (!type || resource.type === type) {
                                    return thisObj.load(resource.uid);
                                }
                            }
                        }
                    }
                    if (ASSERT){
                        verifyMaxUID();
                    }
                    return null;
                };

                /**
                 * Registers an asset in a Project.
                 * @method registerObject
                 * @param {Object} object
                 * @param {String} type
                 */
                this.registerObject = function (object, type) {
                    var uid = engine.getUID(object);
                    if (resourceCache[uid]) {
                        if (true) {
                            Util.warn("Object already registered ", uid, object);
                        }
                        return;
                    }
                    resourceCache[uid] = object;
                    if (!resourceDescriptorsByUID[uid]) { // only update if new object
                        resourceDescriptorsByUID[uid] = new ResourceDescriptor({
                            uid: uid,
                            type: type,
                            config: {name: object.name} // will be generated on serialization
                        });
                    }
                    if (ASSERT){
                        verifyMaxUID();
                    }
                };

                /**
                 * Updates the resourceDescriptors with data from the initialized objects
                 * @method refreshResourceDescriptors
                 * @param {Function} filter=null Filter with function(object): return boolean, where true means include in export.
                 */
                this.refreshResourceDescriptors = function (filter) {
                    var uid;
                    filter = filter || function () { return true; };
                    for (uid in resourceDescriptorsByUID) {
                        if (resourceDescriptorsByUID.hasOwnProperty(uid)) {
                            refreshResourceDescriptor(uid, filter);
                        }
                    }
                    if (ASSERT){
                        verifyMaxUID();
                    }
                };

                /**
                 * Returns the buildin engine resources
                 * @method getEngineResourceDescriptorsByType
                 * @param {String} type
                 * @return {Array_kick.core.ResourceDescriptor}
                 */
                this.getEngineResourceDescriptorsByType = function (type) {
                    var res = [],
                        searchFor,
                        name,
                        uid;
                    if (type === "kick.mesh.Mesh") {
                        searchFor = "ENGINE_MESH_";
                    } else if (type === "kick.material.Shader") {
                        searchFor = "ENGINE_SHADER_";
                    } else if (type === "kick.texture.Texture") {
                        searchFor = "ENGINE_TEXTURE_";
                    }
                    if (searchFor) {
                        for (name in Project) {
                            if (typeof Project[name] === "number" && Project.hasOwnProperty(name) && name.indexOf(searchFor) === 0) {
                                uid = Project[name];
                                name = Util.toCamelCase(name.substr(searchFor.length), " ");
                                res.push(new ResourceDescriptor({
                                    type: type,
                                    config: {
                                        name: name,
                                        uid: uid
                                    }
                                }));
                            }
                        }
                    }
                    return res;
                };

                /**
                 * @method getResourceDescriptorsByType
                 * @param {String} type
                 * @return {Array_kick.core.ResourceDescriptor}
                 */
                this.getResourceDescriptorsByType = function (type) {
                    var res = [],
                        uid;
                    for (uid in resourceDescriptorsByUID) {
                        if (resourceDescriptorsByUID.hasOwnProperty(uid) && resourceDescriptorsByUID[uid].type === type) {
                            res.push(resourceDescriptorsByUID[uid]);
                        }
                    }
                    return res;
                };

                /**
                 * @method getResourceDescriptorsByName
                 * @param {String} name
                 * @return {Array_kick.core.ResourceDescriptor}
                 */
                this.getResourceDescriptorsByName = function (name) {
                    var res = [],
                        uid;
                    for (uid in resourceDescriptorsByUID) {
                        if (resourceDescriptorsByUID.hasOwnProperty(uid) && resourceDescriptorsByUID[uid].name === name) {
                            res.push(resourceDescriptorsByUID[uid]);
                        }
                    }
                    return res;
                };



                /**
                 * @method getResourceDescriptor
                 * @param {Number} uid
                 * @return {kick.core.ResourceDescriptor} resource descriptor (or null if not found)
                 */
                this.getResourceDescriptor = function (uid) {
                    refreshResourceDescriptor(uid);
                    return resourceDescriptorsByUID[uid];
                };

                /**
                 * @method addResourceDescriptor
                 * @param {kick.core.ResourceDescriptor|Object} resourceDescriptor
                 * @return {kick.core.ResourceDescriptor}
                 */
                this.addResourceDescriptor = function (resourceDescriptor) {
                    if (!(resourceDescriptor instanceof ResourceDescriptor)) {
                        resourceDescriptor = new ResourceDescriptor(resourceDescriptor);
                    }

                    resourceDescriptorsByUID[resourceDescriptor.uid] = resourceDescriptor;
                    return resourceDescriptor;
                };

                /**
                 * Remove resource descriptor and destroy the resource if already allocated.
                 * @method removeResourceDescriptor
                 * @param {Number} uid
                 */
                this.removeResourceDescriptor = function (uid) {
                    // destroy the resource
                    var resource = resourceCache[uid];
                    if (resource) {
                        // remove references
                        delete resourceCache[uid];
                        // call destroy if exist
                        if (resource.destroy) {
                            resource.destroy();
                        }
                    }
                    // remove description
                    delete resourceDescriptorsByUID[uid];
                };

                /**
                 * @method toJSON
                 * @param {Function} filter=null Filter with function(object): return boolean, where true means include in export.
                 * @return Object
                 */
                this.toJSON = function (filter) {
                    var res = [],
                        uid,
                        resourceDescriptor;
                    filter = filter || function () { return true; };
                    thisObj.refreshResourceDescriptors(filter);
                    for (uid in resourceDescriptorsByUID) {
                        if (resourceDescriptorsByUID.hasOwnProperty(uid) && uid >= 0) { // don't serialize engine assets (since they are static)
                            resourceDescriptor = resourceDescriptorsByUID[uid];
                            if (resourceDescriptor instanceof ResourceDescriptor && filter(resourceDescriptor)) {
                                res.push(resourceDescriptor.toJSON(filter));
                            }
                        }
                    }
                    return {
                        engineVersion: engine.version,
                        maxUID: _maxUID,
                        activeScene: engine.activeScene ? engine.activeScene.uid : 0,
                        resourceDescriptors: res
                    };
                };
            };

        /**
         * @property ENGINE_SHADER_DEFAULT
         * @type Number
         * @static
         */
        Project.ENGINE_SHADER_DEFAULT = -100;
        /**
         * @property ENGINE_SHADER_SPECULAR
         * @type Number
         * @static
         */
        Project.ENGINE_SHADER_SPECULAR = -101;
        /**
         * @property ENGINE_SHADER_UNLIT
         * @type Number
         * @static
         */
        Project.ENGINE_SHADER_UNLIT = -102;
        /**
         * @property ENGINE_SHADER_TRANSPARENT_SPECULAR
         * @type Number
         * @static
         */
        Project.ENGINE_SHADER_TRANSPARENT_SPECULAR = -103;
        /**
         * @property ENGINE_SHADER_TRANSPARENT_UNLIT
         * @type Number
         * @static
         */
        Project.ENGINE_SHADER_TRANSPARENT_UNLIT = -104;
        /**
         * @property ENGINE_SHADER___SHADOWMAP
         * @type Number
         * @static
         */
        Project.ENGINE_SHADER___SHADOWMAP = -105;
        /**
         * @property ENGINE_SHADER___PICK
         * @type Number
         * @static
         */
        Project.ENGINE_SHADER___PICK = -106;
        /**
         * @property ENGINE_SHADER___ERROR
         * @type Number
         * @static
         * @protected
         */
        Project.ENGINE_SHADER___ERROR = -107;
        /**
         * @property ENGINE_SHADER_DIFFUSE
         * @type Number
         * @static
         */
        Project.ENGINE_SHADER_DIFFUSE = -108;
        /**
         * @property ENGINE_SHADER_TRANSPARENT_DIFFUSE
         * @type Number
         * @static
         */
        Project.ENGINE_SHADER_TRANSPARENT_DIFFUSE = -109;
        /**
         * @property ENGINE_SHADER_UNLIT_VERTEX_COLOR
         * @type Number
         * @static
         */
        Project.ENGINE_SHADER_UNLIT_VERTEX_COLOR = -110;
        /**
         * @property ENGINE_SHADER___PICK_UV
         * @type Number
         * @static
         * @protected
         */
        Project.ENGINE_SHADER___PICK_UV = -111;
        /**
         * @property ENGINE_SHADER___PICK_NORMAL
         * @type Number
         * @static
         * @protected
         */
        Project.ENGINE_SHADER___PICK_NORMAL = -112;
        /**
         * @property ENGINE_SHADER_TRANSPARENT_POINT_SPRITE
         * @type Number
         * @static
         */
        Project.ENGINE_SHADER_TRANSPARENT_POINT_SPRITE = -113;
        /**
         * @property ENGINE_SHADER_BUMPED_SPECULAR
         * @type Number
         * @static
         */
        Project.ENGINE_SHADER_BUMPED_SPECULAR = -114;
        /**
         * @property ENGINE_SHADER_SKYBOX
         * @type Number
         * @static
         */
        Project.ENGINE_SHADER_SKYBOX = -115;
        /**
         * @property ENGINE_SHADER_PARTICLES
         * @type Number
         * @static
         */
        Project.ENGINE_SHADER_PARTICLES = -116;
        /**
         * @property ENGINE_SHADER___UNLIT_NO_DEPTH_TEST
         * @type Number
         * @static
         * @protected
         */
        Project.ENGINE_SHADER___UNLIT_NO_DEPTH_TEST = -117;
        /**
         * @property ENGINE_TEXTURE_BLACK
         * @type Number
         * @static
         */
        Project.ENGINE_TEXTURE_BLACK = -200;
        /**
         * @property ENGINE_TEXTURE_WHITE
         * @type Number
         * @static
         */
        Project.ENGINE_TEXTURE_WHITE = -201;
        /**
         * @property ENGINE_TEXTURE_GRAY
         * @type Number
         * @static
         */
        Project.ENGINE_TEXTURE_GRAY = -202;

        /**
         * @property ENGINE_TEXTURE_LOGO
         * @type Number
         * @static
         */
        Project.ENGINE_TEXTURE_LOGO = -203;

        /**
         * @property ENGINE_TEXTURE_CUBEMAP_WHITE
         * @type Number
         * @static
         */
        Project.ENGINE_TEXTURE_CUBEMAP_WHITE = -204;

        /**
         * @property ENGINE_TEXTURE_DEFAULT_NORMAL
         * @type Number
         * @static
         */
        Project.ENGINE_TEXTURE_DEFAULT_NORMAL = -205;

        /**
         * @property ENGINE_MESH_TRIANGLE
         * @type Number
         * @static
         */
        Project.ENGINE_MESH_TRIANGLE = -300;

        /**
         * @property ENGINE_MESH_PLANE
         * @type Number
         * @static
         */
        Project.ENGINE_MESH_PLANE = -301;

        /**
         * @property ENGINE_MESH_UVSPHERE
         * @type Number
         * @static
         */
        Project.ENGINE_MESH_UVSPHERE = -302;

        /**
         * @property ENGINE_MESH_CUBE
         * @type Number
         * @static
         */
        Project.ENGINE_MESH_CUBE = -303;

        /**
         * @property ENGINE_MESH_CUBE
         * @type Number
         * @static
         */
        Project.ENGINE_MESH_POINT = -304;

        /**
         * Default material is using ENGINE\_SHADER\_UNLIT and is white
         * @property ENGINE_MATERIAL_DEFAULT
         * @type {Number}
         * @static
         */
        Project.ENGINE_MATERIAL_DEFAULT = -400;


        return Project;
    });

define('kick/core/URLResourceProvider',["kick/mesh/MeshData", "./Util"], function (MeshData, Util) {
    

    /**
     * Fall back handler of resources
     * @class URLResourceProvider
     * @namespace kick.core
     * @constructor
     * @extends kick.core.ResourceProvider
     * @param {kick.core.Engine} engine
     * @private
     */
    return function (engine) {
        var gl = engine.gl,
            thisObj = this;
        Object.defineProperties(this, {
            /**
             * Returns empty string (match all)
             * @property protocol
             * @type String
             */
            protocol: {
                value: ""
            }
        });

        this.getMeshData = function (url, meshDestination, resourceTracker) {
            var oReq = new XMLHttpRequest();
            if (resourceTracker && resourceTracker.resourceLoadingStarted){
                resourceTracker.resourceLoadingStarted(url, meshDestination);
            }
            function handler() {
                if (oReq.readyState === 4) { // oReq.readyState  === complete
                    if (oReq.status === 200) { // oReq.status === ok
                        var arrayBuffer = oReq.response,
                            meshData = new MeshData();
                        if (meshData.deserialize(arrayBuffer)) {
                            meshDestination.meshData = meshData;
                            if (resourceTracker && resourceTracker.resourceLoadingStarted){
                                resourceTracker.resourceLoadingFinished(url, meshDestination);
                            }
                        } else {
                            Util.fail("Cannot deserialize meshdata " + url);
                            if (resourceTracker && resourceTracker.resourceLoadingFailed){
                                resourceTracker.resourceLoadingFailed(url, meshDestination);
                            }
                        }
                    } else {
                        Util.fail("Cannot load meshdata " + url + ". Server responded " + oReq.status);
                        if (resourceTracker && resourceTracker.resourceLoadingFailed){
                            resourceTracker.resourceLoadingFailed(url, meshDestination);
                        }
                    }
                }
            }

            oReq.open("GET", url, true);
            oReq.responseType = "arraybuffer";
            oReq.onreadystatechange = handler;
            oReq.send();
        };

        this.getImageData = function (uri, textureDestination, resourceTracker) {
            var img = new Image();
            if (resourceTracker && resourceTracker.resourceLoadingStarted){
                resourceTracker.resourceLoadingStarted(url, textureDestination);
            }
            img.onload = function () {
                try {
                    textureDestination.setImage(img, uri);
                    if (resourceTracker && resourceTracker.resourceLoadingStarted){
                        resourceTracker.resourceLoadingFinished(url, textureDestination);
                    }
                } catch (e) {
                    Util.fail("Exception when loading image " + uri);
                    if (resourceTracker && resourceTracker.resourceLoadingFailed){
                        resourceTracker.resourceLoadingFailed(url, textureDestination);
                    }
                }
            };
            img.onerror = function (e) {
                Util.fail(e);
                Util.fail("Exception when loading image " + uri);
                if (resourceTracker && resourceTracker.resourceLoadingFailed){
                    resourceTracker.resourceLoadingFailed(url, textureDestination);
                }
            };
            if (uri.indexOf('data:') !== 0) {
                img.crossOrigin = "anonymous"; // Ask for a CORS image except when using data
            }
            img.src = uri;
        };
    };

});

define('kick/core/ResourceLoader',["./URLResourceProvider", "./BuiltInResourceProvider"], function (URLResourceProvider, BuiltInResourceProvider) {
    

    /**
     * Responsible for loading of resources. Use the Engine object to obtain a reference to this object.
     * @class ResourceLoader
     * @namespace kick.core
     * @constructor
     */
    return function (engine) {
        var resourceProviders =
                [
                    new URLResourceProvider(engine),
                    new BuiltInResourceProvider(engine)
                ],
            /**
             * Create a callback function
             * @method buildCallbackFunc
             * @private
             */
            buildCallbackFunc = function (methodName) {
                return function (url, destination, resourceTracker) {
                    var i,
                        resourceProvider,
                        protocol;
                    for (i = resourceProviders.length - 1; i >= 0; i--) {
                        resourceProvider = resourceProviders[i];
                        protocol = resourceProvider.protocol;
                        if (url.indexOf(protocol) === 0) {
                            resourceProvider[methodName](url, destination, resourceTracker);
                            return;
                        }
                    }
                };
            };
        /**
         * @method getMeshData
         * @param {String} uri
         * @param {kick.mesh.Mesh} meshDestination
         * @param {ResourceTracker} [resourceTracker]
         */
        this.getMeshData = buildCallbackFunc("getMeshData");
        /**
         * @method getImageData
         * @param {String} uri
         * @param {kick.texture.Texture} textureDestination
         */
        this.getImageData = buildCallbackFunc("getImageData");

        /**
         * @method getShaderData
         * @param {String} uri
         * @param {kick.material.Shader} shaderDestination
         */
        this.getShaderData = buildCallbackFunc("getShaderData");

        /**
         * @method addResourceProvider
         * @param {kick.resource.ResourceProvider}resourceProvider
         */
        this.addResourceProvider = function (resourceProvider) {
            resourceProviders.push(resourceProvider);
        };

        /**
         * @method removeResourceProvider
         * @param {kick.resource.ResourceProvider}resourceProvider
         */
        this.removeResourceProvider = function (resourceProvider) {
            var i;
            for (i = resourceProvider.length - 1; i >= 0; i--) {
                if (resourceProviders[i] === resourceProvider) {
                    resourceProviders.splice(i, 1);
                }
            }
        };
    };

});

define('kick/core/MouseInput',["kick/math/Vec2", "./Util"], function (Vec2, Util) {
    

    /**
     * Provides an easy-to-use mouse input interface.
     * Example:<br>
     * @example
     *     function SimpleMouseComponent(){
     *         var mouseInput,
     *         thisObj = this;
     *         this.activated = function(){
     *             mouseInput = kick.core.Engine.instance.mouseInput;
     *         };
     *         this.update = function(){
     *             if (mouseInput.isButtonDown(0)){
     *                 var str = "Left mouse down at position "+mouseInput.mousePosition[0]+","+mouseInput.mousePosition[1];
     *                 console.log(str);
     *             }
     *         }
     *     }
     * @constructor
     * @class MouseInput
     * @namespace kick.core
     */
    return function (engine) {
        var vec2 = Vec2,
            mouse = [],
            mouseUp = [],
            mouseDown = [],
            mousePosition = vec2.create(),
            lastMousePosition = vec2.create(),
            deltaMovement = null,
            objectPosition = vec2.create(),
            mouseWheelDelta = vec2.create(),
            mouseWheelPreventDefaultAction = false,
            canvas = engine.canvas,
            devicePixelRatio = engine.config.highDPISupport ? (window.devicePixelRatio || 1) : 1,
            removeElementFromArray = Util.removeElementFromArray,
            contains = Util.contains,
            mouseMovementListening = true,
            releaseMouseButtonOnMouseOut = true,
            body = document.body,
            isFirefox = navigator.userAgent.indexOf("Firefox") !== -1,
            isChrome = navigator.userAgent.indexOf("Chrome") !== -1,
            mouseContextMenuHandler = function (e) {
                e.preventDefault();
                return false;
            },
            mouseMovementHandler = function (e) {
                mousePosition[0] = (e.clientX - objectPosition[0] + body.scrollLeft) * devicePixelRatio;
                mousePosition[1] = (e.clientY - objectPosition[1] + body.scrollTop) * devicePixelRatio;
                if (deltaMovement) {
                    vec2.subtract(deltaMovement, mousePosition, lastMousePosition);
                } else {
                    deltaMovement = vec2.create();
                }
                vec2.copy(lastMousePosition, mousePosition);
            },
            mouseWheelHandler = function (e) {
                if (isChrome) {
                    mouseWheelDelta[0] += e.wheelDeltaX;
                    mouseWheelDelta[1] += e.wheelDeltaY;
                } else {
                    if (e.axis === 1) { // horizontal
                        mouseWheelDelta[0] -= e.detail;
                    } else {
                        mouseWheelDelta[1] -= e.detail;
                    }
                }
                if (mouseWheelPreventDefaultAction) {
                    e.preventDefault();
                    return false;
                }
                return true;
            },
            mouseDownHandler = function (e) {
                var mouseButton = e.button;
                if (!contains(mouse, mouseButton)) {
                    mouseDown.push(mouseButton);
                    mouse.push(mouseButton);
                }
                if (!mouseMovementListening) {  // also update mouse position if not listening for mouse movement
                    mouseMovementHandler();
                }
            },
            mouseUpHandler = function (e) {
                var mouseButton = e.button;
                mouseUp.push(mouseButton);
                removeElementFromArray(mouse, mouseButton);
                if (!mouseMovementListening) { // also update mouse position if not listening for mouse movement
                    mouseMovementHandler();
                }
            },
            mouseOutHandler = function () {
                var i;
                if (releaseMouseButtonOnMouseOut) {
                    // simulate mouse up events
                    for (i = mouse.length - 1; i >= 0; i--) {
                        mouseUpHandler({button: mouse[i]});
                    }
                }
            },
            /**
             * Calculates an object with the x and y coordinates of the given object.
             * Updates the objectPosition variable
             * @method updateCanvasElementPositionPrivate
             * @private
             */
            updateCanvasElementPositionPrivate = function () {
                var object = canvas,
                    left = 0,
                    top = 0;

                while (object.offsetParent) {
                    left += object.offsetLeft;
                    top += object.offsetTop;
                    object = object.offsetParent;
                }

                left += object.offsetLeft;
                top += object.offsetTop;

                objectPosition[0] = left;
                objectPosition[1] = top;
            };
        Object.defineProperties(this, {
            /**
             * Returns the mouse position of the canvas element, where 0,0 is in the upper left corner.
             * @property mousePosition
             * @type kick.math.Vec2
             */
            mousePosition: {
                get: function () {
                    return mousePosition;
                }
            },
            /**
             * Returns the delta movement (relative mouse movement since last frame)
             * @property deltaMovement
             * @type kick.math.Vec2
             */
            deltaMovement: {
                get: function () {
                    return deltaMovement || vec2.create();
                }
            },
            /**
             * Mouse scroll wheel input in two dimensions (horizontal and vertical)
             * @property deltaWheel
             * @type kick.math.Vec2
             */
            deltaWheel: {
                get: function () {
                    return mouseWheelDelta;
                }
            },
            /**
             * If set to true, the engine will prevent screen from scrolling when mouse wheel is used when mouse pointer
             * is over the canvas.<br>
             * Default value is false
             * @property mouseWheelPreventDefaultAction
             * @type Boolean
             */
            mouseWheelPreventDefaultAction: {
                get: function () {
                    return mouseWheelPreventDefaultAction;
                },
                set: function (newValue) {
                    mouseWheelPreventDefaultAction = newValue;
                }
            },
            /**
             * When true mouse buttons are auto released when mouse moves outside the canvas.
             * If this is not true, then mouse up events may not be detected. This is important
             * when listening for mouse drag events.
             * Default true
             * @property releaseMouseButtonOnMouseOut
             * @type Boolean
             */
            releaseMouseButtonOnMouseOut: {
                get: function () {
                    return releaseMouseButtonOnMouseOut;
                },
                set: function (newValue) {
                    if (newValue !== releaseMouseButtonOnMouseOut) {
                        releaseMouseButtonOnMouseOut = newValue;
                        if (releaseMouseButtonOnMouseOut) {
                            canvas.addEventListener("mouseout", mouseOutHandler, false);
                        } else {
                            canvas.removeEventListener("mouseout", mouseOutHandler, false);
                        }
                    }
                }
            },
            /**
             * Default value is true
             * @property mouseMovementEventsEnabled
             * @type Boolean
             */
            mouseMovementEventsEnabled: {
                get: function () { return mouseMovementListening; },
                set: function (value) {
                    if (mouseMovementListening !== value) {
                        mouseMovementListening = value;
                        if (mouseMovementListening) {
                            canvas.addEventListener("mousemove", mouseMovementHandler, false);
                        } else {
                            canvas.removeEventListener("mousemove", mouseMovementHandler, false);
                            deltaMovement = null;
                        }
                    }
                }
            }
        });

        /**
         * @method isButtonDown
         * @param {Number} mouseButton
         * @return {boolean} true if mouse button is pressed down in this frame
         */
        this.isButtonDown = function (mouseButton) {
            return contains(mouseDown, mouseButton);
        };

        /**
         * @method isButtonUp
         * @param {Number} mouseButton
         * @return {boolean} true if mouseButton is released in this frame
         */
        this.isButtonUp = function (mouseButton) {
            return contains(mouseUp, mouseButton);
        };

        /**
         * @method isButton
         * @param {Number} mouseButton
         * @return {boolean} true if mouseButton is down
         */
        this.isButton = function (mouseButton) {
            return contains(mouse, mouseButton);
        };

        /**
         * Resets the mouse position each frame (mouse buttons down and delta values)
         * @method frameUpdated
         * @private
         */
        this.frameUpdated = function () {
            mouseDown.length = 0;
            mouseUp.length = 0;
            mouseWheelDelta[0] = 0;
            mouseWheelDelta[1] = 0;
            if (deltaMovement) {
                deltaMovement[0] = 0;
                deltaMovement[1] = 0;
            }
        };

        /**
         * Update the mouseInput with the relative position of the canvas element.
         * This method should be called whenever the canvas element is moved in the document. <br>
         * This method is automatically on engine.canvasResized events.
         *
         * @method updateCanvasElementPosition
         */
        this.updateCanvasElementPosition = updateCanvasElementPositionPrivate;

        (function init() {
            updateCanvasElementPositionPrivate();
            var canvas = engine.canvas;
            canvas.addEventListener("mousedown", mouseDownHandler, true);
            canvas.addEventListener("mouseup", mouseUpHandler, true);
            canvas.addEventListener("mousemove", mouseMovementHandler, true);
            canvas.addEventListener("mouseout", mouseOutHandler, true);
            canvas.addEventListener("contextmenu", mouseContextMenuHandler, true);
            engine.addEventListener("canvasResized", updateCanvasElementPositionPrivate);
            if (isFirefox) {
                canvas.addEventListener('MozMousePixelScroll', mouseWheelHandler, true); // Firefox
            } else if (isChrome) {
                canvas.addEventListener('mousewheel', mouseWheelHandler, true); // Chrome
            } else {
                canvas.addEventListener('DOMMouseScroll', mouseWheelHandler, true); // Firefox
            }
        }());
    };

});

define('kick/core/KeyInput',["./Util"], function (Util) {
    

    /**
     * Key Input manager.<br>
     * This class encapsulates keyboard input and makes it easy to
     * test for key input.<br>
     *
     * Example code:
     * @example
     *     function KeyTestComponent(){
     *         var keyInput, thisObj = this;
     *         // registers listener (invoked when component is registered)
     *         this.activated = function (){
     *             var engine = kick.core.Engine.instance;
     *             keyInput = engine.keyInput;
     *         };
     *         this.update = function(){
     *             var keyCodeForA = "A".charCodeAt(0);
     *             if (keyInput.isKeyDown(keyCodeForA)){
     *                 console.log("A key is down");
     *             }
     *             if (keyInput.isKey(keyCodeForA)){
     *                 console.log("A key is being held down");
     *             }
     *             if (keyInput.isKeyUp(keyCodeForA)){
     *                 console.log("A key is up");
     *             }
     *         };
     *     }
     *
     * Pressing the 'a' key should result in one frame with 'A key is down',
     * multiple frames with 'A key is being held down' and finally one frame
     * with 'A key is up'
     * @class KeyInput
     * @constructor
     * @namespace kick.core
     */
    return function () {
        var keyDown = [],
            keyUp = [],
            key = [],
            removeElementFromArray = Util.removeElementFromArray,
            contains = Util.contains,
            keyDownHandler = function (e) {
                var keyCode = e.keyCode;
                if (!contains(key, keyCode)) {
                    keyDown.push(keyCode);
                    key.push(keyCode);
                }
            },
            keyUpHandler = function (e) {
                var keyCode = e.keyCode;
                keyUp.push(keyCode);
                removeElementFromArray(key, keyCode);
            };

        /**
         * @method isKeyDown
         * @param {Number} keyCode
         * @return {boolean} true if key is pressed down in this frame
         */
        this.isKeyDown = function (keyCode) {
            return contains(keyDown, keyCode);
        };

        /**
         * @method isKeyUp
         * @param {Number} keyCode
         * @return {boolean} true if key is release in this frame
         */
        this.isKeyUp = function (keyCode) {
            return contains(keyUp, keyCode);
        };

        /**
         *
         * @method isKey
         * @param {Number} keyCode
         * @return {boolean} true if key is down
         */
        this.isKey = function (keyCode) {
            return contains(key, keyCode);
        };

        /**
         * @method isAnyKeyDown
         * @return {boolean} true if any key is pressed down in this frame
         */
        this.isAnyKeyDown = function () {
            return keyDown.length > 0;
        };

        /**
         * @method isAnyKeyUp
         * @return {boolean} true if any key is release in this frame
         */
        this.isAnyKeyUp = function () {
            return keyUp.length > 0;
        };

        /**
         *
         * @method isAnyKey
         * @return {boolean} true if any key is down
         */
        this.isAnyKey = function () {
            return key.length > 0;
        };


        /**
         * This method clears key up and key downs each frame (leaving key unmodified)
         * @method update
         * @private
         */
        this.frameUpdated = function () {
            keyDown.length = 0;
            keyUp.length = 0;
        };

        (function init() {
            document.addEventListener("keydown", keyDownHandler, false);
            document.addEventListener("keyup", keyUpHandler, false);
        }());
    };

});

define('kick/core/EventQueue',["./Util"], function (util) {
    

    /**
     * Event queue let you schedule future events in the game engine. Events are invoked just before the
     * Component.update() methods.<br>
     * An event can run for either a single frame or for multiple frames.
     * @class EventQueue
     * @namespace kick.core
     * @param {kick.core.Engine} engine
     */
    return function (engine) {
        var queue = [],
            queueSortFn = function (a, b) {
                return a.timeStart - b.timeStart;
            },
            time = engine.time;

        /**
         * Add a event to the event queue. Using timeStart = 0 will make the event run in the next frame.
         * @method add
         * @param {function} task
         * @param {Number} timeStart Number of milliseconds from current time
         * @param {Number} timeEnd=timeStart Number of milliseconds from current time
         * @return {Object} event object (used for 'cancel' event)
         */
        this.add = function (task, timeStart, timeEnd) {
            var currentTime = time.time + 1, // schedule for one millisecond in the future - this makes it legal for event call backs to schedule new events
                queueElement = {
                    task: task,
                    timeStart: timeStart + currentTime,
                    timeEnd: (timeEnd || timeStart) + currentTime
                };
            util.insertSorted(queueElement, queue, queueSortFn);
            return queueElement;
        };

        /**
         * Removes an event object from the queue.
         * @method cancel
         * @param {Object} eventObject (should be the object returned from the EventQueue.add method
         */
        this.cancel = function (eventObject) {
            util.removeElementFromArray(queue, eventObject);
        };

        /**
         * Run the event queue. This method is invoked by the Engine object just before the components are updated.
         * @protected
         * @method run
         */
        this.run = function () {
            var i,
                currentTime = time.time,
                queueLength = queue.length,
                queueElement;
            for (i = 0; i < queueLength && (queueElement = queue[i]).timeStart < currentTime; i++) {
                queueElement.task();
                if (queueElement.timeEnd < currentTime) {
                    queue.splice(i, 1);
                    queueLength--;
                }
            }
        };

        /**
         * Clears the queue
         * @method clear
         */
        this.clear = function () {
            queue = [];
        };
    };
});

define('kick/math/Quat',["kick/core/Constants", "./Vec3", "./Vec4", "./Mat3", "./Mat4"], function (constants, vec3, vec4, mat3, mat4) {
    

    /**
     * Quat - Quaternions
     * @class Quat
     * @namespace kick.math
     */
    return {
        /**
         * Creates a new identity quat
         *
         * @method create
         * @return {kick.math.Quat} New quat
         * @static
         */
        create: function () {
            var out = new Float32Array(4);
            out[3] = 1;
            return out;
        },

        /**
         * Creates a new quat initialized with values from an existing quaternion
         * @method clone
         * @param {kick.math.Quat} a quaternion to clone
         * @return {kick.math.Quat} a new quaternion
         * @static
         */
        clone: vec4.clone,

        /**
         * Creates a new quat initialized with the given values
         * @method fromValues
         * @param {Number} x X component
         * @param {Number} y Y component
         * @param {Number} z Z component
         * @param {Number} w W component
         * @return {kick.math.Quat} a new quaternion
         * @static
         */
        fromValues: vec4.fromValues,

        /**
         * Copy the values from one quat to another
         *
         * @method copy
         * @param {kick.math.Quat} out the receiving quaternion
         * @param {kick.math.Quat} a the source quaternion
         * @return {kick.math.Quat} out
         * @static
         */
        copy: vec4.copy,

        /**
         * Set the components of a quat to the given values
         *
         * @method set
         * @param {kick.math.Quat} out the receiving quaternion
         * @param {Number} x X component
         * @param {Number} y Y component
         * @param {Number} z Z component
         * @param {Number} w W component
         * @return {kick.math.Quat} out
         * @static
         */
        set: vec4.set,

        /**
         * Set a quat to the identity quaternion (0,0,0,1)
         * @method identity
         * @param {kick.math.Quat} out quat to set the identity to
         * @return {kick.math.Quat} out
         * @static
         */
        identity: function (out) {
            out[0] = 0;
            out[1] = 0;
            out[2] = 0;
            out[3] = 1;
            return out;
        },

        /**
         * Sets a quat from the given angle and rotation axis,
         * then returns it.
         * @method setAxisAngle
         * @param {kick.math.Quat} out the receiving quaternion
         * @param {kick.math.Vec3} axis the axis around which to rotate
         * @param {Number} rad the angle in radians
         * @return {kick.math.Quat} out
         * @static
         */
        setAxisAngle: function (out, axis, rad) {
            rad = rad * 0.5;
            var s = Math.sin(rad);
            out[0] = s * axis[0];
            out[1] = s * axis[1];
            out[2] = s * axis[2];
            out[3] = Math.cos(rad);
            return out;
        },

        /**
         * Adds two quat's
         *
         * @method add
         * @param {kick.math.Quat} out the receiving quaternion
         * @param {kick.math.Quat} a the first operand
         * @param {kick.math.Quat} b the second operand
         * @return {kick.math.Quat} out
         * @static
         */
        add: vec4.add,

        /**
         * Multiplies two quat's
         *
         * @method multiply
         * @param {kick.math.Quat} out the receiving quaternion
         * @param {kick.math.Quat} a the first operand
         * @param {kick.math.Quat} b the second operand
         * @return {kick.math.Quat} out
         * @static
         */
        multiply: function (out, a, b) {
            var ax = a[0], ay = a[1], az = a[2], aw = a[3],
                bx = b[0], by = b[1], bz = b[2], bw = b[3];

            out[0] = ax * bw + aw * bx + ay * bz - az * by;
            out[1] = ay * bw + aw * by + az * bx - ax * bz;
            out[2] = az * bw + aw * bz + ax * by - ay * bx;
            out[3] = aw * bw - ax * bx - ay * by - az * bz;
            return out;
        },

        /**
         * Scales a quat by a scalar number
         *
         * @method scale
         * @param {kick.math.Quat} out the receiving vector
         * @param {kick.math.Quat} a the vector to scale
         * @param {Number} b amount to scale the vector by
         * @return {kick.math.Quat} out
         * @static
         */
        scale: vec4.scale,

        /**
         * Rotates a quaternion by the given angle around the X axis
         *
         * @method rotateX
         * @param {kick.math.Quat} out quat receiving operation result
         * @param {kick.math.Quat} a quat to rotate
         * @param {Number} rad angle (in radians) to rotate
         * @return {kick.math.Quat} out
         * @static
         */
        rotateX: function (out, a, rad) {
            rad *= 0.5;

            var ax = a[0], ay = a[1], az = a[2], aw = a[3],
                bx = Math.sin(rad), bw = Math.cos(rad);

            out[0] = ax * bw + aw * bx;
            out[1] = ay * bw + az * bx;
            out[2] = az * bw - ay * bx;
            out[3] = aw * bw - ax * bx;
            return out;
        },

        /**
         * Rotates a quaternion by the given angle around the Y axis
         *
         * @method rotateY
         * @param {kick.math.Quat} out quat receiving operation result
         * @param {kick.math.Quat} a quat to rotate
         * @param {Number} rad angle (in radians) to rotate
         * @return {kick.math.Quat} out
         * @static
         */
        rotateY: function (out, a, rad) {
            rad *= 0.5;

            var ax = a[0], ay = a[1], az = a[2], aw = a[3],
                by = Math.sin(rad), bw = Math.cos(rad);

            out[0] = ax * bw - az * by;
            out[1] = ay * bw + aw * by;
            out[2] = az * bw + ax * by;
            out[3] = aw * bw - ay * by;
            return out;
        },

        /**
         * Rotates a quaternion by the given angle around the Z axis
         *
         * @method rotateZ
         * @param {kick.math.Quat} out quat receiving operation result
         * @param {kick.math.Quat} a quat to rotate
         * @param {Number} rad angle (in radians) to rotate
         * @return {kick.math.Quat} out
         * @static
         */
        rotateZ : function (out, a, rad) {
            rad *= 0.5;

            var ax = a[0], ay = a[1], az = a[2], aw = a[3],
                bz = Math.sin(rad), bw = Math.cos(rad);

            out[0] = ax * bw + ay * bz;
            out[1] = ay * bw - ax * bz;
            out[2] = az * bw + aw * bz;
            out[3] = aw * bw - az * bz;
            return out;
        },

        /**
         * Calculates the W component of a quat from the X, Y, and Z components.
         * Assumes that quaternion is 1 unit in length.
         * Any existing W component will be ignored.
         * @method calculateW
         * @param {kick.math.Quat} out the receiving quaternion
         * @param {kick.math.Quat} a quat to calculate W component of
         * @return {kick.math.Quat} out
         * @static
         */
        calculateW: function (out, a) {
            var x = a[0], y = a[1], z = a[2];

            out[0] = x;
            out[1] = y;
            out[2] = z;
            out[3] = -Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));
            return out;
        },

        /**
         * Returns dot product of q1 and q1
         * @method dot
         * @param {kick.math.Quat} q1
         * @param {kick.math.Quat} q2
         * @return {Number}
         * @static
         */
        dot: vec4.dot,

        /**
         * Performs a linear interpolation between two quat's
         * @method lerp
         * @param {kick.math.Quat} out the receiving quaternion
         * @param {kick.math.Quat} a the first operand
         * @param {kick.math.Quat} b the second operand
         * @param {Number} t interpolation amount between the two inputs
         * @return {kick.math.Quat} out
         * @static
         */
        lerp: vec4.lerp,

        /**
         * Performs a spherical linear interpolation between two quat
         * @method slerp
         * @param {kick.math.Quat} out the receiving quaternion
         * @param {kick.math.Quat} a the first operand
         * @param {kick.math.Quat} b the second operand
         * @param {Number} t interpolation amount between the two inputs
         * @return {kick.math.Quat} out
         * @static
         */
        slerp: function (out, a, b, t) {
            var ax = a[0], ay = a[1], az = a[2], aw = a[3],
                bx = b[0], by = b[1], bz = b[2], bw = a[3],

                cosHalfTheta = ax * bx + ay * by + az * bz + aw * bw,
                halfTheta,
                sinHalfTheta,
                ratioA,
                ratioB;

            if (Math.abs(cosHalfTheta) >= 1.0) {
                if (out !== a) {
                    out[0] = ax;
                    out[1] = ay;
                    out[2] = az;
                    out[3] = aw;
                }
                return out;
            }

            halfTheta = Math.acos(cosHalfTheta);
            sinHalfTheta = Math.sqrt(1.0 - cosHalfTheta * cosHalfTheta);

            if (Math.abs(sinHalfTheta) < 0.001) {
                out[0] = (ax * 0.5 + bx * 0.5);
                out[1] = (ay * 0.5 + by * 0.5);
                out[2] = (az * 0.5 + bz * 0.5);
                out[3] = (aw * 0.5 + bw * 0.5);
                return out;
            }

            ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta;
            ratioB = Math.sin(t * halfTheta) / sinHalfTheta;

            out[0] = (ax * ratioA + bx * ratioB);
            out[1] = (ay * ratioA + by * ratioB);
            out[2] = (az * ratioA + bz * ratioB);
            out[3] = (aw * ratioA + bw * ratioB);

            return out;
        },

        /**
         * Calculates the inverse of a quat
         *
         * @method inverse
         * @param {kick.math.Quat} out the receiving quaternion
         * @param {kick.math.Quat} a quat to calculate inverse of
         * @return {kick.math.Quat} out
         * @static
         */
        invert: function (out, a) {
            var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],
                dot = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3,
                invDot = dot ? 1.0 / dot : 0;

            // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0

            out[0] = -a0 * invDot;
            out[1] = -a1 * invDot;
            out[2] = -a2 * invDot;
            out[3] = a3 * invDot;
            return out;
        },

        /**
         * Calculates the conjugate of a quat
         * @method conjugate
         * @param {kick.math.Quat} out the receiving quaternion
         * @param {kick.math.Quat} a quat to calculate conjugate of
         * @return {kick.math.Quat} out
         * @static
         */
        conjugate: function (out, a) {
            out[0] = -a[0];
            out[1] = -a[1];
            out[2] = -a[2];
            out[3] = a[3];
            return out;
        },

        /**
         * Calculates the length of a quat
         * @method length
         * @param {kick.math.Quat} a vector to calculate length of
         * @return {Number} length of a
         * @static
         */
        length: vec4.length,

        /**
         * Calculates the squared length of a quat
         *
         * @method squaredLength
         * @param {kick.math.Quat} a vector to calculate squared length of
         * @return {Number} squared length of a
         * @static
         */
        squaredLength: vec4.squaredLength,

        /**
         * Normalize a quat
         *
         * @method normalize
         * @param {kick.math.Quat} out the receiving quaternion
         * @param {kick.math.Quat} a quaternion to normalize
         * @return {kick.math.Quat} out
         * @static
         */
        normalize: vec4.normalize,


        /**
         * Creates a quaternion from the given 3x3 rotation matrix.
         * @method fromMat3
         * @param {kick.math.Quat} out the receiving quaternion
         * @param {kick.math.Mat3} m rotation matrix
         * @return {kick.math.Quat} out
         * @static
         */
        fromMat3: (function() {
            var s_iNext = [1,2,0];
            return function(out, m) {
                // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes
                // article "Quaternion Calculus and Fast Animation".
                var fTrace = m[0] + m[4] + m[8];
                var fRoot;

                if ( fTrace > 0.0 ) {
                    // |w| > 1/2, may as well choose w > 1/2
                    fRoot = Math.sqrt(fTrace + 1.0);  // 2w
                    out[3] = 0.5 * fRoot;
                    fRoot = 0.5/fRoot;  // 1/(4w)
                    out[0] = (m[7]-m[5])*fRoot;
                    out[1] = (m[2]-m[6])*fRoot;
                    out[2] = (m[3]-m[1])*fRoot;
                } else {
                    // |w| <= 1/2
                    var i = 0;
                    if ( m[4] > m[0] )
                      i = 1;
                    if ( m[8] > m[i*3+i] )
                      i = 2;
                    var j = s_iNext[i];
                    var k = s_iNext[j];

                    fRoot = Math.sqrt(m[i*3+i]-m[j*3+j]-m[k*3+k] + 1.0);
                    out[i] = 0.5 * fRoot;
                    fRoot = 0.5 / fRoot;
                    out[3] = (m[k*3+j] - m[j*3+k]) * fRoot;
                    out[j] = (m[j*3+i] + m[i*3+j]) * fRoot;
                    out[k] = (m[k*3+i] + m[i*3+k]) * fRoot;
                }

                return out;
            };
        })(),

        /**
         * Transforms a vec3 with the given quaternion
         * @method multiplyVec3
         * @param {kick.math.Vec3} out vec3 receiving operation result
         * @param {kick.math.Quat} quat quat to transform the vector with
         * @param {kick.math.Vec3} vec vec3 to transform
         * @return {kick.math.Vec3} out
         * @static
         */
        multiplyVec3: function (out, quat, vec) {
            var x = vec[0], y = vec[1], z = vec[2],
                qx = quat[0], qy = quat[1], qz = quat[2], qw = quat[3],

            // calculate quat * vec
                ix = qw * x + qy * z - qz * y,
                iy = qw * y + qz * x - qx * z,
                iz = qw * z + qx * y - qy * x,
                iw = -qx * x - qy * y - qz * z;

            // calculate result * inverse quat
            out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
            out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
            out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;

            return out;
        },


        /**
         * Calculates a rotation represented in Eulers angles (in degrees)
         * Pitch->X axis, Yaw->Y axis, Roll->Z axis
         * @method toEuler
         * @param {kick.math.Vec3} out vec3  receiving operation result
         * @param {kick.math.Quat} quat quat to create matrix from
         * @return {kick.math.Vec3} out
         * @static
         */
        toEuler: function (out, quat) {
            var x = quat[0], y = quat[1], z = quat[2], w = quat[3],
                yy = y * y,
                radianToDegree = 57.2957795130824;

            if (!out) { out = vec3.create(); }

            out[0] = Math.atan2(2 * (w * x + y * z), 1 - 2 * (x * x + yy)) * radianToDegree;
            out[1] = Math.asin(2 * (w * y - z * x)) * radianToDegree;
            out[2] = Math.atan2(2 * (w * z + x * y), 1 - 2 * (yy + z * z)) * radianToDegree;

            return out;
        },

        /**
         * Compute the lookAt rotation
         * @method lookAt
         * @param {kick.math.Quat} out
         * @param {kick.math.Vec3} position
         * @param {kick.math.Vec3} target
         * @param {kick.math.Vec3} up
         * @return {kick.math.Quat} out
         * @static
         */
        lookAt: (function () {
            var upVector = vec3.create(),
                rightVector = vec3.create(),
                forwardVector = vec3.create(),
                destMatrix = mat3.create();
            return function (out, position, target, up) {
                // idea create mat3 rotation and transform into quaternion
                vec3.subtract(forwardVector, position, target);
                vec3.normalize(forwardVector, forwardVector);
                vec3.cross(rightVector, up, forwardVector);
                vec3.normalize(rightVector, rightVector); // needed?
                vec3.cross(upVector, forwardVector, rightVector);
                vec3.normalize(upVector, upVector); // needed?
                destMatrix[0] = rightVector[0];
                destMatrix[1] = rightVector[1];
                destMatrix[2] = rightVector[2];
                destMatrix[3] = upVector[0];
                destMatrix[4] = upVector[1];
                destMatrix[5] = upVector[2];
                destMatrix[6] = forwardVector[0];
                destMatrix[7] = forwardVector[1];
                destMatrix[8] = forwardVector[2];
                return mat3.toQuat(out, destMatrix);
            };
        }()),

        /**
         * Set the rotation based on Eulers angles.
         * Pitch->X axis, Yaw->Y axis, Roll->Z axis
         * @method setEuler
         * @param {kick.math.Quat} out quat receiving operation result
         * @param {kick.math.Vec3} vec vec3 eulers angles (degrees)
         * @return {kick.math.Quat} dest if specified, a new quat otherwise
         * @static
         */
        setEuler: function (out, vec) {
            // code based on GLM
            var degreeToRadian = 0.01745329251994, halfDTR = degreeToRadian * 0.5,
                x = vec[0] * halfDTR,
                y = vec[1] * halfDTR,
                z = vec[2] * halfDTR,
                cx = Math.cos(x), cy = Math.cos(y), cz = Math.cos(z),
                sx = Math.sin(x), sy = Math.sin(y), sz = Math.sin(z);
            out[3] = cx * cy * cz + sx * sy * sz;
            out[0] = sx * cy * cz - cx * sy * sz;
            out[1] = cx * sy * cz + sx * cy * sz;
            out[2] = cx * cy * sz - sx * sy * cz;
            return out;
        },


        /**
         * @method setFromRotationMatrix
         * @param {kick.math.Quat} out
         * @param {kick.math.Mat4} mat
         * @return {kick.math.Quat}
         * @static
         */
        setFromRotationMatrix: function (out, mat) {
            var x, y, z, w,
                m00 = mat[0], m01 = mat[4], m02 = mat[8],
                m10 = mat[1], m11 = mat[5], m12 = mat[9],
                m20 = mat[2], m21 = mat[6], m22 = mat[10],
                absQ;
            // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm
            function copySign(a, b) {
                return b < 0 ? -Math.abs(a) : Math.abs(a);
            }
            absQ = Math.pow(mat4.determinant(mat), 1.0 / 3.0);
            w = Math.sqrt(Math.max(0, absQ + m00  + m11 + m22)) / 2;
            x = Math.sqrt(Math.max(0, absQ + m00  - m11 - m22)) / 2;
            y = Math.sqrt(Math.max(0, absQ - m00  + m11 - m22)) / 2;
            z = Math.sqrt(Math.max(0, absQ - m00  - m11 + m22)) / 2;
            x = copySign(x, (m21 - m12)); // m21 - m12
            y = copySign(y, (m02 - m20)); // m02 - m20
            z = copySign(z, (m10 - m01)); // m10 - m01
            this.copy(out, [x, y, z, w]);
            this.normalize(out, out);
            return out;
        },

        /**
         * Calculates a 3x3 matrix from the given quat
         * @method toMat3
         * @param {kick.math.Mat3} out mat3 receiving operation result
         * @param {kick.math.Quat} quat quat to create matrix from
         * @return {kick.math.Mat3} out
         * @static
         */
        toMat3: function (out, quat) {
            var x = quat[0], y = quat[1], z = quat[2], w = quat[3],
                x2 = x + x,
                y2 = y + y,
                z2 = z + z,

                xx = x * x2,
                xy = x * y2,
                xz = x * z2,
                yy = y * y2,
                yz = y * z2,
                zz = z * z2,
                wx = w * x2,
                wy = w * y2,
                wz = w * z2;

            out[0] = 1 - (yy + zz);
            out[1] = xy + wz;
            out[2] = xz - wy;

            out[3] = xy - wz;
            out[4] = 1 - (xx + zz);
            out[5] = yz + wx;

            out[6] = xz + wy;
            out[7] = yz - wx;
            out[8] = 1 - (xx + yy);

            return out;
        },

        /**
         * Calculates a 4x4 matrix from the given quat
         * @method toMat4
         * @param {kick.math.Mat4} out mat4 receiving operation result
         * @param {kick.math.Quat} quat quat to create matrix from
         * @return {kick.math.Mat4} out
         * @static
         */
        toMat4: function (out, quat) {

            var x = quat[0], y = quat[1], z = quat[2], w = quat[3],
                x2 = x + x,
                y2 = y + y,
                z2 = z + z,

                xx = x * x2,
                xy = x * y2,
                xz = x * z2,
                yy = y * y2,
                yz = y * z2,
                zz = z * z2,
                wx = w * x2,
                wy = w * y2,
                wz = w * z2;

            out[0] = 1 - (yy + zz);
            out[1] = xy + wz;
            out[2] = xz - wy;
            out[3] = 0;

            out[4] = xy - wz;
            out[5] = 1 - (xx + zz);
            out[6] = yz + wx;
            out[7] = 0;

            out[8] = xz + wy;
            out[9] = yz - wx;
            out[10] = 1 - (xx + yy);
            out[11] = 0;

            out[12] = 0;
            out[13] = 0;
            out[14] = 0;
            out[15] = 1;

            return out;
        },



        /**
         * Return rotation that goes from quat to quat2.<br>
         * It is the same as: quat.multiply(dest, quat.invert(quat,quat),quat2);
         * @method difference
         * @param {kick.math.Quat} out
         * @param {kick.math.Quat} quat from rotation
         * @param {kick.math.Quat} quat2 to rotation
         * @return {kick.math.Quat} out
         * @static
         */
        difference: function (out, quat, quat2) {
            var qax = -quat[0], qay = -quat[1], qaz = -quat[2], qaw = quat[3],
                qbx = quat2[0], qby = quat2[1], qbz = quat2[2], qbw = quat2[3];

            out[0] = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
            out[1] = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
            out[2] = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
            out[3] = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

            return out;
        },

        /**
         * Returns a string representation of a quaternion
         * @method str
         * @param {kick.math.Quat} quat quat to represent as a string
         * @return {String} string representation of quat
         * @static
         */
        str: function (quat) {
            return '[' + quat[0] + ', ' + quat[1] + ', ' + quat[2] + ', ' + quat[3] + ']';
        }
    };
});

define('kick/scene/SceneLights',["kick/core/Constants", "kick/core/Util", "kick/math/Mat3", "kick/math/Mat4", "kick/math/Vec3", "kick/math/Quat"],
    function (Constants, Util, Mat3, Mat4, Vec3, Quat) {
        

        var ASSERT = true;

        /**
         * Datastructure used pass light information
         * @class SceneLights
         * @namespace kick.scene
         * @constructor
         * @param {Number} maxNumerOfLights (value from config)
         */
        return function (maxNumerOfLights) {
            var ambientLight = null,
                directionalLight = null,
                directionalLightData = new Float32Array(9), // column matrix with the columns lightDirection,colorIntensity,halfVector
                directionalLightDirection = directionalLightData.subarray(0, 3),
                directionalLightColorIntensity = directionalLightData.subarray(3, 6),
                directionalHalfVector = directionalLightData.subarray(6, 9),
                directionalLightDirectionWorld = Vec3.clone([1, 0, 0]),
                directionalLightTransform = null,
                pointLightData = new Float32Array(9 * maxNumerOfLights), // mat3*maxNumerOfLights
                pointLightDataVec3 = Vec3.wrapArray(pointLightData),
                pointLights = [],
                lightDirection = [0, 0, 1],
                /**
                 * Set the point light to have not contribution this means setting the position 1,1,1, the color to 0,0,0
                 * and attenuation to 1,0,0.<br>
                 * This is needed since the ecLight position would otherwise be in 0,0,0 which is invalid
                 * @method resetPointLight
                 * @param {Number} index of point light
                 * @private
                 */
                resetPointLight = function (index) {
                    var i;
                    for (i = 0; i < 3; i++) {
                        Vec3.copy(pointLightDataVec3[index * 3 + i], [0, 0, 0]);
                    }
                };
            Object.defineProperties(this, {
                /**
                 * The ambient light in the scene.
                 * @property ambientLight
                 * @type kick.scene.Light
                 */
                ambientLight: {
                    get: function () {
                        return ambientLight;
                    },
                    set: function (value) {
                        if (ASSERT) {
                            if (value && ambientLight) {
                                throw new Error("Cannot have multiple ambient lights in the scene");
                            }
                        }
                        ambientLight = value;
                    }
                },
                /**
                 * The directional light in the scene.
                 * @property directionalLight
                 * @type kick.scene.Light
                 */
                directionalLight: {
                    get: function () {
                        return directionalLight;
                    },
                    set: function (value) {
                        if (ASSERT) {
                            if (value && directionalLight) {
                                throw new Error("Cannot have multiple directional lights in the scene");
                            }
                        }
                        directionalLight = value;
                        if (value !== null) {
                            directionalLightTransform = directionalLight.gameObject.transform;
                        } else {
                            directionalLightTransform = null;
                            Mat3.copy(directionalLightData, [0, 0, 0, 0, 0, 0, 0, 0, 0]);
                        }
                    }
                },
                /**
                 * Matrix of directional light data. Column 1 contains the light-direction in eye space,
                 * column 2 color intensity and column 3 half vector
                 * @property directionalLightData
                 * @type kick.math.Mat3
                 */
                directionalLightData: {
                    get: function () {
                        return directionalLightData;
                    }
                },
                /**
                 * Return the directional light in world space
                 * @property directionalLightWorld
                 * @type kick.math.Vec3
                 */
                directionalLightWorld: {
                    get: function () {
                        return directionalLightDirectionWorld;
                    }
                },
                /**
                 * Matrices of point light data. Each matrix (mat3) contains:<br>
                 * Column 1 vector: point light position in eye coordinates<br>
                 * Column 2 vector: color intensity<br>
                 * Column 3 vector: attenuation vector
                 * @property pointLightData
                 * @type Array of Mat3
                 */
                pointLightData: {
                    get: function () {
                        return pointLightData;
                    }
                }
            });

            /**
             * @method addPointLight
             * @param {kick.scene.Light} pointLight
             */
            this.addPointLight = function (pointLight) {
                if (!Util.contains(pointLights, pointLight)) {
                    if (pointLights.length === maxNumerOfLights) {
                        if (ASSERT) {
                            Util.fail("Only " + maxNumerOfLights + " point lights allowed in scene");
                        }
                    } else {
                        pointLights.push(pointLight);
                    }
                }
            };

            /**
             * @method removePointLight
             * @param {kick.scene.Light} pointLight
             */
            this.removePointLight = function (pointLight) {
                var index = pointLights.indexOf(pointLight);
                if (index >= 0) {
                    // remove element at position index
                    pointLights.splice(index, 1);
                } else {
                    if (ASSERT) {
                        Util.fail("Error removing point light");
                    }
                }
                resetPointLight(pointLights.length);
            };

            /**
             * Recompute the light based on the view-matrix. This method is called from the camera when the scene is
             * rendered, to transform the light into eye coordinates and compute the half vector for directional light
             * @method recomputeLight
             * @param {kick.math.Mat4} viewMatrix
             */
            this.recomputeLight = function (viewMatrix) {
                if (directionalLight !== null) {
                    // compute light direction
                    Quat.multiplyVec3(directionalLightDirectionWorld, directionalLightTransform.rotation, lightDirection);

                    // transform to eye space
                    Mat4.multiplyVec3Vector(directionalLightDirection, viewMatrix, directionalLightDirectionWorld);
                    Vec3.normalize(directionalLightDirection, directionalLightDirection);

                    // compute half vector
                    Vec3.add(directionalHalfVector, lightDirection, directionalLightDirection);
                    Vec3.normalize(directionalHalfVector, directionalHalfVector);

                    Vec3.copy(directionalLightColorIntensity, directionalLight.colorIntensity);
                }
                if (maxNumerOfLights) { // only run if max number of lights are 1 or above (otherwise JIT compiler will skip it)
                    var index = 0,
                        i,
                        pointLight,
                        pointLightPosition;
                    for (i = pointLights.length - 1; i >= 0; i--) {
                        pointLight = pointLights[i];
                        pointLightPosition = pointLight.transform.position;

                        Mat4.multiplyVec3(pointLightDataVec3[index], viewMatrix, pointLightPosition);
                        Vec3.copy(pointLightDataVec3[index + 1], pointLight.colorIntensity);
                        Vec3.copy(pointLightDataVec3[index + 2], pointLight.attenuation);
                        index += 3;
                    }
                }
            };

            (function init() {
                var i;
                for (i = 0; i < maxNumerOfLights; i++) {
                    resetPointLight(i);
                }
            }());
        };
    });

define('kick/math/Frustum',["kick/core/Constants", "./Vec3", "./Aabb"], function (constants, vec3, aabb) {
    
    var OUTSIDE = 0,
        INSIDE = 1,
        INTERSECTING = 2;

    /**
     * Frustum represented as 6 line equations (a*x+b*y+c*z+d=0 , where [a,b,c] is the normal of the plane).
     * Note the normals of the frustum points inwards. The order of the planes are left, right, top, bottom, near, far
     * The implementation is based on
     * "Fast Extraction of Viewing Frustum Planes from the WorldView-Projection Matrix" by Gil Grib and Klaus Hartmann
     * http://www.cs.otago.ac.nz/postgrads/alexis/planeExtraction.pdf
     * @class Frustum
     * @namespace kick.math
     */
    return {
        /**
         * Create a array of 24. 6 line equations (a*x+b*y+c*z+d=0 , where [a,b,c] is the normal of the plane).
         * @method create
         * @static
         */
        create : function () {
            return new Float32Array(24);
        },

        /**
         * @method extractPlanes
         * @param {Array_24} out
         * @param {kick.math.Mat4} modelViewMatrix
         * @param {Boolean} normalize normalize plane normal
         * @return {Array_24} out
         * @static
         */
        extractPlanes: function (out, modelViewMatrix, normalize) {
            var _11 = modelViewMatrix[0], _21 = modelViewMatrix[1], _31 = modelViewMatrix[2], _41 = modelViewMatrix[3],
                _12 = modelViewMatrix[4], _22 = modelViewMatrix[5], _32 = modelViewMatrix[6], _42 = modelViewMatrix[7],
                _13 = modelViewMatrix[8], _23 = modelViewMatrix[9], _33 = modelViewMatrix[10], _43 = modelViewMatrix[11],
                _14 = modelViewMatrix[12], _24 = modelViewMatrix[13], _34 = modelViewMatrix[14], _44 = modelViewMatrix[15],
                i,
                x,
                y,
                z,
                length,
                lengthRecip;
            // Left clipping plane
            out[0] = _41 + _11;
            out[1] = _42 + _12;
            out[2] = _43 + _13;
            out[3] = _44 + _14;
            // Right clipping plane
            out[4] = _41 - _11;
            out[4 + 1] = _42 - _12;
            out[4 + 2] = _43 - _13;
            out[4 + 3] = _44 - _14;
            // Top clipping plane
            out[2 * 4] = _41 - _21;
            out[2 * 4 + 1] = _42 - _22;
            out[2 * 4 + 2] = _43 - _23;
            out[2 * 4 + 3] = _44 - _24;
            // Bottom clipping plane
            out[3 * 4] = _41 + _21;
            out[3 * 4 + 1] = _42 + _22;
            out[3 * 4 + 2] = _43 + _23;
            out[3 * 4 + 3] = _44 + _24;
            // Near clipping plane
            out[4 * 4] = _41 + _31;
            out[4 * 4 + 1] = _42 + _32;
            out[4 * 4 + 2] = _43 + _33;
            out[4 * 4 + 3] = _44 + _34;
            // Far clipping plane
            out[5 * 4] = _41 - _31;
            out[5 * 4 + 1] = _42 - _32;
            out[5 * 4 + 2] = _43 - _33;
            out[5 * 4 + 3] = _44 - _34;
            if (normalize) {
                for (i = 0; i < 6; i++) {
                    x = out[i * 4];
                    y = out[i * 4 + 1];
                    z = out[i * 4 + 2];
                    length = Math.sqrt(x * x + y * y + z * z);
                    lengthRecip = 1 / length;
                    out[i * 4] *= lengthRecip;
                    out[i * 4 + 1] *= lengthRecip;
                    out[i * 4 + 2] *= lengthRecip;
                    out[i * 4 + 3] *= lengthRecip;
                }
            }
            return out;
        },

        /**
         * Value = 0
         * @property OUTSIDE
         * @type Number
         * @static
         */
        OUTSIDE: OUTSIDE,

        /**
         * Value = 1
         * @property INSIDE
         * @type Number
         * @static
         */
        INSIDE: INSIDE,

        /**
         * Value = 2
         * @property INTERSECTING
         * @type Number
         * @static
         */
        INTERSECTING: INTERSECTING,

        /**
         * Based on [Akenine-Moller's Real-Time Rendering 3rd Ed] chapter 16.14.3
         * @method intersectAabb
         * @param {kick.math.Frustum} frustumPlanes
         * @param {kick.math.Aabb} aabbIn
         * @return {Number} frustum.OUTSIDE = outside(0), frustum.INSIDE = inside(1), frustum.INTERSECTING = intersecting(2)
         * @static
         */
        intersectAabb: (function () {
            var center = vec3.create(),
                halfVector = vec3.create();
            return function (frustumPlanes, aabbIn) {
                var result = INSIDE, i,
                    testResult,
                    centerX, centerY, centerZ,
                    halfVectorX, halfVectorY, halfVectorZ,
                    // based on [Akenine-Moller's Real-Time Rendering 3rd Ed] chapter 16.10.1
                    planeAabbIntersect = function (planeIndex) {
                        var offset = planeIndex * 4,
                            nx = frustumPlanes[offset],
                            ny = frustumPlanes[offset + 1],
                            nz = frustumPlanes[offset + 2],
                            d = frustumPlanes[offset + 3],
                            e = halfVectorX * Math.abs(nx) + halfVectorY * Math.abs(ny) + halfVectorZ * Math.abs(nz),
                            s = centerX * nx + centerY * ny + centerZ * nz + d;
                        // Note that the following is reverse than in [Akenine-Moller's Real-Time Rendering 3rd Ed],
                        // since we define outside as the negative halfspace
                        if (s - e > 0) { return INSIDE; }
                        if (s + e < 0) { return OUTSIDE; }
                        return INTERSECTING;
                    };
                aabb.center(center, aabbIn);
                aabb.halfVec3(halfVector, aabbIn);
                centerX = center[0];
                centerY = center[1];
                centerZ = center[2];
                halfVectorX = halfVector[0];
                halfVectorY = halfVector[1];
                halfVectorZ = halfVector[2];
                for (i = 0; i < 6; i++) {
                    testResult = planeAabbIntersect(i);
                    if (testResult === OUTSIDE) {
                        return testResult;
                    } else if (testResult === INTERSECTING) {
                        result = INTERSECTING;
                    }
                }
                return result;
            };
        }())
    };
});

define('kick/scene/EngineUniforms',[], function () {
    

    /**
     * Data object for engine uniforms used during rendering (in the render method on components)
     * @class EngineUniforms
     * @namespace kick.scene
     * @constructor
     */
    return function (object) {
        /**
         * @property viewMatrix
         * @type kick.math.Mat4
         */
        this.viewMatrix = object.viewMatrix;
        /**
         * @property projectionMatrix
         * @type kick.math.Mat4
         */
        this.projectionMatrix = object.projectionMatrix;
        /**
         * @property viewProjectionMatrix
         * @type kick.math.Mat4
         */
        this.viewProjectionMatrix = object.viewProjectionMatrix;
        /**
         * @property lightMatrix
         * @type kick.math.Mat4
         */
        this.lightMatrix = object.lightMatrix;
        /**
         * @property currentCamera
         * @type kick.scene.Camera
         */
        this.currentCamera = object.currentCamera;
        /**
         * @property currentCameraTransform
         * @type kick.math.Mat4
         */
        this.currentCameraTransform = object.currentCameraTransform;
        /**
         * @property sceneLights
         * @type kick.scene.SceneLights
         */
        this.sceneLights = null;

        Object.seal(this);
    };
});

define('kick/texture/RenderTexture',["kick/core/ProjectAsset", "kick/math/Vec2", "kick/core/Constants", "kick/core/Util", "kick/core/EngineSingleton"],
    function (ProjectAsset, Vec2, Constants, Util, EngineSingleton) {
        

        /**
         * Render texture (used for camera's render target)
         * @class RenderTexture
         * @namespace kick.texture
         * @constructor
         * @param {Object} [config]
         * @extends kick.core.ProjectAsset
         */
        return function (config) {
            // extend ProjectAsset
            ProjectAsset(this, config, "kick.texture.RenderTexture");
            if (true){
                if (config === EngineSingleton.engine){
                    Util.fail("RenderTexture constructor changed - engine parameter is removed");
                }
            }
            var engine = EngineSingleton.engine,
                gl = engine.gl,
                _config = config || {},
                framebuffer = gl.createFramebuffer(),
                colorTexture = null,
                _dimension = Vec2.create(),
                renderBuffers = [],
                thisObj = this,
                _name = "",
                cleanUpRenderBuffers = function () {
                    var i;
                    for (i = 0; i < renderBuffers.length; i++) {
                        gl.deleteRenderbuffer(renderBuffers[i]);
                    }
                },
                initFBO = function () {
                    var renderbuffer,
                        frameBufferStatus;
                    _dimension = colorTexture ? colorTexture.dimension : _dimension;
                    cleanUpRenderBuffers();
                    gl.bindFramebuffer(36160, framebuffer);

                    if (colorTexture) {
                        gl.framebufferTexture2D(36160, 36064, 3553, colorTexture.textureId, 0);
                    } else {
                        renderbuffer = gl.createRenderbuffer();
                        gl.bindRenderbuffer(36161, renderbuffer);
                        gl.renderbufferStorage(36161, 32854, _dimension[0], _dimension[1]);
                        gl.framebufferRenderbuffer(36160, 36064, 36161, renderbuffer);
                        renderBuffers.push(renderbuffer);
                    }

                    renderbuffer = gl.createRenderbuffer();
                    gl.bindRenderbuffer(36161, renderbuffer);
                    gl.renderbufferStorage(36161, 33189, _dimension[0], _dimension[1]);
                    gl.framebufferRenderbuffer(36160, 36096, 36161, renderbuffer);
                    renderBuffers.push(renderbuffer);

                    if (true) {
                        frameBufferStatus = gl.checkFramebufferStatus(36160);
                        if (frameBufferStatus !== 36053) {
                            switch (frameBufferStatus) {
                            case 36054:
                                Util.fail("FRAMEBUFFER_INCOMPLETE_ATTACHMENT");
                                break;
                            case 36055:
                                Util.fail("FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT");
                                break;
                            case 36057:
                                Util.fail("FRAMEBUFFER_INCOMPLETE_DIMENSIONS");
                                break;
                            case 36061:
                                Util.fail("FRAMEBUFFER_UNSUPPORTED");
                                break;
                            }
                        }
                    }
                    gl.bindFramebuffer(36160, null);
                },
                contextLost = function () {
                    gl = null;
                },
                contextRestored = function (newGl) {
                    gl = newGl;
                    framebuffer = gl.createFramebuffer();
                    initFBO();
                };

            /**
             * Binds the render texture
             * @method bind
             */
            this.bind = function () {
                gl.bindFramebuffer(36160, framebuffer);
            };

            /**
             * Unbinds the render texture
             * @method unbind
             */
            this.unbind = function () {
                gl.bindFramebuffer(36160, null);
            };


            Object.defineProperties(this, {
                /**
                 * @property dimension
                 * @type kick.math.Vec2
                 */
                dimension: {
                    get: function () {
                        return _dimension;
                    },
                    set: function (newValue) {
                        _dimension = newValue;
                        if (_dimension) {
                            initFBO();
                        }
                    }
                },
                /**
                 * @property colorTexture
                 * @type kick.texture.Texture
                 */
                colorTexture: {
                    get: function () { return colorTexture; },
                    set: function (newValue) {
                        colorTexture = newValue;
                        if (colorTexture) {
                            initFBO();
                        }
                    }
                },
                /**
                 * @property name
                 * @type String
                 */
                name: {
                    get: function () { return _name; },
                    set: function (newValue) { _name = newValue; }
                }
            });

            /**
             * @method destroy
             */
            this.destroy = function () {
                if (framebuffer !== null) {
                    cleanUpRenderBuffers();
                    gl.deleteFramebuffer(framebuffer);
                    framebuffer = null;
                    engine.project.removeResourceDescriptor(thisObj.uid);
                    engine.removeEventListener("contextLost", contextLost);
                    engine.removeEventListener("contextRestored", contextRestored);
                }
            };

            /**
             * @method toJSON
             */
            this.toJSON = function () {
                return {
                    uid: thisObj.uid,
                    name: _name,
                    colorTexture: Util.getJSONReference(colorTexture)
                };
            };

            this.init(config);
            engine.addEventListener('contextLost', contextLost);
            engine.addEventListener('contextRestored', contextRestored);
        };

    });

define('kick/scene/MeshRenderer',["kick/core/Constants", "kick/material/Material", "kick/core/Util", "kick/mesh/Mesh", "kick/core/EngineSingleton", "kick/core/Observable"],
    function (Constants, Material, Util, Mesh, EngineSingleton, Observable) {
        

        var ASSERT = true;

        /**
         * Renders a Mesh.
         * To create custom renderable objects you should not inherit from this class, but simple create a component with a
         * render() method.
         * If a mesh with sub-meshes, which uses multiple materials, the renderOrder is taken from the first material
         * @class MeshRenderer
         * @constructor
         * @namespace kick.scene
         * @extends kick.scene.Component
         * @final
         * @param {Object} config configuration
         */
        return function (config) {
            var transform,
                _materials = [],
                _mesh,
                _renderOrder,
                engine = EngineSingleton.engine,
                thisObj = this,
                updateRenderOrder = function() {
                    if (_materials.length > 0 && _renderOrder !== _materials[0].renderOrder){
                        _renderOrder = _materials[0].renderOrder;
                        thisObj.fireEvent("componentUpdated", thisObj);
                    }
                };

            Observable.call(this,
                /**
                 * Fired when mesh is updated
                 * @event contextLost
                 * @param {kick.scene.Component} component
                 */
                ["componentUpdated"]
            );

            /**
             * If no materials are assigned, the ENGINE\_MATERIAL\_DEFAULT is assigned as material.
             * @method activated
             */
            this.activated = function () {
                transform = thisObj.gameObject.transform;
                if (_materials.length === 0) {
                    var project = engine.project;
                    thisObj.material = project.load(project.ENGINE_MATERIAL_DEFAULT);
                }
            };

            Object.defineProperties(this, {
                // inherit documentation from component
                aabb: {
                    get: function () {
                        return _mesh.aabb;
                    }
                },
                /**
                 * The renderOrder for materials[0]
                 * @property renderOrder
                 * @type {Number}
                 */
                renderOrder: {
                    get: function () {
                        return _renderOrder;
                    }
                },
                /**
                 * Shortcut for materials[0]
                 * @property material
                 * @type kick.material.Material
                 */
                material: {
                    get: function () {
                        if (_materials.length === 0) {
                            return null;
                        }
                        return _materials[0];
                    },
                    set: function (newValue) {
                        if (ASSERT) {
                            if (!(newValue instanceof Material)) {
                                Util.fail("MeshRenderer.material must be a kick.material.Material");
                            }
                        }
                        if (_materials.length > 0){
                            _materials[0].removeEventListener("shaderChanged", updateRenderOrder);
                        }
                        _materials[0] = newValue;
                        _materials[0].addEventListener("shaderChanged", updateRenderOrder);
                        _renderOrder = _materials[0].renderOrder;
                        thisObj.fireEvent("componentUpdated", this);
                    }
                },
                /**
                 *
                 * @property materias
                 * @type Array_kick.material.Material
                 */
                materials: {
                    get: function () {
                        return _materials;
                    },
                    set: function (newValue) {
                        var i;
                        for (i = 0;i < _materials.length; i++){
                            _materials[i].removeEventListener("shaderChanged", updateRenderOrder);
                        }
                        _materials = [];
                        for (i = 0; i < newValue.length; i++) {
                            if (ASSERT) {
                                if (!(newValue[i] instanceof Material)) {
                                    Util.fail("MeshRenderer.material must be a kick.material.Material");
                                }
                            }
                            _materials[i] = newValue[i];
                            _materials[i].addEventListener("shaderChanged", updateRenderOrder);
                        }
                        thisObj.fireEvent("componentUpdated", this);
                    },
                    enumerable: true
                },
                /**
                 * @property mesh
                 * @type kick.mesh.Mesh
                 */
                mesh: {
                    get: function () {
                        return _mesh;
                    },
                    set: function (newValue) {
                        if (ASSERT) {
                            if (!(newValue instanceof Mesh)) {
                                Util.fail("MeshRenderer.mesh must be a kick.mesh.Mesh");
                            }
                        }
                        _mesh = newValue;
                    },
                    enumerable: true
                },
                /**
                 * Name of the component type = "meshRenderer".
                 * @example
                 *      var meshRenderer = gameObject.meshRenderer;
                 * @property componentType
                 * @type String
                 * @final
                 */
                componentType: {value:"meshRenderer"}
            });

            /**
             * This method may not be called (the renderer could make the same calls)
             * @method render
             * @param {kick.scene.EngineUniforms} engineUniforms
             * @param {kick.material.Material} [overwriteMaterial]
             */
            this.render = function (engineUniforms, overwriteMaterial) {
                var length = _materials.length,
                    i,
                    shader;
                if (overwriteMaterial) {
                    shader = overwriteMaterial.shader;
                    for (i = 0; i < length; i++) {
                        _mesh.bind(shader);
                        shader.bindUniform(overwriteMaterial, engineUniforms, transform);
                        _mesh.render(i);
                    }
                } else {
                    for (i = 0; i < length; i++) {
                        shader = _materials[i].shader;
                        _mesh.bind(shader);
                        shader.bindUniform(_materials[i], engineUniforms, transform);
                        _mesh.render(i);
                    }
                }
            };

            /**
             * @method toJSON
             * @return {JSON}
             */
            this.toJSON = function () {
                if (!thisObj.gameObject) {
                    return null; // component is destroyed
                } else {
                    return Util.componentToJSON(this, "kick.scene.MeshRenderer");
                }
            };

            Util.applyConfig(this, config);
        };

    });

define('kick/scene/PickResult',["./MeshRenderer", "kick/material/Material", "kick/core/Constants", "kick/core/EngineSingleton", "kick/core/Util", "kick/math/Vec4", "kick/math/Vec3", "kick/math/Vec2"],
    function (MeshRenderer, Material, Constants, EngineSingleton, Util, vec4, vec3, vec2) {
        

        /**
         * Result of Camera.pickPoint.
         * @example
         *      function SomeComponent() {
         *           var engine = kick.core.Engine.instance,
         *              mouseInput = engine.mouseInput,
         *              camera;
         *           this.activated = function () {
         *              camera = engine.activeScene.findComponentsOfType(kick.scene.Camera)[0];
         *           };
         *
         *           this.update = function () {
         *              var objectPicked = function (pickResult) {
         *                    console.log("UV", pickResult.uv, "Normal", pickResult.normal, "distance",
         *                              pickResult.distance, "point", pickResult.point);
         *                };
         *                if (mouseInput.isButtonUp(0)) {
         *                    camera.pickPoint(objectPicked, mouseInput.mousePosition[0], mouseInput.mousePosition[1]);
         *                }
         *           };
         *       };
         * @class PickResult
         * @namespace kick.scene
         * @constructor
         * @param {kick.texture.RenderTexture} pickingRenderTarget
         * @param {kick.scene.GameObject} gameObject
         * @param {Integer} x
         * @param {Integer} y
         * @param {EngineUniforms} engineUniforms
         * @param {kick.scene.Camera} camera
         * @constructor
         */
        return function (pickingRenderTarget, gameObject, x, y, engineUniforms, camera) {
            if (true) {
                if (pickingRenderTarget === EngineSingleton.engine) {
                    Util.fail("PickResult constructor changed - engine parameter is removed");
                }
            }
            var normal,
                uv,
                depth,
                engine = EngineSingleton.engine,
                /**
                 * @private
                 * @method renderObjectWithShader
                 * @param {kick.material.Shader} shader
                 * @return kick.math.Vec4
                 */
                renderObjectWithShader = function (shader) {
                    var array = new Uint8Array(4),
                        meshRenderers = gameObject.getComponentsWithMethod("render"),
                        i,
                        material = new Material({
                            name: "PickResult",
                            shader: shader
                        });
                    camera.setupCamera();
                    pickingRenderTarget.bind();
                    engine.gl.clear(16384 | 256);
                    for (i = 0; i < meshRenderers.length; i++) {
                        meshRenderers[i].render(engineUniforms, material);
                    }
                    engine.gl.pixelStorei(3333, 1);
                    engine.gl.readPixels(x, y, 1, 1, 6408, 5121, array);
                    pickingRenderTarget.unbind();
                    return array;
                },
                readNormal = function () {
                    var shader = engine.project.load(engine.project.ENGINE_SHADER___PICK_NORMAL);
                    normal = renderObjectWithShader(shader);
                    // normal = (normal / 255 - 0.5) * 2
                    normal = vec3.scale(vec3.create(), normal, 1 / 255);
                    vec3.add(normal, normal, [-0.5, -0.5, -0.5]);
                    vec3.scale(normal, normal, 2);
                },
                readUV = function () {
                    var shader = engine.project.load(engine.project.ENGINE_SHADER___PICK_UV);
                    uv = renderObjectWithShader(shader);
                    uv = vec2.scale(vec2.create(), uv, 1 / 255);
                },
                readDepth = function () {
                    var shader = engine.project.load(engine.project.ENGINE_SHADER___SHADOWMAP),
                        depthPacked = renderObjectWithShader(shader),
                        bit_shift = [1 / (16777216 * 255), 1 / (65536 * 255), 1 / (256 * 255), 1 / 255];
                    depth = vec4.dot(depthPacked, bit_shift);
                };


            Object.defineProperties(this, {
                /**
                 * Reference to the found gameObject
                 * @property gameObject
                 * @type kick.scene.GameObject
                 */
                gameObject: {
                    value: gameObject
                },
                /**
                 * The x value of the pick
                 * @property x
                 * @type Number
                 */
                x: {
                    value: x
                },
                /**
                 * The y value of the pick
                 * @property y
                 * @type Number
                 */
                y: {
                    value: y
                },
                /**
                 * The normal (in object coordinates) at the pick point
                 * @property normal
                 * @type kick.math.Vec3
                 */
                normal: {
                    get: function () {
                        if (!normal) {
                            readNormal();
                        }
                        return normal;
                    }
                },
                /**
                 * The uv of the pick point
                 * @property uv
                 * @type kick.math.Vec2
                 */
                uv: {
                    get: function () {
                        if (!uv) {
                            readUV();
                        }
                        return uv;
                    }
                },
                /**
                 * The distance of the pick point to the camera
                 * @property distance
                 * @type Number
                 */
                distance : {
                    get: function () {
                        if (!depth) {
                            readDepth();
                        }
                        var zFar = camera.far,
                            zNear = camera.near;

                        return 2 * zFar * zNear / (zFar + zNear - (zFar - zNear) * (2 * depth - 1));
                    }
                },
                /**
                 * The 3D point in world coordinates of the selected point
                 * @property point
                 * @type kick.math.Vec3
                 */
                point: {
                    get: function () {
                        if (!depth) {
                            readDepth();
                        }
                        return vec3.unproject(vec3.create(), [x, y, depth], engineUniforms.viewMatrix, engineUniforms.projectionMatrix, camera.viewportRect);
                    }
                }
            });
        };
    });

define('kick/scene/CameraPicking',["kick/math/Vec4", "kick/material/Material", "kick/texture/RenderTexture", "kick/core/Constants", "kick/core/Util", "./PickResult", "kick/core/EngineSingleton"],
    function (Vec4, Material, RenderTexture, Constants, Util, PickResult, EngineSingleton) {
        

        /**
         * Camera picking object used by Camera objects to manage picking
         * @private
         * @class CameraPicking
         * @param {Function} setupClearColor
         * @param {Function} renderSceneObjects
         * @param {Scene} sceneObj
         * @param {kick.scene.Camera} camera
         * @constructor
         */
        return function (setupClearColor, renderSceneObjects, sceneObj, camera) {
            if (true) {
                if (setupClearColor === EngineSingleton.engine) {
                    Util.fail("CameraPicking constructor changed - engine parameter is removed");
                }
            }
            var engine = EngineSingleton.engine,
                pickingQueue = null,
                pickingMaterial = null,
                pickingRenderTarget = null,
                pickingClearColor = Vec4.create(),
                glState = engine.glState,
                i,
                size = new Float32Array(glState.viewportSize),
                canvasResizedListener = function(newCanvasDimensions){
                    size = new Float32Array(newCanvasDimensions);
                },
                init = function () {
                    pickingQueue = [];
                    pickingMaterial = new Material(
                        {
                            shader: engine.project.load(engine.project.ENGINE_SHADER___PICK),
                            name: "Picking material"
                        }
                    );
                    pickingRenderTarget = new RenderTexture({
                        dimension: size
                    });
                    engine.addEventListener("canvasResized",canvasResizedListener);
                    pickingRenderTarget.name = "__pickRenderTexture";
                };

            init();

            /**
             * @method destroy
             */
            this.destroy = function(){
                engine.removeEventListener("canvasResized",canvasResizedListener);
                if (pickingRenderTarget){
                    pickingRenderTarget.destroy();
                    pickingRenderTarget = null;
                }
            };

            /**
             * Add an object to the picking queue.
             * Picking object must have the signature
             * {gameObjectPickedFn: gameObjectPickedFn,
             * x: x,
             * y: glState.viewportSize[1] - y,
             * width: 1,
             * height: 1,
             * point: true
             * }
             * @method add
             * @param {Object} pickingObject
             */
            this.add = function (pickingObject) {
                pickingQueue.push(pickingObject);
            };

            /**
             * @method handlePickRequests
             * @param {kick.scene.SceneLights} sceneLightObj
             * @param {kick.scene.EngineUniforms} engineUniforms
             */
            this.handlePickRequests = function (sceneLightObj, engineUniforms) {
                if (pickingQueue.length > 0) {
                    if (pickingRenderTarget.dimension[0] !== size[0] ||
                        pickingRenderTarget.dimension[1] !== size[1]){
                        pickingRenderTarget.dimension = size;
                    }
                    glState.currentMaterial = null; // clear current material
                    pickingRenderTarget.bind();
                    setupClearColor(pickingClearColor);
                    engine.gl.clear(16384 | 256);
                    engine.gl.pixelStorei(3333, 1);
                    renderSceneObjects(sceneLightObj, pickingMaterial);
                    for (i = pickingQueue.length - 1; i >= 0; i--) {
                        // create clojure
                        (function () {
                            var pick = pickingQueue[i],
                                pickArrayLength = pick.width * pick.width * 4,
                                array = new Uint8Array(pickArrayLength),
                                objects = [],
                                objectCount = {},
                                j,
                                subArray,
                                uid,
                                foundObj;
                            engine.gl.readPixels(pick.x, pick.y, pick.width, pick.height, 6408, 5121, array);
                            for (j = 0; j < pickArrayLength; j += 4) {
                                subArray = array.subarray(j, j + 4);
                                uid = Util.vec4uint8ToUint32(subArray);
                                if (uid > 0) {
                                    if (objectCount[uid]) {
                                        objectCount[uid]++;
                                    } else {
                                        foundObj = sceneObj.getObjectByUID(uid);
                                        if (foundObj) {
                                            if (pick.point) {
                                                foundObj = new PickResult(pickingRenderTarget, foundObj, pick.x, pick.y, engineUniforms, camera);
                                            }
                                            objects.push(foundObj);
                                            objectCount[uid] = 1;
                                        }
                                    }
                                }
                            }
                            if (objects.length) {
                                engine.eventQueue.add(function () {
                                    var i,
                                        obj;
                                    for (i = 0; i < objects.length; i++) {
                                        obj = objects[i];
                                        pick.gameObjectPickedFn(obj, objectCount[obj.uid]);
                                    }
                                }, 0);
                            }
                        }());
                    }
                    pickingQueue.length = 0;
                    pickingRenderTarget.unbind();
                }
            };
        };

    });

define('kick/scene/Camera',["kick/core/Constants", "kick/core/Util", "kick/math/Quat", "kick/math/Mat4", "kick/math/Vec4", "kick/math/Vec3", "kick/math/Aabb", "kick/math/Frustum", "./EngineUniforms", "./CameraPicking", "kick/material/Material", "kick/texture/RenderTexture", "kick/core/EngineSingleton", "kick/core/Observable"],
    function (Constants, Util, Quat, Mat4, Vec4, Vec3, Aabb, Frustum, EngineUniforms, CameraPicking, Material, RenderTexture, EngineSingleton, Observable) {
        

        /**
         * @module kick.scene
         */

        var DEBUG = true,
            ASSERT = true,
            Camera;

        /**
         * Creates a game camera
         * @example
         *     // create a game object in [0,0,0] facing down the -z axis
         *     var cameraObject = engine.activeScene.createGameObject();
         *     cameraObject.transform.position = [0,0,5];
         *     // create a orthographic camera
         *     var camera = new kick.scene.Camera({
         *          perspective: false,
         *          left:-5,
         *          right:5,
         *          top:5,
         *          bottom:-5
         *     });
         *     cameraObject.addComponent(camera);
         *
         * @class Camera
         * @namespace kick.scene
         * @extends kick.scene.Component
         * @constructor
         * @param {Config} configuration with same properties as the Camera
         */
        Camera = function (config) {
            var gl,
                glState,
                thisObj = this,
                transform,
                engine = EngineSingleton.engine,
                _enabled = true,
                c = Constants,
                _renderShadow = false,
                _renderTarget = null,
                _fieldOfView = 60 * 0.01745329251994,
                _near = 0.1,
                _far = 1000,
                _left = -1,
                _right = 1,
                _bottom = -1,
                _top = 1,
                _clearColor = Vec4.clone([0, 0, 0, 1]),
                _shadowmapClearColor = Vec4.clone([1, 1, 1, 1]),
                _perspective = true,
                _clearFlagColor = true,
                _clearFlagDepth = true,
                _replacementMaterial = null,
                _currentClearFlags,
                _cameraIndex = 1,
                _layerMask = 0xffffffff,
                _shadowmapMaterial,
                _scene,
                pickingObject = null,
                projectionMatrix = Mat4.create(),
                viewMatrix = Mat4.create(),
                viewProjectionMatrix = Mat4.create(),
                lightMatrix = Mat4.create(),
                engineUniforms = new EngineUniforms({
                    viewMatrix: viewMatrix,
                    projectionMatrix: projectionMatrix,
                    viewProjectionMatrix: viewProjectionMatrix,
                    lightMatrix: lightMatrix,
                    currentCamera: thisObj,
                    currentCameraTransform: null
                }),
                isContextListenerRegistered = false,
                contextLost = function () {
                    gl = null;
                },
                contextRestored = function (newGL) {
                    gl = newGL;
                },
                renderableComponentsBackGroundAndGeometry = [],
                renderableComponentsTransparent = [],
                renderableComponentsOverlay = [],
                renderableComponentsArray = [renderableComponentsBackGroundAndGeometry, renderableComponentsTransparent, renderableComponentsOverlay],
                _normalizedViewportRect = Vec4.clone([0, 0, 1, 1]),
                offsetMatrix = Mat4.clone([
                    0.5, 0, 0, 0,
                    0, 0.5, 0, 0,
                    0, 0, 0.5, 0,
                    0.5, 0.5, 0.5, 1
                ]),
                shadowLightProjection,
                shadowLightOffsetFromCamera,
                isNumber = function (o) {
                    return typeof o === "number";
                },
                isBoolean = function (o) {
                    return typeof o === "boolean";
                },
                computeClearFlag = function () {
                    _currentClearFlags = (_clearFlagColor ? 16384 : 0) | (_clearFlagDepth ? 256 : 0);
                },
                setupClearColor = function (color) {
                    if (glState.currentClearColor !== color) {
                        glState.currentClearColor = color;
                        gl.clearColor(color[0], color[1], color[2], color[3]);
                    }
                },
                assertNumber = function (newValue, name) {
                    if (!isNumber(newValue)) {
                        Util.fail("Camera." + name + " must be number");
                    }
                },
                setupViewport = function (offsetX, offsetY, width, height) {
                    gl.viewport(offsetX, offsetY, width, height);
                    gl.scissor(offsetX, offsetY, width, height);
                },
                /**
                 * Compare two objects based on renderOrder value, then on material.shader.uid (if exist)
                 * and finally on mesh.
                 * @method compareRenderOrder
                 * @param {Component} a
                 * @param {Component} b
                 * @return Number
                 * @private
                 */
                compareRenderOrder = function (a, b) {
                    var aRenderOrder = a.renderOrder || 1000,
                        bRenderOrder = b.renderOrder || 1000,
                        getMeshUid,
                        getMeshShaderUid = function (o, defaultValue) {
                            var names = ["material", "shader", "uid"],
                                i;
                            for (i = 0; i < names.length; i++) {
                                o = o[names[i]];
                                if (!o) {
                                    if (DEBUG) {
                                        Util.warn("Cannot find uid of " + o);
                                    }
                                    return defaultValue;
                                }
                            }
                            return o;
                        };
                    getMeshUid = function (o, defaultValue) {
                        return o.mesh.uid || defaultValue;
                    };
                    if (aRenderOrder === bRenderOrder && a.material && b.material) {
                        aRenderOrder = getMeshShaderUid(a, aRenderOrder);
                        bRenderOrder = getMeshShaderUid(b, aRenderOrder);
                    }
                    if (aRenderOrder === bRenderOrder && a.mesh && b.mesh) {
                        aRenderOrder = getMeshUid(a, aRenderOrder);
                        bRenderOrder = getMeshUid(b, aRenderOrder);
                    }
                    return aRenderOrder - bRenderOrder;
                },
                sortTransparentBackToFront = function () {
                    // calculate distances
                    var temp = Vec3.create(),
                        cameraPosition = transform.position,
                        i,
                        object,
                        objectPosition;
                    for (i = renderableComponentsTransparent.length - 1; i >= 0; i--) {
                        object = renderableComponentsTransparent[i];
                        objectPosition = object.gameObject.transform.position;
                        object.distanceToCamera = Vec3.squaredLength(Vec3.subtract(temp, objectPosition, cameraPosition));
                    }
                    function compareDistanceToCamera(a, b) {
                        return b.distanceToCamera - a.distanceToCamera;
                    }
                    renderableComponentsTransparent.sort(compareDistanceToCamera);
                },
                /**
                 * @method renderSceneObjects
                 * @param sceneLightObj
                 * @param shader
                 * @private
                 */
                renderSceneObjects = (function () {
                    var aabbWorldSpace = Aabb.create(),
                        frustumPlanes = new Float32Array(24);
                    return function (sceneLightObj, replacementMaterial) {
                        var cullByViewFrustum = function (component) {
                                var componentAabb = component.aabb,
                                    gameObject = component.gameObject;
                                if (componentAabb && gameObject) {
                                    Aabb.transform(aabbWorldSpace, componentAabb, gameObject.transform.getGlobalMatrix());
                                    return Frustum.intersectAabb(frustumPlanes, aabbWorldSpace) === Frustum.OUTSIDE;
                                }
                                return false;
                            },
                            render = function (renderableComponents) {
                                var length = renderableComponents.length,
                                    j,
                                    renderableComponent;
                                for (j = 0; j < length; j++) {
                                    renderableComponent = renderableComponents[j];
                                    if (!cullByViewFrustum(renderableComponent)) {
                                        renderableComponent.render(engineUniforms, replacementMaterial);
                                    }
                                }
                            };
                        // update frustum planes
                        Frustum.extractPlanes(frustumPlanes, engineUniforms.viewProjectionMatrix, false);
                        engineUniforms.sceneLights = sceneLightObj;
                        render(renderableComponentsBackGroundAndGeometry);
                        render(renderableComponentsTransparent);
                        render(renderableComponentsOverlay);
                    };
                }()),
                renderShadowMap = function (sceneLightObj) {
                    var directionalLight = sceneLightObj.directionalLight,
                        directionalLightTransform = directionalLight.gameObject.transform,
                        shadowRenderTexture = directionalLight.shadowRenderTexture,
                        renderTextureDimension = shadowRenderTexture.dimension,
                        renderTextureWidth = renderTextureDimension[0],
                        renderTextureHeight = renderTextureDimension[1],
                        transformedOffsetFromCamera = Vec3.create(),
                        cameraPosition = Vec3.create();
                    setupViewport(0, 0, renderTextureWidth, renderTextureHeight);

                    shadowRenderTexture.bind();
                    setupClearColor(_shadowmapClearColor);
                    gl.clear(16384 | 256);

                    // fitting:
                    // Using a sphere with the center in front of the camera (based on 0.5 * engine.config.shadowDistance)
                    // The actual light volume is a bit larger than the sphere (to include the corners).
                    // The near plane of the light volume is extended by the engine.config.shadowNearMultiplier
                    // Note that this is a very basic fitting algorithm with rooms for improvement
                    Mat4.copy(projectionMatrix, shadowLightProjection);

                    // find the position of the light 'center' in world space
                    transformedOffsetFromCamera = Quat.multiplyVec3(transformedOffsetFromCamera, transform.rotation, [0, 0, -shadowLightOffsetFromCamera]);
                    cameraPosition = Vec3.add(cameraPosition, transformedOffsetFromCamera, transform.position);
                    // adjust to reduce flicker when rotating camera
                    cameraPosition[0] = Math.round(cameraPosition[0]);
                    cameraPosition[1] = Math.round(cameraPosition[1]);
                    cameraPosition[2] = Math.round(cameraPosition[2]);

                    Mat4.setTRSInverse(viewMatrix, cameraPosition, directionalLightTransform.localRotation, [1, 1, 1]);

                    Mat4.multiply(viewProjectionMatrix, projectionMatrix, viewMatrix);

                    // update light matrix (will be used when scene is rendering with shadow map shader)
                    Mat4.multiply(lightMatrix, Mat4.multiply(lightMatrix, offsetMatrix, projectionMatrix), viewMatrix);

                    renderSceneObjects(sceneLightObj, _shadowmapMaterial);
                    shadowRenderTexture.unbind();
                },

                /**
                 * Add components that implements the render function and match the camera layerMask to cameras renderable components
                 * @method componentAdded
                 * @param {kick.scene.Component} component
                 * @private
                 */
                componentAdded = function (component) {
                    var renderOrder,
                        array;
                    if (ASSERT){
                        if (Array.isArray(component)){
                            Util.fail("Should be array");
                        }
                    }
                    if (typeof component.render === "function" && (component.gameObject.layer & _layerMask)) {
                        renderOrder = component.renderOrder || 1000;
                        if (renderOrder < 2000) {
                            array = renderableComponentsBackGroundAndGeometry;
                        } else if (renderOrder >= 3000) {
                            array = renderableComponentsOverlay;
                        } else {
                            array = renderableComponentsTransparent;
                        }
                        if (!Util.contains(array, component)) {
                            Util.insertSorted(component, array, compareRenderOrder);
                            if (component.addEventListener) {
                                component.addEventListener('componentUpdated', componentUpdated);
                            }
                        }
                    }
                },

                /**
                 * @method componentRemoved
                 * @param {kick.scene.Component} component
                 * @return {Boolean}
                 * @private
                 */
                componentRemoved = function (component) {
                    var removed = false,
                        j;
                    if (ASSERT){
                        if (Array.isArray(component)){
                            Util.fail("Should be array");
                        }
                    }
                    if (typeof (component.render) === "function") {
                        for (j = renderableComponentsArray.length - 1; j >= 0; j--) {
                            removed |= Util.removeElementFromArray(renderableComponentsArray[j], component);
                        }
                    }
                    if (removed) {
                        if (component.removeEventListener){
                            component.removeEventListener('componentUpdated', componentUpdated);
                        }
                    }
                    return removed;
                },
                componentUpdated = function (component) {
                    componentRemoved(component);
                    componentAdded(component);
                },
                initShadowMap = function(){
                    var shadowRadius,
                        nearPlanePosition,
                        _shadowmapShader,
                        materialConfig;

                    _shadowmapShader = engine.project.load(engine.project.ENGINE_SHADER___SHADOWMAP);
                    materialConfig = {
                        name: "Shadow map material",
                        shader: _shadowmapShader
                    };
                    _shadowmapMaterial = new Material(materialConfig);

                    // calculate the shadow projection based on engine.config parameters
                    shadowLightOffsetFromCamera = engine.config.shadowDistance * 0.5; // first find radius
                    shadowRadius = shadowLightOffsetFromCamera * 1.55377397403004; // sqrt(2+sqrt(2))
                    nearPlanePosition = -shadowRadius * engine.config.shadowNearMultiplier;
                    shadowLightProjection = Mat4.create();
                    Mat4.ortho(shadowLightProjection, -shadowRadius, shadowRadius, -shadowRadius, shadowRadius,
                        nearPlanePosition, shadowRadius);
                };

            /**
             * Schedules a camera picking session. During next repaint a picking session is done. If the pick hits some
             * game objects, then a callback is added to the event queue (and will run in next frame). The pickObject can
             * be used for getting UV coordinate for the point (if available)
             * @method pickPoint
             * @param {function} gameObjectPickedFn callback function with the signature function(pickObject)
             * @param {Number} x coordinate in screen coordinates (between 0 and canvas width - 1)
             * @param {Number} y coordinate in screen coordinates (between 0 and canvas height - 1)
             */
            this.pickPoint = function (gameObjectPickedFn, x, y) {
                if (!pickingObject) {
                    pickingObject = new CameraPicking(setupClearColor, renderSceneObjects, _scene, thisObj);
                }
                pickingObject.add({
                    gameObjectPickedFn: gameObjectPickedFn,
                    x: x,
                    y: glState.viewportSize[1] - y,
                    width: 1,
                    height: 1,
                    point: true
                });
            };

            /**
             * Schedules a camera picking session. During next repaint a picking session is done. If the pick hits some
             * game objects, then a callback is added to the event queue (and will run in next frame).
             * Note since the WebGL window coordinate has the origin in the lower left corner and browsers coordinate
             * system has the origin in the upper left corner, you may need to compute y as canvas.height - mouseCoordinate.y
             * @method pick
             * @param {function} gameObjectPickedFn callback function with the signature function(gameObject, hitCount)
             * @param {Number} x coordinate in screen coordinates (between 0 and canvas width - 1)
             * @param {Number} y coordinate in screen coordinates (between 0 and canvas height - 1)
             * @param {Number} [width=1]
             * @param {Number} [height=1]
             */
            this.pick = function (gameObjectPickedFn, x, y, width, height) {
                width = width || 1;
                height = height || 1;
                if (!pickingObject) {
                    pickingObject = new CameraPicking(setupClearColor, renderSceneObjects, _scene);
                }
                pickingObject.add({
                    gameObjectPickedFn: gameObjectPickedFn,
                    x: x,
                    y: y,
                    width: width,
                    height: height
                });
            };

            Observable.call(this, [
            /**
             * Fired every frame when camera render is done
             * @event postRender
             * @param {kick.scene.Camera} camera
             */
                "postRender"
            ]
            );

            /**
             * Clear the screen and set the projectionMatrix and modelViewMatrix on the glState object.
             * Called during renderScene
             * @method setupCamera
             */
            this.setupCamera = function () {
                var viewportDimension = _renderTarget ? _renderTarget.dimension : glState.viewportSize,
                    viewPortWidth = viewportDimension[0],
                    viewPortHeight = viewportDimension[1],
                    offsetX = viewPortWidth * _normalizedViewportRect[0],
                    offsetY = viewPortHeight * _normalizedViewportRect[1],
                    width = viewPortWidth * _normalizedViewportRect[2],
                    height = viewPortHeight * _normalizedViewportRect[3],
                    globalMatrixInv;
                setupViewport(offsetX, offsetY, width, height);
                glState.currentMaterial = null; // clear current material

                setupClearColor(_clearColor);
                gl.clear(_currentClearFlags);

                if (_perspective) {
                    Mat4.perspective(projectionMatrix, _fieldOfView, glState.viewportSize[0] / glState.viewportSize[1],
                        _near, _far);
                } else {
                    Mat4.ortho(projectionMatrix, _left, _right, _bottom, _top,
                        _near, _far);
                }

                globalMatrixInv = transform.getGlobalTRSInverse();
                Mat4.copy(viewMatrix, globalMatrixInv);

                Mat4.multiply(viewProjectionMatrix, projectionMatrix, viewMatrix);

            };

            /**
             * Handles the camera setup (get fast reference to transform and glcontext).
             * Also register component listener on scene
             * @method activated
             */
            this.activated = function () {
                var gameObject = this.gameObject,
                    componentsWithRender,
                    i;
                engineUniforms.currentCameraTransform = gameObject.transform;
                if (!isContextListenerRegistered) {
                    isContextListenerRegistered = true;
                    engine.addEventListener('contextLost', contextLost);
                    engine.addEventListener('contextRestored', contextRestored);
                }
                transform = gameObject.transform;
                gl = engine.gl;
                glState = engine.glState;
                _scene = gameObject.scene;
                renderableComponentsBackGroundAndGeometry.length = 0;
                renderableComponentsTransparent.length = 0;
                renderableComponentsOverlay.length = 0;
                _scene.addEventListener('componentAdded', componentAdded);
                _scene.addEventListener('componentRemoved', componentRemoved);
                // add current components in scene
                componentsWithRender = _scene.findComponentsWithMethod("render");
                for (i = 0; i < componentsWithRender.length; i++) {
                    componentAdded(componentsWithRender[i]);
                }

                // init shadowmap
                if (engine.config.shadows) {
                    initShadowMap();
                } else if (_renderShadow) {
                    _renderShadow = false; // disable render shadow
                    if (ASSERT) {
                        Util.fail("engine.config.shadows must be enabled for shadows");
                    }
                }
            };

            /**
             * Deregister component listener on scene
             * @method deactivated
             */
            this.deactivated = function () {
                _scene.removeComponentListener(thisObj);
            };

            /**
             * @method renderScene
             * @param {kick.scene.SceneLights} sceneLightObj
             */
            this.renderScene = function (sceneLightObj) {
                var i,
                    textureId;
                if (!_enabled) {
                    return;
                }
                if (_renderShadow && sceneLightObj.directionalLight && sceneLightObj.directionalLight.shadow) {
                    glState.currentMaterial = null; // clear current material
                    renderShadowMap(sceneLightObj);
                }
                // setup render target
                if (_renderTarget) {
                    _renderTarget.bind();
                }
                thisObj.setupCamera();

                sceneLightObj.recomputeLight(viewMatrix);
                if (renderableComponentsTransparent.length > 0) {
                    sortTransparentBackToFront();
                }
                renderSceneObjects(sceneLightObj, _replacementMaterial);

                if (_renderTarget) {
                    _renderTarget.unbind();
                }
                if (_renderTarget && _renderTarget.colorTexture && _renderTarget.colorTexture.generateMipmaps) {
                    textureId = _renderTarget.colorTexture.textureId;
                    gl.bindTexture(gl.TEXTURE_2D, textureId);
                    gl.generateMipmap(gl.TEXTURE_2D);
                }
                if (pickingObject) {
                    pickingObject.handlePickRequests(sceneLightObj, engineUniforms);
                }
                thisObj.fireEvent("postRender", thisObj);
            };

            Object.defineProperties(this, {
                /**
                 * Allows usage of replacement material on camera rendering
                 * Default value is null.
                 * @property replacementMaterial
                 * @type kick.material.Shader
                 */
                replacementMaterial: {
                    get: function () { return _replacementMaterial; },
                    set: function (newValue) { _replacementMaterial = newValue; }
                },
                /**
                 * Default is true
                 * @property enabled
                 * @type Boolean
                 */
                enabled: {
                    get: function () { return _enabled; },
                    set: function (newValue) { _enabled = newValue; }
                },
                /**
                 * Default false
                 * @property renderShadow
                 * @type Boolean
                 */
                renderShadow: {
                    get: function () { return _renderShadow; },
                    set: function (newValue) {
                        if (engine) { // if object is initialized
                            if (engine.config.shadows) {
                                _renderShadow = newValue;
                            } else if (newValue) {
                                if (ASSERT) {
                                    Util.fail("engine.config.shadows must be enabled for shadows");
                                }
                            }
                        } else {
                            _renderShadow = newValue;
                        }
                    }
                },
                /**
                 * Camera renders only objects where the components layer exist in the layer mask. <br>
                 * @property layerMask
                 * @type Number
                 */
                layerMask: {
                    get: function () { return _layerMask; },
                    set: function (newValue) {
                        if (true) {
                            if (!isNumber(newValue)) {
                                Util.fail("Camera.layerMask should be a number");
                            }
                        }
                        _layerMask = newValue;
                    }
                },
                /**
                 * Set the render target of the camera. Null means screen framebuffer.<br>
                 * @property renderTarget
                 * @type kick.texture.RenderTexture
                 */
                renderTarget: {
                    get: function () { return _renderTarget; },
                    set: function (newValue) {
                        if (true) {
                            if (newValue !== null && !(newValue instanceof RenderTexture)) {
                                Util.fail("Camera.renderTarget should be null or a kick.texture.RenderTexture");
                            }
                        }
                        _renderTarget = newValue;
                    }
                },
                /**
                 * Set the field of view Y in degrees<br>
                 * Only used when perspective camera type. Default 60.0.
                 * Must be between 1 and 179
                 * @property fieldOfView
                 * @type Number
                 */
                fieldOfView: {
                    get: function () { return _fieldOfView * 57.2957795130824; },
                    set: function (newValue) {
                        if (true) {
                            assertNumber(newValue, "fieldOfView");
                        }
                        _fieldOfView = Math.min(179, Math.max(newValue, 1)) * 0.01745329251994;
                    }
                },
                /**
                 * Set the near clipping plane of the view volume<br>
                 * Used in both perspective and orthogonale camera.<br>
                 * Default 0.1
                 * @property near
                 * @type Number
                 */
                near: {
                    get: function () {
                        return _near;
                    },
                    set: function (newValue) {
                        if (true) {
                            assertNumber(newValue, "near");
                        }
                        _near = newValue;
                    }
                },
                /**
                 * Set the far clipping plane of the view volume<br>
                 * Used in both perspective and orthogonale camera.<br>
                 * Default 1000.0
                 * @property far
                 * @type Number
                 */
                far: {
                    get: function () {
                        return _far;
                    },
                    set: function (newValue) {
                        if (true) {
                            assertNumber(newValue, "far");
                        }
                        _far = newValue;
                    }
                },
                /**
                 * True means camera is perspective projection, false means orthogonale projection<br>
                 * Default true
                 * @property perspective
                 * @type Boolean
                 */
                perspective: {
                    get: function () {
                        return _perspective;
                    },
                    set: function (newValue) {
                        if (true) {
                            if (!isBoolean(newValue)) {
                                Util.fail("Camera.perspective must be a boolean");
                            }
                        }
                        _perspective = newValue;
                    }
                },
                /**
                 * Only used for orthogonal camera type (!cameraTypePerspective). Default -1
                 * @property left
                 * @type Number
                 */
                left: {
                    get: function () {
                        return _left;
                    },
                    set: function (newValue) {
                        if (true) {
                            assertNumber(newValue, "left");
                        }
                        _left = newValue;
                    }
                },
                /**
                 * Only used for orthogonal camera type (!cameraTypePerspective). Default 1
                 * @property right
                 * @type Number
                 */
                right: {
                    get: function () {
                        return _right;
                    },
                    set: function (newValue) {
                        if (true) {
                            assertNumber(newValue, "right");
                        }
                        _right = newValue;
                    }
                },
                /**
                 * Only used when orthogonal camera type (!cameraTypePerspective). Default -1
                 * @property bottom
                 * @type Number
                 */
                bottom: {
                    get: function () {
                        return _bottom;
                    },
                    set: function (newValue) {
                        if (true) {
                            assertNumber(newValue, "bottom");
                        }
                        _bottom = newValue;
                    }
                },
                /**
                 * Only used when orthogonal camera type (!cameraTypePerspective). Default 1
                 * @property top
                 * @type Number
                 */
                top: {
                    get: function () {
                        return _top;
                    },
                    set: function (newValue) {
                        if (true) {
                            assertNumber(newValue, "top");
                        }
                        _top = newValue;
                    }
                },
                /**
                 * The sorting order when multiple cameras exists in the scene.<br>
                 * Cameras with lowest number is rendered first.
                 * @property cameraIndex
                 * @type Number
                 * @default 1
                 */
                cameraIndex: {
                    get: function () {
                        return _cameraIndex;
                    },
                    set: function (newValue) {
                        if (true) {
                            assertNumber(newValue, "cameraIndex");
                        }
                        _cameraIndex = newValue;
                    }
                },
                /**
                 * Only used when orthogonal camera type (!cameraTypePerspective). Default [0,0,0,1]
                 * @property clearColor
                 * @type kick.math.Vec4
                 */
                clearColor: {
                    get: function () {
                        return Vec4.clone(_clearColor);
                    },
                    set: function (newValue) {
                        _clearColor = Vec4.clone(newValue);
                    }
                },
                /**
                 * Indicates if the camera should clear color buffer.<br>
                 * Default value is true
                 * @property clearFlagColor
                 * @type Boolean
                 */
                clearFlagColor: {
                    get: function () {
                        return _clearFlagColor;
                    },
                    set: function (newValue) {
                        computeClearFlag();
                        _clearFlagColor = newValue;
                    }
                },
                /**
                 * Indicates if the camera should clear the depth buffer.<br>
                 * Default is true.
                 * @property clearFlagDepth
                 * @type Boolean
                 */
                clearFlagDepth: {
                    get: function () {
                        return _clearFlagDepth;
                    },
                    set: function (newValue) {
                        computeClearFlag();
                        _clearFlagDepth = newValue;
                    }
                },
                /**
                 * Normalized viewport rect [xOffset,yOffset,xWidth,yHeight]<br>
                 * Default is [0,0,1,1]
                 * @property normalizedViewportRect
                 * @type Array_Number
                 */
                normalizedViewportRect: {
                    get: function () {
                        return _normalizedViewportRect;
                    },
                    set: function (newValue) {
                        if (true) {
                            if (newValue.length !== 4) {
                                Util.fail("Camera.normalizedViewportRect must be Float32Array of length 4");
                            }
                        }
                        Vec4.copy(_normalizedViewportRect, newValue);
                    }
                },
                /**
                 * Viewport rect [xOffset,yOffset,xWidth,yHeight]
                 * @property viewportRect
                 * @type Array_Number
                 */
                viewportRect: {
                    get: function () {
                        var res = Vec4.clone(_normalizedViewportRect),
                            canvasDimension = engine.canvasDimension;
                        res[0] *= canvasDimension[0];
                        res[2] *= canvasDimension[0];
                        res[1] *= canvasDimension[1];
                        res[3] *= canvasDimension[1];
                        return res;
                    },
                    set: function (value) {
                        if (true) {
                            if (value.length !== 4) {
                                Util.fail("Camera.viewportRect must be Float32Array of length 4");
                            }
                        }
                        var res = Vec4.clone(value),
                            canvasDimension = engine.canvasDimension;
                        res[0] /= canvasDimension[0];
                        res[2] /= canvasDimension[0];
                        res[1] /= canvasDimension[1];
                        res[3] /= canvasDimension[1];
                        Vec4.copy(_normalizedViewportRect, res);
                    }
                },
                /**
                 * Name of the component componentType = "camera".
                 * @example
                 *      var camera = gameObject.camera;
                 * @property componentType
                 * @type String
                 * @final
                 */
                componentType: {value:"camera"}
            });

            /**
             * Destroy camera component
             * @method destroy
             */
            this.destroy = function () {
                if (isContextListenerRegistered) {
                    isContextListenerRegistered = false;
                    engine.removeEventListener('contextLost', contextLost);
                    engine.removeEventListener('contextRestored', contextRestored);
                }
                if (pickingObject) {
                    pickingObject.destroy();
                    pickingObject = null;
                }
            };

            /**
             * Serialize object
             * @method toJSON
             * @return {Object} data object
             */
            this.toJSON = function () {
                return {
                    type: "kick/scene/Camera",
                    uid: thisObj.uid || (engine ? engine.getUID(thisObj) : 0),
                    config: {
                        enabled: _enabled,
                        renderShadow: _renderShadow,
                        layerMask: _layerMask,
                        renderTarget: Util.getJSONReference(_renderTarget),
                        fieldOfView: _fieldOfView,
                        near: _near,
                        far: _far,
                        perspective: _perspective,
                        left: _left,
                        right: _right,
                        bottom: _bottom,
                        top: _top,
                        cameraIndex: _cameraIndex,
                        clearColor: Util.typedArrayToArray(_clearColor),
                        clearFlagColor: _clearFlagColor,
                        clearFlagDepth: _clearFlagDepth,
                        normalizedViewportRect: Util.typedArrayToArray(_normalizedViewportRect)
                    }
                };
            };

            Util.applyConfig(this, config);
            computeClearFlag();
        };

        /**
         * Reset the camera clear flags
         * @method setupClearFlags
         * @param {Boolean} clearColor
         * @param {Boolean} clearDepth
         */
        Camera.prototype.setupClearFlags = function (clearColor, clearDepth) {
            this.clearColor = clearColor;
            this.clearDepth = clearDepth;
            delete this._currentClearFlags;
        };

        return Camera;
    });

define('kick/scene/Light',["kick/core/Constants", "kick/core/Util", "kick/math/Vec3", "kick/texture/Texture", "kick/texture/RenderTexture", "kick/core/EngineSingleton"],
    function (Constants, Util, Vec3, Texture, RenderTexture, EngineSingleton) {
        

        var ASSERT = true,
            Light;

        /**
         * A light object.<br>
         * Note that each scene can only have one ambient light and one directional light.
         * The directional light points in (0,0,1) direction (transformed by the GameObject transform)
         * @example
         *            var lightGameObject = engine.activeScene.createGameObject();
         *            lightGameObject.transform.position = [0,0,10];
         *
         *            // add point light
         *            var lightComponent = new kick.scene.Light({type:kick.scene.Light.TYPE_POINT});
         *            lightGameObject.addComponent(lightComponent);
         *
         *            // add ambient light (only one per scene)
         *            var ambientLightComponent = new kick.scene.Light({type:kick.scene.Light.TYPE_AMBIENT, colorIntensity: [0.1,0.1,0.1] });
         *            lightGameObject.addComponent(ambientLightComponent);
         *
         * @class Light
         * @namespace kick.scene
         * @extends kick.scene.Component
         * @constructor
         * @param {Object} config
         * @final
         */
        Light = function (config) {
            var thisObj = this,
                color = Vec3.clone([1.0, 1.0, 1.0]),
                engine = EngineSingleton.engine,
                type = 3, // point light
                _shadow = false,
                _shadowStrength = 1.0,
                _shadowBias = 0.05,
                _shadowTexture = null,
                _shadowRenderTexture = null,
                attenuation = Vec3.clone([1, 0, 0]),
                intensity = 1,
                transform,
                colorIntensity = Vec3.clone([1.0, 1.0, 1.0]),
                updateIntensity = function () {
                    Vec3.copy(colorIntensity, [color[0] * intensity, color[1] * intensity, color[2] * intensity]);
                },
                gameObject,
                initialized = false,
                scriptPriority,
                updateShadowTexture = function () {
                    if (_shadow) {
                        if (!_shadowTexture) {
                            _shadowTexture = new Texture({
                                minFilter: 9728,
                                magFilter: 9728,
                                wrapS: 33071,
                                wrapT: 33071,
                                flipY: false,
                                generateMipmaps: false
                            });
                            var maxTextureSize = Math.min(engine.gl.getParameter(34024),
                                engine.gl.getParameter(3379));
                            maxTextureSize = Math.min(maxTextureSize, 4096) * engine.config.shadowMapQuality;
                            _shadowTexture.setImageData(maxTextureSize, maxTextureSize, 0, 5121, null, "");
                            _shadowRenderTexture = new RenderTexture({
                                colorTexture: _shadowTexture
                            });
                        }
                    } else if (_shadowRenderTexture) {
                        _shadowRenderTexture.destroy();
                        _shadowTexture.destroy();
                        _shadowRenderTexture = null;
                        _shadowTexture = null;
                    }
                };
            Object.defineProperties(this, {
                /**
                 * Short for lightObj.gameObject.transform
                 * @property transform
                 * @type kick.scene.Transform
                 */
                transform: {
                    get: function () {
                        return transform;
                    }
                },
                /**
                 * @property shadowRenderTexture
                 * @type kick.texture.RenderTexture
                 */
                shadowRenderTexture: {
                    get: function () {
                        return _shadowRenderTexture;
                    }
                },
                /**
                 * @property shadowTexture
                 * @type kick.texture.Texture
                 */
                shadowTexture: {
                    get: function () {
                        return _shadowTexture;
                    }
                },
                /**
                 * Default value is false.
                 * Only directional light supports shadows.
                 * @property shadow
                 * @type boolean
                 * @default false
                 */
                shadow: {
                    get: function () {
                        return _shadow;
                    },
                    set: function (value) {
                        if (value !== _shadow) {
                            _shadow = value;
                            if (initialized) {
                                updateShadowTexture();
                            }
                        }
                    },
                    enumerable: true
                },
                /**
                 * Shadow strength (between 0.0 and 1.0).
                 * @property shadowStrength
                 * @type Number
                 * @default 1.0
                 */
                shadowStrength: {
                    get: function () {
                        return _shadowStrength;
                    },
                    set: function (value) {
                        _shadowStrength = value;
                    },
                    enumerable: true
                },
                /**
                 * Shadow bias.
                 * @property shadowBias
                 * @type Number
                 * @default 0.05
                 */
                shadowBias: {
                    get: function () {
                        return _shadowBias;
                    },
                    set: function (value) {
                        _shadowBias = value;
                    },
                    enumerable: true
                },
                /**
                 * Color intensity of the light (RGB).
                 * @property color
                 * @type kick.math.Vec3
                 * @default [1,1,1]
                 */
                color: {
                    get: function () {
                        return Vec3.clone(color);
                    },
                    set: function (value) {
                        if (ASSERT) {
                            if (value.length !== 3) {
                                Util.fail("Light color must be vec3");
                            }
                        }
                        Vec3.copy(color, value);
                        updateIntensity();
                    },
                    enumerable: true
                },
                /**
                 * Color type. Must be either:<br>
                 * Light.TYPE\_AMBIENT,
                 * Light.TYPE\_DIRECTIONAL,
                 * Light.TYPE\_POINT <br>
                 * Note that this value is readonly after initialization. To change it create a new Light component and replace the current light
                 * component of its gameObject.
                 * @property type
                 * @type Enum
                 * @final
                 * @default Light.TYPE_POINT
                 */
                type: {
                    get: function () {
                        return type;
                    },
                    set: function (newValue) {
                        if (!initialized) {
                            type = newValue;
                        } else {
                            if (ASSERT) {
                                Util.fail("Light type cannot be changed after initialization");
                            }
                        }
                    },
                    enumerable: true
                },
                /**
                 * Light intensity (a multiplier to color)
                 * @property intensity
                 * @type Number
                 * @default 1
                 */
                intensity: {
                    get: function () {
                        return intensity;
                    },
                    set: function (value) {
                        intensity = value;
                        updateIntensity();
                    },
                    enumerable: true
                },
                /**
                 * Specifies the light falloff.<br>
                 * attenuation[0] is constant attenuation,<br>
                 * attenuation[1] is linear attenuation,<br>
                 * attenuation[2] is quadratic attenuation.<br>
                 * @property attenuation
                 * @type kick.math.Vec3
                 * @default [1,0,0]
                 */
                attenuation: {
                    get: function () {
                        return attenuation;
                    },
                    set: function (newValue) {
                        Vec3.copy(attenuation, newValue);
                    },
                    enumerable: true
                },
                /**
                 * color RGB multiplied with intensity (plus color A).<br>
                 * This property exposes a internal value. This value should not be modified.
                 * Instead use the intensity and color property.
                 * @property colorIntensity
                 * @type kick.math.Vec3
                 * @final
                 */
                colorIntensity: {
                    get: function () {
                        return colorIntensity;
                    },
                    set: function (newValue) {
                        colorIntensity = newValue;
                    },
                    enumerable: true
                },
                // inherited interface from component
                gameObject: {
                    get: function () {
                        return gameObject;
                    },
                    set: function (value) {
                        gameObject = value;
                    }
                },
                // inherited interface from component
                scriptPriority: {
                    get: function () {
                        return scriptPriority;
                    },
                    set: function (value) {
                        scriptPriority = value;
                    },
                    enumerable: true
                },
                /**
                 * Name of the component componentType = "meshRenderer".
                 * @example
                 *      var light = gameObject.light;
                 * @property componentType
                 * @type String
                 * @final
                 */
                componentType: {value:"light"}
            });

            this.activated = function () {
                var gameObject = thisObj.gameObject;
                initialized = true;
                transform = gameObject.transform;
                updateShadowTexture();
            };

            /**
             * @method toJSON
             * @return {JSON}
             */
            this.toJSON = function () {
                return Util.componentToJSON(this, "kick.scene.Light");
            };

            Util.applyConfig(this, config);
            Util.copyStaticPropertiesToObject(this, Light);
        };

        /**
         * Used to define ambient color in the scene (indirect lightening)
         * @property TYPE_AMBIENT
         * @type Number
         * @static
         */
        Light.TYPE_AMBIENT = 1;
        /**
         * Used to define directional light in the scene (such as sunlight)
         * @property TYPE_DIRECTIONAL
         * @type Number
         * @static
         */
        Light.TYPE_DIRECTIONAL = 2;
        /**
         * Used to define point light in the scene
         * @property TYPE_POINT
         * @type Number
         * @static
         */
        Light.TYPE_POINT = 3;

        Object.freeze(Light);

        return Light;
    });

define('kick/scene/Transform',["kick/math/Mat4", "kick/math/Vec3", "kick/math/Quat", "kick/core/Constants", "kick/core/Util", "kick/core/EngineSingleton"], function (Mat4, Vec3, Quat, Constants, Util, EngineSingleton) {
    

    var ASSERT = true,
        Transform;

    /**
     * Position, rotation and scale of a game object. This component should not be created manually.
     * It is created when a GameObject is created.
     *
     * KickJS uses a right handed coordinate system.
     * @namespace kick.scene
     * @class Transform
     * @extends kick.scene.Component
     */
    Transform = function () {
        var localMatrix = Mat4.create(),
            globalMatrix = Mat4.create(),
            localMatrixInverse = Mat4.create(),
            globalMatrixInverse = Mat4.create(),
            globalPosition = Vec3.create(),
            localPosition = Vec3.create(),
            globalRotationQuat = Quat.create(),
            localRotationQuat = Quat.create(),
            localScale = Vec3.clone([1, 1, 1]),
            // the dirty parameter let the
            LOCAL = 0,
            LOCAL_INV = 1,
            GLOBAL = 2,
            GLOBAL_INV = 3,
            GLOBAL_POSITION = 4,
            GLOBAL_ROTATION = 5,
            dirty = new Int8Array(6), // local,localInverse,global,globalInverse
            children = [],
            parentTransform = null,
            thisObj = this,
            isNaNArray = function(array){
                var i;
                for (i=0;i<array.length;i++){
                    if (isNaN(array[i])){
                        Util.warn("NaN");
                    }
                }
            },
            markGlobalDirty = function () {
                var i;
                dirty[GLOBAL] = 1;
                dirty[GLOBAL_INV] = 1;
                dirty[GLOBAL_POSITION] = 1;
                dirty[GLOBAL_ROTATION] = 1;
                for (i = children.length - 1; i >= 0; i--) {
                    children[i]._markGlobalDirty();
                }
            },
            markLocalDirty = function () {
                dirty[LOCAL] = 1;
                dirty[LOCAL_INV] = 1;
                markGlobalDirty();
            };

        Object.defineProperties(this, {
            /**
             * Global position.
             * @property position
             * @type kick.math.Vec3
             */
            position: {
                get: function () {
                    // if no parent - use local position
                    if (parentTransform === null) {
                        return Vec3.clone(localPosition);
                    }
                    if (dirty[GLOBAL_POSITION]) {
                        Mat4.multiplyVec3(globalPosition, thisObj.getGlobalMatrix(), [0, 0, 0]);
                        dirty[GLOBAL_POSITION] = 0;
                    }
                    return Vec3.clone(globalPosition);
                },
                set: function (newValue) {
                    if (ASSERT){
                        isNaNArray(newValue);
                    }
                    var currentPosition;
                    if (parentTransform === null) {
                        thisObj.localPosition = newValue;
                        return;
                    }
                    currentPosition = thisObj.position;
                    Vec3.copy(localPosition, newValue);
                    thisObj.localPosition = [
                        localPosition[0] + currentPosition[0] - newValue[0],
                        localPosition[1] + currentPosition[1] - newValue[1],
                        localPosition[2] + currentPosition[2] - newValue[2]
                    ];
                    markLocalDirty();
                }
            },
            /**
             * Local position.
             * @property localPosition
             * @type kick.math.Vec3
             */
            localPosition: {
                get: function () {
                    return Vec3.clone(localPosition);
                },
                set: function (newValue) {
                    if (ASSERT){
                        isNaNArray(newValue);
                    }
                    Vec3.copy(localPosition, newValue);
                    markLocalDirty();
                }
            },
            /**
             * Local rotation in euler angles.
             * @property localRotationEuler
             * @type kick.math.Vec3
             */
            localRotationEuler: {
                get: function () {
                    var vec = Vec3.create();
                    Quat.toEuler(vec, localRotationQuat);
                    return vec;
                },
                set: function (newValue) {
                    if (ASSERT){
                        isNaNArray(newValue);
                    }
                    Quat.setEuler(localRotationQuat, newValue);
                    markLocalDirty();
                }
            },
            /**
             * Global rotation in euler angles.
             * @property rotationEuler
             * @type kick.math.Vec3
             */
            rotationEuler: {
                get: function () {
                    var vec = Vec3.create();
                    Quat.toEuler(vec, thisObj.rotation);
                    return vec;
                },
                set: function (newValue) {
                    if (ASSERT){
                        isNaNArray(newValue);
                    }
                    var tmp = Quat.create();
                    Quat.setEuler(tmp, newValue);
                    this.rotation = tmp;
                }
            },

            /**
             * Global rotation in quaternion.
             * @property rotation
             * @type kick.math.Quat
             */
            rotation: {
                get: function () {
                    var parentIterator = null;
                    if (parentTransform === null) {
                        return Quat.clone(localRotationQuat);
                    }
                    if (dirty[GLOBAL_ROTATION]) {
                        Quat.copy(globalRotationQuat, localRotationQuat);
                        parentIterator = thisObj.parent;
                        while (parentIterator !== null) {
                            Quat.multiply(globalRotationQuat, parentIterator.localRotation, globalRotationQuat);
                            parentIterator = parentIterator.parent;
                        }
                        dirty[GLOBAL_ROTATION] = false;
                    }
                    return globalRotationQuat;
                },
                set: function (newValue) {
                    if (ASSERT){
                        isNaNArray(newValue);
                    }
                    if (parentTransform === null) {
                        this.localRotation = newValue;
                        return;
                    }
                    var rotationDifference = Quat.create();
                    Quat.difference(rotationDifference, newValue, thisObj.rotation);
                    this.localRotation = Quat.multiply(localRotationQuat, localRotationQuat, rotationDifference);
                }
            },
            /**
             * Local rotation in quaternion.
             * @property localRotation
             * @type kick.math.Quat
             */
            localRotation: {
                get: function () {
                    return localRotationQuat;
                },
                set: function (newValue) {
                    if (ASSERT){
                        isNaNArray(newValue);
                    }
                    Quat.copy(localRotationQuat, newValue);
                    markLocalDirty();
                }
            },
            /**
             * Local scale.
             * Any zero value will be replaced with an epsilon value.
             * @property localScale
             * @type kick.math.Vec3
             */
            localScale: {
                get: function () {
                    return Vec3.clone(localScale);
                },
                set: function (newValue) {
                    if (ASSERT){
                        isNaNArray(newValue);
                    }
                    var i;
                    Vec3.copy(localScale, newValue);
                    // replace 0 value with epsilon to prevent a singular matrix
                    for (i = 0; i < localScale.length; i++) {
                        if (localScale[i] === 0) {
                            localScale[i] = 0.00001;
                        }
                    }
                    markLocalDirty();
                }
            },
            /**
             * Array of children. The children should not be modified directly. Instead use the parent property
             * @property children
             * @type Array_kick.scene.Transform
             */
            children: {
                value: children
            },
            /**
             * Parent transform. Initial null.
             * @property parent
             * @type kick.scene.Transform
             */
            parent: {
                get: function () {
                    return parentTransform;
                },
                set: function (newParent) {
                    if (newParent === this) {
                        Util.fail('Cannot assign parent to self');
                    }
                    if (ASSERT) {
                        if (newParent === undefined) {
                            Util.fail("Cannot set newParent to undefined - should be null");
                        }
                    }
                    if (newParent !== parentTransform) {
                        if (newParent === null) {
                            parentTransform = null;
                            Util.removeElementFromArray(newParent.children, this);
                        } else {
                            parentTransform = newParent;
                            newParent.children.push(this);
                        }
                        markGlobalDirty();
                    }
                }
            },
            /**
             * Name of the component type = "transform".
             * @example
             *      var transform = gameObject.transform;
             * @property componentType
             * @type String
             * @final
             */
            componentType: {value:"transform"}
        });

        /**
         * Changes the rotation of the object to look at input (Transform) object.
         * @method lookAt
         * @param {kick.scene.Transform} transform target object to look at
         * @param {kick.math.Vec3} up the up-vector used in the lookAt
         */
        this.lookAt = function (transform, up) {
            if (ASSERT) {
                if (!(transform instanceof Transform)) {
                    Util.fail("transform must be a kick.scene.Transform");
                }
            }
            Quat.lookAt(localRotationQuat, thisObj.position, transform.position, up);
            markLocalDirty();
        };

        /**
         * Return the local transformation matrix
         * @method getLocalMatrix
         * @return {kick.math.Mat4} local transformation
         */
        this.getLocalMatrix = function () {
            if (dirty[LOCAL]) {
                Mat4.setTRS(localMatrix, localPosition, localRotationQuat, localScale);
                dirty[LOCAL] = 0;
            }
            return localMatrix;
        };

        /**
         * Return the local inverse of translate rotate scale
         * @method getLocalTRSInverse
         * @return {kick.math.Mat4} inverse of local transformation
         */
        this.getLocalTRSInverse = function () {
            if (dirty[LOCAL_INV]) {
                Mat4.setTRSInverse(localMatrixInverse, localPosition, localRotationQuat, localScale);
                dirty[LOCAL_INV] = 0;
            }
            return localMatrixInverse;
        };

        /**
         * @method getGlobalMatrix
         * @return {kick.math.Mat4} global transform
         */
        this.getGlobalMatrix = function () {
            if (dirty[GLOBAL]) {
                Mat4.copy(globalMatrix, thisObj.getLocalMatrix());

                var transformIterator = thisObj.parent;
                while (transformIterator !== null) {
                    Mat4.multiply(globalMatrix, transformIterator.getLocalMatrix(), globalMatrix);
                    transformIterator  = transformIterator.parent;
                }
                dirty[GLOBAL] = 0;
            }
            return globalMatrix;
        };

        /**
         * Return the inverse of global rotate translate transform
         * @method getGlobalTRSInverse
         * @return {kick.math.Mat4} inverse global transform
         */
        this.getGlobalTRSInverse = function () {
            if (dirty[GLOBAL_INV]) {
                Mat4.copy(globalMatrixInverse, thisObj.getLocalTRSInverse());
                var transformIterator = thisObj.parent;
                while (transformIterator !== null) {
                    Mat4.multiply(globalMatrixInverse, globalMatrixInverse, transformIterator.getLocalTRSInverse());
                    transformIterator  = transformIterator.parent;
                }
                dirty[GLOBAL_INV] = 0;
            }
            return globalMatrixInverse;
        };

        /**
         * Mark the global transform updated.
         * This will mark the transform updated (meaning the global transform must be recomputed based on
         * translation, rotation, scale)
         * @method markGlobalDirty
         * @private
         */
        this._markGlobalDirty = markGlobalDirty;

        /**
         * @method toJSON
         * @return {Object} JSON formatted object
         */
        this.toJSON = function () {
            var typedArrayToArray = Util.typedArrayToArray;
            if (ASSERT) {
                if (!thisObj.gameObject) {
                    Util.fail("Cannot serialize a Transform object that has no reference to gameObject");
                }
            }
            return {
                type: "kick.scene.Transform",
                uid: EngineSingleton.engine.getUID(thisObj),
                config: {
                    localPosition: typedArrayToArray(localPosition),
                    localRotation: typedArrayToArray(localRotationQuat),
                    localScale: typedArrayToArray(localScale),
                    parent: parentTransform ? Util.getJSONReference(parentTransform) : null
                }
            };
        };



        /**
         * @method str
         * @return {String} stringify JSON
         */
        this.str = function () {
            return JSON.stringify(thisObj.toJSON());
        };
    };

    return Transform;
});

define('kick/scene/GameObject',["./Transform", "kick/core/Util", "kick/core/Constants", "kick/core/Observable"], function (Transform, Util, Constants, Observable) {
    

    var ASSERT = true;

    /**
     * Game objects. (Always attached to a given scene).
     * This constructor should not be called directly - Scene.createGameObject() should be used instead.
     * @class GameObject
     * @namespace kick.scene
     * @constructor
     * @param {kick.scene.Scene} scene
     * @param {Object} config configuration for gameObject (components will not be initialized)
     */
    return function (scene, config) {
        var _components = [],
            _layer = 1,
            _name,
            _uid = scene.engine.createUID(),
            thisObj = this;
        Object.defineProperties(this,
            {
                /**
                 * Reference to the containing scene
                 * @property scene
                 * @type kick.scene.Scene
                 */
                scene: {
                    value: scene
                },
                /**
                 * Reference to the engine
                 * @property engine
                 * @type kick.core.Engine
                 * @deprecated
                 */
                engine: {
                    get: function () {
                        if (ASSERT) {
                            Util.fail("GameObject.engine is deprecated. Use EngineSingleton.engine instead.");
                        }
                        return scene.engine;
                    }
                },
                /**
                 * Reference to the transform
                 * @property transform
                 * @type kick.scene.Transform
                 */
                // automatically bound
                /**
                 * Layer bit flag. The default value is 1.
                 * The layer should have a value of 2^n
                 * @property layer
                 * @type Number
                 */
                layer: {
                    get: function () {
                        return _layer;
                    },
                    set: function (newValue) {
                        if (typeof newValue !== 'number') {
                            Util.fail("GameObject.layer must be a Number");
                        }
                        _layer = newValue;
                    }
                },
                /**
                 * @property name
                 * @type String
                 */
                name: {
                    get: function () {
                        return _name;
                    },
                    set: function (newValue) {
                        _name = newValue;
                    }
                },
                /**
                 * Unique id - identifies a game object (within a scene).
                 * @property uid
                 * @type Number
                 */
                uid: {
                    get: function () {
                        return _uid;
                    },
                    set: function (newValue) {
                        _uid = newValue;
                    }
                },
                /**
                 * Number of components
                 * @property numberOfComponents
                 * @type Number
                 */
                numberOfComponents: {
                    get: function () {
                        return _components.length;
                    }
                },
                /**
                 * @property destroyed
                 * @type Boolean
                 */
                destroyed: {
                    get: function () {
                        return _components.length === 0;
                    }
                }
            });

        Observable.call(this, [
        /**
         * Fired when a new component is added to gameObject
         * @event componentAdded
         * @param {kick.scene.Component} component
         */
            "componentAdded",
        /**
         * Fired when a new component is removed from gameObject
         * @event componentRemoved
         * @param {kick.scene.Component} component
         */
            "componentRemoved"
        ]
        );

        /**
         * Get component by index.
         * @method getComponent
         * @param {Number} index
         * @return {kick.scene.Component}
         */
        this.getComponent = function (index) {
            return _components[index];
        };

        /**
         * Add the component to a gameObject and set the gameObject field on the component
         * @method addComponent
         * @param {kick.scene.Component} component
         */
        this.addComponent = function (component) {
            if (component.gameObject) {
                throw {
                    name: "Error",
                    message: "Component " + component + " already added to gameObject " + component.gameObject
                };
            }
            if (!component.scriptPriority) {
                component.scriptPriority = 0;
            }
            if (typeof component.componentType === "string" && thisObj[component.componentType] === undefined){
                thisObj[component.componentType] = component;
            }
            component.gameObject = this;
            _components.push(component);
            thisObj.fireEvent("componentAdded", component);
        };

        /**
         * Remove the component from a gameObject and clear the gameObject field on the component
         * @method removeComponent
         * @param {kick.scene.Component} component
         */
        this.removeComponent =  function (component) {
            try {
                delete component.gameObject;
            } catch (e) {
                // ignore if gameObject cannot be deleted
            }
            // delete component reference
            if (typeof component.componentType === "string" && thisObj[component.componentType] === component){
                delete thisObj[component.componentType];
            }
            if (Util.removeElementFromArray(_components, component)){
                thisObj.fireEvent("componentRemoved", component);
            }
        };

        /**
         * Invoked when component updated (such as material change).
         * @method notifyComponentUpdated
         * @param {kick.scene.Component} component
         * @deprecated
         */
        this.notifyComponentUpdated = function (component) {
            Util.fail("Use component.fireEvent('componentUpdated', component) instead");
            if (component.hasOwnProperty("componentUpdated")){
                component.fireEvent("componentUpdated", component);
            }
        };

        /**
         * Destroys game object after next frame.
         * Removes all components instantly.
         * This method will call destroyGameObject on the associated scene.
         * @method destroy
         */
        this.destroy = function () {
            var i;
            for (i = _components.length - 1; i >= 0; i--) {
                thisObj.removeComponent(_components[i]);
            }
            scene.destroyGameObject(thisObj);
        };
        /**
         * Get the first component of a specified type. Internally uses instanceof.<br>
         * Example usage:<br>
         * @example
         *     var meshRenderer = someGameObject.getComponentOfType(kick.scene.MeshRenderer);
         *     var material = meshRenderer.material;
         * @method getComponentOfType
         * @param {Object} type the constructor of the wanted component
         * @return {Object} component of specified type or null
         */
        this.getComponentOfType = function (type) {
            var component,
                i;
            for (i = _components.length - 1; i >= 0; i--) {
                component = _components[i];
                if (component instanceof type) {
                    return component;
                }
            }
            return null;
        };

        /**
         * Get all component of a specified type. Internally uses instanceof.<br>
         * Example usage:<br>
         * @example
         *     var meshRenderer = someGameObject.getComponentsOfType(kick.scene.MeshRenderer);
         *     if (meshRenderer.length > 0){
         *         material = meshRenderer[0].material;
         *     }
         * @method getComponentsOfType
         * @param {Object} type the constructor of the wanted component
         * @return {Array} arrays of components of specified type
         */
        this.getComponentsOfType = function (type) {
            var component,
                i,
                res = [];
            for (i = _components.length - 1; i >= 0; i--) {
                component = _components[i];
                if (component instanceof type) {
                    res.push(component);
                }
            }
            return res;
        };

        /**
         * Get the first component with a specific method.<br>
         * Example usage:<br>
         * @example
         *     var renderer = someGameObject.getComponentsWithMethod("render");
         * @method getComponentsWithMethod
         * @param {String} methodName of the method
         * @return {Object|null} component of with a method with a specific method name
         */
        this.getComponentsWithMethod = function (methodName) {
            var component,
                i;
            for (i = _components.length - 1; i >= 0; i--) {
                component = _components[i];
                if (typeof (component[methodName]) === "function") {
                    return component;
                }
            }
            return null;
        };

        /**
         * Get all components with a specific method. <br>
         * Example usage:<br>
         * @example
         *     var renderers = someGameObject.getComponentsWithMethod("render");
         *     for (var i = 0; i < renderers.length; i++){
         *         renderers[i].render(obj);
         *     }
         * @method getComponentsWithMethod
         * @param {Object} methodName the constructor of the wanted component
         * @return {Array} arrays of components of specified type
         */
        this.getComponentsWithMethod = function (methodName) {
            var component,
                i,
                res = [];
            for (i = _components.length - 1; i >= 0; i--) {
                component = _components[i];
                if (typeof (component[methodName]) === "function") {
                    res.push(component);
                }
            }
            return res;
        };

        /**
         * @method toJSON
         * @return JSON object
         */
        this.toJSON = function () {
            var componentsJSON = [],
                component,
                i,
                componentJSON;
            for (i = 0; i < _components.length; i++) {
                component = _components[i];
                if (!component.toJSON) {
                    componentsJSON.push(Util.componentToJSON(component));
                } else {
                    componentJSON = component.toJSON();
                    if (componentJSON) {
                        componentsJSON.push(componentJSON);
                    }
                }
            }
            return {
                name: _name,
                layer: _layer,
                uid: _uid,
                components: componentsJSON
            };
        };

        (function init() {
            thisObj.addComponent(new Transform(thisObj));
            Util.applyConfig(thisObj, config, ["uid"]);
        }());
    };
});

define('kick/scene/Scene',["require", "kick/core/ProjectAsset", "./SceneLights", "kick/core/Constants", "kick/core/Util", "./Camera", "./Light", "./GameObject", "kick/core/EngineSingleton", "kick/core/Observable"],
    function (require, ProjectAsset, SceneLights, Constants, Util, Camera, Light, GameObject, EngineSingleton, Observable) {
        

        var warn = Util.warn,
            DEBUG = true,
            ASSERT = true,
            Scene;

        /**
         * A scene objects contains a list of GameObjects
         * @class Scene
         * @namespace kick.scene
         * @constructor
         * @param {Object} config
         * @extends kick.core.ProjectAsset
         */
        Scene = function (config) {
            // extend ProjectAsset
            ProjectAsset(this, config, "kick.scene.Scene");
            if (ASSERT){
                if (config === EngineSingleton.engine){
                    Util.fail("Scene constructor changed - engine parameter is removed");
                }
            }
            var engine = EngineSingleton.engine,
                objectsById = {},
                gameObjects = [],
                activeGameObjects = [],
                gameObjectsNew = [],
                gameObjectsDelete = [],
                updateableComponents = [],
                componentsNew = [],
                componentsDelete = [],
                componentsAll = [],
                cameras = [],
                renderableComponents = [],
                sceneLightObj = new SceneLights(engine.config.maxNumerOfLights),
                _name = "Scene",
                thisObj = this,
                addLight = function (light) {
                    if (light.type === Light.TYPE_AMBIENT) {
                        sceneLightObj.ambientLight = light;
                    } else if (light.type === Light.TYPE_DIRECTIONAL) {
                        sceneLightObj.directionalLight = light;
                    } else {
                        sceneLightObj.addPointLight(light);
                    }
                },
                removeLight = function (light) {
                    if (light.type === Light.TYPE_AMBIENT) {
                        sceneLightObj.ambientLight = null;
                    } else if (light.type === Light.TYPE_DIRECTIONAL) {
                        sceneLightObj.directionalLight = null;
                    } else {
                        sceneLightObj.removePointLight(light);
                    }
                },
                /**
                 * Compares two objects based on scriptPriority
                 * @method sortByScriptPriority
                 * @param {kick.scene.Component} a
                 * @param {kick.scene.Component} b
                 * @return {Number} order of a,b
                 * @private
                 */
                sortByScriptPriority = function (a, b) {
                    return a.scriptPriority - b.scriptPriority;
                },
                /**
                 * Compares two camera objects by their cameraIndex attribute
                 * @method cameraSortFunc
                 * @param {kick.scene.Camera} a
                 * @param {kick.scene.Camera} b
                 * @param {Number} difference
                 * @private
                 */
                cameraSortFunc = function (a, b) {
                    return b.cameraIndex - a.cameraIndex;
                },
                /**
                 * Handle insertions of new gameobjects and components. This is done in a separate step to avoid problems
                 * with missed updates (or multiple updates) due to modifying the array while iterating it.
                 * @method addNewGameObjects
                 * @private
                 */
                addNewGameObjects = function () {
                    var i,
                        component,
                        componentsNewCopy;
                    if (gameObjectsNew.length > 0) {
                        activeGameObjects = activeGameObjects.concat(gameObjectsNew);
                        gameObjectsNew.length = 0;
                    }
                    if (componentsNew.length > 0) {
                        componentsNewCopy = componentsNew;
                        componentsNew = [];
                        for (i = componentsNewCopy.length - 1; i >= 0; i--) {
                            component = componentsNewCopy[i];
                            componentsAll.push(component);
                            if (typeof (component.activated) === "function") {
                                component.activated();
                            }
                            if (typeof (component.update) === "function") {
                                Util.insertSorted(component, updateableComponents, sortByScriptPriority);
                            }
                            if (typeof (component.render) === "function") {
                                renderableComponents.push(component);
                            }
                            if (typeof (component.render) === "function") {
                                Util.removeElementFromArray(renderableComponents, component);
                            }
                            if (component instanceof Camera) {
                                Util.insertSorted(component, cameras, cameraSortFunc);
                            } else if (component instanceof Light) {
                                addLight(component);
                            }
                            thisObj.fireEvent("componentAdded", component);
                        }
                    }
                },/**
                 * Handle deletion of new gameobjects and components. This is done in a separate step to avoid problems
                 * with missed updates (or multiple updates) due to modifying the array while iterating it.
                 * @method cleanupGameObjects
                 * @private
                 */
                cleanupGameObjects = function () {
                    var i,
                        component,
                        componentsDeleteCopy;
                    if (gameObjectsDelete.length > 0) {
                        Util.removeElementsFromArray(activeGameObjects, gameObjectsDelete);
                        Util.removeElementsFromArray(gameObjects, gameObjectsDelete);
                        gameObjectsDelete.length = 0;
                    }
                    if (componentsDelete.length > 0) {
                        componentsDeleteCopy = componentsDelete;
                        componentsDelete = [];
                        for (i = componentsDeleteCopy.length - 1; i >= 0; i--) {
                            component = componentsDeleteCopy[i];
                            Util.removeElementFromArray(componentsAll, component);
                            if (typeof (component.deactivated) === "function") {
                                component.deactivated();
                            }
                            if (typeof (component.update) === "function") {
                                Util.removeElementFromArray(updateableComponents, component);
                            }
                            if (component instanceof Camera) {
                                Util.removeElementFromArray(cameras, component);
                            } else if (component instanceof Light) {
                                removeLight(component);
                            }
                            thisObj.fireEvent("componentRemoved", component);
                        }
                    }
                },
                insertAndRemoveComponents = function () {
                    var count = 0;
                    while (gameObjectsDelete.length ||
                            componentsDelete.length ||
                            gameObjectsNew.length ||
                            componentsNew.length) {
                        cleanupGameObjects();
                        addNewGameObjects();
                        if (ASSERT) {
                            count++;
                            if (count > 10) {
                                Util.fail("Recursion detected in Component.activated or Component.deactivated.");
                                return;
                            }
                        }
                    }
                },
                updateComponents = function () {
                    insertAndRemoveComponents();
                    var i;
                    for (i = updateableComponents.length - 1; i >= 0; i--) {
                        updateableComponents[i].update();
                    }
                    insertAndRemoveComponents();
                },
                renderComponents = function () {
                    var i;
                    for (i = cameras.length - 1; i >= 0; i--) {
                        cameras[i].renderScene(sceneLightObj);
                    }
                    engine.gl.flush();
                },
                componentAddedListener = function (component) {
                    Util.insertSorted(component, componentsNew, sortByScriptPriority);
                    var uid = engine.getUID(component);
                    if (ASSERT) {
                        if (objectsById[uid]) {
                            Util.fail("Component with uid " + uid + " already exist");
                        }
                    }
                    objectsById[uid] = component;
                },
                componentRemovedListener = function (component) {
                    Util.removeElementFromArray(componentsNew, component);
                    componentsDelete.push(component);
                    delete objectsById[component.uid];
                },
                createGameObjectPrivate = function (config) {
                    var gameObject = new GameObject(thisObj, config);
                    gameObjectsNew.push(gameObject);
                    gameObjects.push(gameObject);
                    objectsById[gameObject.uid] = gameObject;
                    gameObject.addEventListener("componentAdded", componentAddedListener);
                    gameObject.addEventListener("componentRemoved", componentRemovedListener);
                    return gameObject;
                };

            Observable.call(this, [
            /**
             * Fired when a new component is added to scene
             * @event componentAdded
             * @param {kick.scene.Component} component
             */
                "componentAdded",
            /**
             * Fired when a new component is removed from scene
             * @event componentRemoved
             * @param {kick.scene.Component} component
             */
                "componentRemoved"
            ]
            );

            /**
             * @method destroy
             */
            this.destroy = function () {
                engine.project.removeResourceDescriptor(thisObj.uid);
                if (thisObj === engine.activeScene) {
                    engine.activeScene = null;
                }
            };

            /**
             * Search the scene for components of the specified type in the scene. Note that this
             * method is slow - do not run in the the update function.
             * @method findComponentsOfType
             * @param {Function} componentType
             * @return {Array_kick.scene.Component} components
             */
            this.findComponentsOfType = function (componentType) {
                if (ASSERT) {
                    if (typeof componentType !== 'function') {
                        Util.fail("Scene.findComponentsOfType expects a function");
                    }
                }
                var res = [],
                    i,
                    j,
                    component;
                for (i = gameObjects.length - 1; i >= 0; i--) {
                    component = gameObjects[i].getComponentsOfType(componentType);
                    for (j = 0; j < component.length; j++) {
                        res.push(component[j]);
                    }
                }
                return res;
            };

            /**
             * Search the scene for components of the specified type in the scene. Note that this
             * method is slow - do not run in the the update function.
             * @method findComponentsWithMethod
             * @param {string} methodName
             * @return {Array_kick.scene.Component} components
             */
            this.findComponentsWithMethod = function (methodName) {
                if (ASSERT) {
                    if (typeof methodName !== 'string') {
                        Util.fail("Scene.findComponentsWithMethod expects a string");
                    }
                }
                var res = [],
                    i,
                    j,
                    component;
                for (i = gameObjects.length - 1; i >= 0; i--) {
                    component = gameObjects[i].getComponentsWithMethod(methodName);
                    for (j = 0; j < component.length; j++) {
                        res.push(component[j]);
                    }
                }
                return res;
            };

            /**
             * @method getObjectByUID
             * @param {Number} uid
             * @return {Object} GameObject or component
             */
            this.getObjectByUID = function (uid) {
                return objectsById[uid];
            };

            /**
             * Returns a GameObject identified by name
             * @method getGameObjectByName
             * @param {String} name
             * @return {kick.scene.GameObject} GameObject or undefined if not found
             */
            this.getGameObjectByName = function (name) {
                var i,
                    gameObject;
                for (i = gameObjects.length - 1; i >= 0; i--) {
                    gameObject = gameObjects[i];
                    if (gameObject.name === name) {
                        return gameObject;
                    }
                }
            };

            Object.defineProperties(this, {
                /**
                 * Reference to the engine
                 * @property engine
                 * @type kick.core.Engine
                 */
                engine: {
                    value: engine
                },
                /**
                 * Name of the scene
                 * @property name
                 * @type String
                 */
                name: {
                    get: function () {
                        return _name;
                    },
                    set: function (newValue) {
                        _name = newValue;
                    }

                }
            });

            /**
             * @method createGameObject
             * @param {Object} [config] Optionally configuration passed to the game objects
             * @return {kick.scene.GameObject}
             */
            this.createGameObject = function (config) {
                var gameObject = createGameObjectPrivate(config),
                    transform = gameObject.transform;
                objectsById[engine.getUID(transform)] = transform;
                return gameObject;
            };

            /**
             * Destroys the game object and delete it from the scene.
             * This call will call destroy on the gameObject
             * @method destroyObject
             * @param {kick.scene.GameObject} gameObject
             * @deprecated
             */
            this.destroyObject = function (gameObject) {
                var isMarkedForDeletion = Util.contains(gameObjectsDelete, gameObject);

                if (!isMarkedForDeletion) {
                    gameObjectsDelete.push(gameObject);
                    delete objectsById[gameObject.uid];
                }
                if (!gameObject.destroyed) {
                    gameObject.destroy();
                }
            };

            /**
             * Destroys the game object and delete it from the scene.
             * This call will call destroy on the gameObject
             * @method destroyGameObject
             * @param {kick.scene.GameObject} gameObject
             */
            this.destroyGameObject = function (gameObject) {
                var isMarkedForDeletion = Util.contains(gameObjectsDelete, gameObject);
                if (!isMarkedForDeletion) {
                    gameObjectsDelete.push(gameObject);
                    delete objectsById[gameObject.uid];
                }
                if (!gameObject.destroyed) {
                    gameObject.destroy();
                }
            };

            /**
             * @method getNumberOfGameObjects
             * @return {Number} number of gameobjects
             */
            this.getNumberOfGameObjects = function () {
                return gameObjects.length;
            };

            /**
             * @method getGameObject
             * @param {Number} index
             * @return {kick.scene.GameObject}
             */
            this.getGameObject = function (index) {
                return gameObjects[index];
            };

            /**
             * Called by engine every frame. Updates and render scene
             * @method updateAndRender
             */
            this.updateAndRender = function () {
                updateComponents();
                renderComponents();
            };

            /**
             * @method toJSON
             * @param {Function} [filterFn] Optional. Filter with function(object): return boolean, where true means include in export.
             * @return {Object}
             */
            this.toJSON = function (filterFn) {
                var gameObjectsCopy = [],
                    i,
                    gameObject;
                filterFn = filterFn || function () { return true; };
                for (i = 0; i < gameObjects.length; i++) {
                    gameObject = gameObjects[i];
                    if (filterFn(gameObject)) {
                        gameObjectsCopy.push(gameObject.toJSON());
                    }
                }
                return {
                    uid: thisObj.uid,
                    gameObjects: gameObjectsCopy,
                    name: _name
                };
            };

            /**
             * Configures the object using the configuration data.
             * @method init
             * @param config {Object} configuration data in JSON format
             */
            this.init = function(config){
                var gameObject,
                    mappingUidToObject,
                    newGameObjects,
                    configs,
                    hasProperty = Util.hasProperty,
                    applyConfig = Util.applyConfig,
                    i,
                    createConfigWithReferences = function (config) {
                        var configCopy = {},
                            name,
                            value;
                        for (name in config) {
                            if (config.hasOwnProperty(name) && hasProperty(config, name)) {
                                value = config[name];
                                value = Util.deserializeConfig(value, thisObj);
                                configCopy[name] = value;
                            }
                        }
                        return configCopy;
                    };
                if (config) {
                    _name = config.name || "Scene";
                    gameObjects = [];
                    mappingUidToObject = {};
                    configs = {};
                    // create game objects
                    (function createGameObjects() {
                        if (config && config.gameObjects){
                            for (i = 0; i < config.gameObjects.length; i++) {
                                gameObject = config.gameObjects[i];
                                gameObjects[i] = createGameObjectPrivate(gameObject);
                                mappingUidToObject[gameObject.uid] = gameObjects[i];
                            }
                        }
                    }());

                    (function createComponents() {
                        var component,
                            componentObj,
                            Type,
                            gameObjectConfig,
                            j,
                            i,
                            uid,
                            originalConf,
                            conf,
                            obj;

                        for (j = 0; j < gameObjects.length; j++) {
                            gameObjectConfig = config.gameObjects[j];
                            gameObject = gameObjects[j];
                            // build components
                            for (i = 0; gameObjectConfig.components && i < gameObjectConfig.components.length; i++) {
                                component = gameObjectConfig.components[i];
                                if (component.type === "kick.scene.Transform") {
                                    componentObj = gameObject.transform;
                                    componentObj.uid = component.uid;
                                    // register transform object to objectsById
                                    objectsById[componentObj.uid] = componentObj;
                                } else {
                                    Type = require(component.type.replace(/\./g,"/"));
                                    if (typeof Type === 'function') {
                                        componentObj = new Type({uid: component.uid});
                                        componentObj.uid = component.uid;
                                        gameObject.addComponent(componentObj);
                                    } else {
                                        Util.warn("Cannot find Class " + component.type);
                                        continue;
                                    }
                                }
                                mappingUidToObject[component.uid] = componentObj;
                                configs[component.uid] = component.config;
                            }
                        }

                        // apply config
                        for (uid in mappingUidToObject) {
                            if (mappingUidToObject.hasOwnProperty(uid) && hasProperty(mappingUidToObject, uid)) {
                                originalConf = configs[uid];
                                if (originalConf) {
                                    conf = createConfigWithReferences(originalConf);
                                    obj = mappingUidToObject[uid];
                                    applyConfig(obj, conf);
                                }
                            }
                        }
                    }());
                }
            };
            this.init(config);
        };

        /**
         * Create empty scene with camera
         * @method createDefault
         * @static
         * @return {kick.scene.Scene}
         */
        Scene.createDefault = function () {
            var engine = EngineSingleton.engine,
                newScene = new Scene(),
                gameObject = newScene.createGameObject();
            gameObject.addComponent(new Camera());
            return newScene;
        };

        return Scene;
    });

define('kick/math/Mat2',[], function () {
    

    /**
     * Mat2 - 2x2 Matrix
     * Any javascript array containing at least 4 numeric elements can serve as a mat2, however creating matrices
     * using Mat2 constructor functions will use Float32Array
     * @class Mat2
     * @namespace kick.math
     */
    return {
        /**
         * Creates a new instance of a mat2 using Float32Array<br>
         *
         * @method create
         * @return {kick.math.Mat2} New mat2
         * @static
         */
        create: function () {
            var out = new Float32Array(4);
            out[0] = 1;
            out[3] = 1;
            return out;
        },

        /**
         * Creates a new mat2 initialized with values from an existing matrix
         * @method clone
         * @param {kick.math.Mat2} a matrix to clone
         * @return {kick.math.Mat2} a new 2x2 matrix
         * @static
         */
        clone: function (a) {
            var out = new Float32Array(4);
            out[0] = a[0];
            out[1] = a[1];
            out[2] = a[2];
            out[3] = a[3];
            return out;
        },

        /**
         * Copies the values of one mat3 to another
         * @method copy
         * @param {kick.math.Mat2} out the receiving matrix
         * @param {kick.math.Mat2} a the source matrix
         * @return {kick.math.Mat2} out
         * @static
         */
        copy: function (out, a) {
            out[0] = a[0];
            out[1] = a[1];
            out[2] = a[2];
            out[3] = a[3];
            return out;
        },

        /**
         * Sets a Mat2 to the identity matrix
         * @method identity
         * @param {kick.math.Mat2} out the receiving matrix
         * @return {kick.math.Mat2} out
         * @static
         */
        identity: function (out) {
            out[0] = 1;
            out[1] = 0;
            out[2] = 0;
            out[3] = 1;
            return out;
        },

        /**
         * Transposes a Mat2 (flips the values over the diagonal)
         * @method transpose
         * @param {kick.math.Mat2} out the receiving matrix
         * @param {kick.math.Mat2} a the source matrix
         * @return {kick.math.Mat2} out
         * @static
         */
        transpose: function (out, a) {
            // If we are transposing ourselves we can skip a few steps but have to cache some values
            if (out === a) {
                var a1 = a[1];
                out[1] = a[2];
                out[2] = a1;
            } else {
                out[0] = a[0];
                out[1] = a[2];
                out[2] = a[1];
                out[3] = a[3];
            }
            return out;
        },
        /**
         * Inverts a Mat2
         * @method invert
         * @param {kick.math.Mat2} out the receiving matrix
         * @param {kick.math.Mat2} a the source matrix
         * @return {kick.math.Mat2} out
         * @static
         */
        invert: function (out, a) {
            var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],

                // Calculate the determinant
                det = a0 * a3 - a2 * a1;

            if (!det) {
                return null;
            }
            det = 1.0 / det;

            out[0] =  a3 * det;
            out[1] = -a1 * det;
            out[2] = -a2 * det;
            out[3] =  a0 * det;

            return out;
        },

        /**
         * Calculates the adjugate of a mat2
         * @method adjoint
         * @param {kick.math.Mat2} out the receiving matrix
         * @param {kick.math.Mat2} a the source matrix
         * @return {kick.math.Mat2} out
         * @static
         */
        adjoint: function (out, a) {
            // Caching this value is nessecary if out == a
            var a0 = a[0];
            out[0] =  a[3];
            out[1] = -a[1];
            out[2] = -a[2];
            out[3] =  a0;

            return out;
        },

        /**
         * Calculates the determinant of a Mat2
         * @method determinant
         * @param {kick.math.Mat2} a the source matrix
         * @return {Number} determinant of a
         * @static
         */
        determinant: function (a) {
            return a[0] * a[3] - a[2] * a[1];
        },

        /**
         * Multiplies two Mat2's
         * @method multiply
         * @param {kick.math.Mat2} out the receiving matrix
         * @param {kick.math.Mat2} a the first operand
         * @param {kick.math.Mat2} b the second operand
         * @return {kick.math.Mat2} out
         * @static
         */
        multiply: function (out, a, b) {
            var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],
                b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
            out[0] = a0 * b0 + a1 * b2;
            out[1] = a0 * b1 + a1 * b3;
            out[2] = a2 * b0 + a3 * b2;
            out[3] = a2 * b1 + a3 * b3;
            return out;
        },

        /**
         * Rotates a mat2 by the given angle
         * @method rotate
         * @param {kick.math.Mat2} out the receiving matrix
         * @param {kick.math.Mat2} a the matrix to rotate
         * @param {Number} rad the angle to rotate the matrix by
         * @return {kick.math.Mat2} out
         * @static
         */
        rotate: function (out, a, rad) {
            var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],
                s = Math.sin(rad),
                c = Math.cos(rad);
            out[0] = a0 *  c + a1 * s;
            out[1] = a0 * -s + a1 * c;
            out[2] = a2 *  c + a3 * s;
            out[3] = a2 * -s + a3 * c;
            return out;
        },

        /**
         * Scales the mat2 by the dimensions in the given vec2
         * @method scale
         * @param {kick.math.Mat2} out the receiving matrix
         * @param {kick.math.Mat2} a the matrix to rotate
         * @param {kick.math.Vec2} v the vec2 to scale the matrix by
         * @return {kick.math.Mat2} out
         * @static
         **/
        scale: function (out, a, v) {
            var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],
                v0 = v[0], v1 = v[1];
            out[0] = a0 * v0;
            out[1] = a1 * v1;
            out[2] = a2 * v0;
            out[3] = a3 * v1;
            return out;
        },

        /**
         * Returns a string representation of a Mat2
         * @method str
         * @param {kick.math.Mat2} a matrix to represent as a string
         * @return {String} string representation of the matrix
         * @static
         */
        str: function (a) {
            return '[' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ']';
        },

        /**
         * Returns a string representation of a Mat2 printed as a 2x2 matrix (on 2 lines)
         * @method strPretty
         * @param {kick.math.Mat2} mat mat2 to represent as a string
         * @return {String} string representation of mat
         * @static
         */
        strPretty: function (mat) {
            return '[' + mat[0] + ', ' + mat[2] + '\n' +
                ', ' + mat[1] + ', ' + mat[3] + ']';
        }
    };
});

define('kick/math/Mat2d',[], function () {
    

    /**
     * Mat2 - 2x3 Matrix
     * A mat2d contains six elements defined as:
     * <pre>
     * [a, b,
     *  c, d,
     *  tx,ty]
     * </pre>
     * This is a short form for the 3x3 matrix:
     * <pre>
     * [a, b, 0
     *  c, d, 0
     *  tx,ty,1]
     * </pre>
     * The last column is ignored so the array is shorter and operations are faster.
     * @class Mat2d
     * @namespace kick.math
     */
    return {
        /**
         * Creates a new identity mat2d
         *
         * @method create
         * @return {kick.math.Mat2d} New mat2d
         * @static
         */
        create: function () {
            var out = new Float32Array(6);
            out[0] = 1;
            out[3] = 1;
            return out;
        },

        /**
         * Creates a new mat2d initialized with values from an existing matrix
         * @method clone
         * @param {kick.math.Mat2d} a matrix to clone
         * @return {kick.math.Mat2d} a new 2x3 matrix
         * @static
         */
        clone: function (a) {
            var out = new Float32Array(6);
            out[0] = a[0];
            out[1] = a[1];
            out[2] = a[2];
            out[3] = a[3];
            out[4] = a[4];
            out[5] = a[5];

            return out;
        },

        /**
         * Copy the values from one mat2d to another
         * @method copy
         * @param {kick.math.Mat2d} out the receiving matrix
         * @param {kick.math.Mat2d} a the source matrix
         * @return {kick.math.Mat2d} out
         * @static
         */
        copy: function (out, a) {
            out[0] = a[0];
            out[1] = a[1];
            out[2] = a[2];
            out[3] = a[3];
            out[4] = a[4];
            out[5] = a[5];
            return out;
        },

        /**
         * Sets a Mat2d to the identity matrix
         * @method identity
         * @param {kick.math.Mat2d} out the receiving matrix
         * @return {kick.math.Mat2d} out
         * @static
         */
        identity: function (out) {
            out[0] = 1;
            out[1] = 0;
            out[2] = 0;
            out[3] = 1;
            out[4] = 0;
            out[5] = 0;
            return out;
        },

        /**
         * Inverts a Mat2d
         * @method invert
         * @param {kick.math.Mat2d} out the receiving matrix
         * @param {kick.math.Mat2d} a the source matrix
         * @return {kick.math.Mat2d} out
         * @static
         */
        invert: function (out, a) {
            var aa = a[0], ab = a[1], ac = a[2], ad = a[3],
                atx = a[4], aty = a[5];

            var det = aa * ad - ab * ac;
            if(!det){
                return null;
            }
            det = 1.0 / det;

            out[0] = ad * det;
            out[1] = -ab * det;
            out[2] = -ac * det;
            out[3] = aa * det;
            out[4] = (ac * aty - ad * atx) * det;
            out[5] = (ab * atx - aa * aty) * det;
            return out;
        },

        /**
         * Calculates the determinant of a Mat2d
         * @method determinant
         * @param {kick.math.Mat2d} a the source matrix
         * @return {Number} determinant of a
         * @static
         */
        determinant: function (a) {
            return a[0] * a[3] - a[1] * a[2];
        },

        /**
         * Multiplies two Mat2d's
         * @method multiply
         * @param {kick.math.Mat2d} out the receiving matrix
         * @param {kick.math.Mat2d} a the first operand
         * @param {kick.math.Mat2d} b the second operand
         * @return {kick.math.Mat2d} out
         * @static
         */
        multiply: function (out, a, b) {
            var aa = a[0], ab = a[1], ac = a[2], ad = a[3],
                atx = a[4], aty = a[5],
                ba = b[0], bb = b[1], bc = b[2], bd = b[3],
                btx = b[4], bty = b[5];

            out[0] = aa*ba + ab*bc;
            out[1] = aa*bb + ab*bd;
            out[2] = ac*ba + ad*bc;
            out[3] = ac*bb + ad*bd;
            out[4] = ba*atx + bc*aty + btx;
            out[5] = bb*atx + bd*aty + bty;
            return out;
        },

        /**
         * Rotates a mat2d by the given angle
         * @method rotate
         * @param {kick.math.Mat2d} out the receiving matrix
         * @param {kick.math.Mat2d} a the matrix to rotate
         * @param {Number} rad the angle to rotate the matrix by
         * @return {kick.math.Mat2d} out
         * @static
         */
        rotate: function (out, a, rad) {
            var aa = a[0],
                ab = a[1],
                ac = a[2],
                ad = a[3],
                atx = a[4],
                aty = a[5],
                st = Math.sin(rad),
                ct = Math.cos(rad);

            out[0] = aa*ct + ab*st;
            out[1] = -aa*st + ab*ct;
            out[2] = ac*ct + ad*st;
            out[3] = -ac*st + ct*ad;
            out[4] = ct*atx + st*aty;
            out[5] = ct*aty - st*atx;
            return out;
        },

        /**
         * Scales the mat2d by the dimensions in the given vec2
         * @method scale
         * @param {kick.math.Mat2d} out the receiving matrix
         * @param {kick.math.Mat2d} a the matrix to rotate
         * @param {kick.math.Vec2} v the vec2 to scale the matrix by
         * @return {kick.math.Mat2d} out
         * @static
         **/
        scale: function (out, a, v) {
            var vx = v[0], vy = v[1];
            out[0] = a[0] * vx;
            out[1] = a[1] * vy;
            out[2] = a[2] * vx;
            out[3] = a[3] * vy;
            out[4] = a[4] * vx;
            out[5] = a[5] * vy;
            return out;
        },

        /**
         * Translates the mat2d by the dimensions in the given vec2
         *
         * @method translate
         * @param {kick.math.Mat2d} out the receiving matrix
         * @param {kick.math.Mat2d} a the matrix to translate
         * @param {kick.math.Vec2} v the vec2 to translate the matrix by
         * @return {kick.math.Mat2d} out
         * @static
         */
        translate: function (out, a, v){
            out[0] = a[0];
            out[1] = a[1];
            out[2] = a[2];
            out[3] = a[3];
            out[4] = a[4] + v[0];
            out[5] = a[5] + v[1];
            return out;
        },

        /**
         * Returns a string representation of a Mat2d
         * @method str
         * @param {kick.math.Mat2d} a matrix to represent as a string
         * @return {String} string representation of the matrix
         * @static
         */
        str: function (a) {
            return '[' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' +
                                a[3] + ', ' + a[4] + ', ' + a[5] + ']';
        },

        /**
         * Returns a string representation of a Mat2d printed as a 3x3 matrix (on 3 lines)
         * @method strPretty
         * @param {kick.math.Mat2d} mat mat2d to represent as a string
         * @return {String} string representation of mat
         * @static
         */
        strPretty: function (mat) {
            return '[' + mat[0] + ', ' + mat[1] + ', 0\n' +
                ', ' + mat[2] + ', ' + mat[3] + ', 0\n'+
                ', ' + mat[4] + ', ' + mat[5] + ', 1]';
        }
    };
});

define('kick/math',["./math/Vec2", "./math/Vec3", "./math/Vec4", "./math/Mat2","./math/Mat2d", "./math/Mat3", "./math/Mat4", "./math/Quat", "./math/Frustum", "./math/Aabb"],
    function (vec2, vec3, vec4, mat2, mat2d, mat3, mat4, quat, frustum, aabb) {
        
        return {
            Vec2: vec2,
            Vec3: vec3,
            Vec4: vec4,
            Mat2: mat2,
            Mat2d: mat2d,
            Mat3: mat3,
            Mat4: mat4,
            Quat: quat,
            Frustum: frustum,
            Aabb: aabb
        };
    }
);

define('kick/core/Time',[], function () {
    

    /**
     * A global timer object
     * @class Time
     * @namespace kick.core
     */
    return function () {
        /**
         * Time since start in milliseconds. Read only
         * @property time
         * @type Number
         */
        this.time = 0;
        /**
         * Millis between this frame and last frame. Read only
         * @property deltaTime
         * @type Number
         */
        this.deltaTime = 0;
        /**
         * Number of frames since start. Read only
         * @property frame
         * @type Number
         */
        this.frame = 0;
        /**
         * Default value is 1.0. Can be used for implementing pause or slow-motion sequences
         * @property scale
         * @type Number
         */
        this.scale = 0;
    };
});

define('kick/core/WebGLDebugUtils',["./Constants"], function (Constants) {
    

    /* /// Removed from documentation ///
     * This class contains the webgl-debug.js. Note is is only defined in debug builds.
     * @class WebGLDebugUtils
     * @namespace kick.core
     * @static
     */
    if (!true) {
        return {};
    } else {
        // based on the webgl-debug.js
        // https://www.khronos.org/registry/webgl/sdk/debug/webgl-debug.js
        // Various functions for helping debug WebGL apps.
        return function () {

            /*
             * Wrapped logging function.
             * @param {string} msg Message to log.
             */
            var log = function(msg) {
                if (window.console && window.console.log) {
                    window.console.log(msg);
                }
            };

            /*
             * Wrapped error logging function.
             * @param {string} msg Message to log.
             */
            var error = function(msg) {
                if (window.console && window.console.error) {
                    window.console.error(msg);
                } else {
                    log(msg);
                }
            };

            /*
             * Which arguements are enums.
             * @type {!Object.<number, string>}
             */
            var glValidEnumContexts = {

                // Generic setters and getters

                'enable': { 0:true },
                'disable': { 0:true },
                'getParameter': { 0:true },

                // Rendering

                'drawArrays': { 0:true },
                'drawElements': { 0:true, 2:true },

                // Shaders

                'createShader': { 0:true },
                'getShaderParameter': { 1:true },
                'getProgramParameter': { 1:true },

                // Vertex attributes

                'getVertexAttrib': { 1:true },
                'vertexAttribPointer': { 2:true },

                // Textures

                'bindTexture': { 0:true },
                'activeTexture': { 0:true },
                'getTexParameter': { 0:true, 1:true },
                'texParameterf': { 0:true, 1:true },
                'texParameteri': { 0:true, 1:true, 2:true },
                'texImage2D': { 0:true, 2:true, 6:true, 7:true },
                'texSubImage2D': { 0:true, 6:true, 7:true },
                'copyTexImage2D': { 0:true, 2:true },
                'copyTexSubImage2D': { 0:true },
                'generateMipmap': { 0:true },

                // Buffer objects

                'bindBuffer': { 0:true },
                'bufferData': { 0:true, 2:true },
                'bufferSubData': { 0:true },
                'getBufferParameter': { 0:true, 1:true },

                // Renderbuffers and framebuffers

                'pixelStorei': { 0:true, 1:true },
                'readPixels': { 4:true, 5:true },
                'bindRenderbuffer': { 0:true },
                'bindFramebuffer': { 0:true },
                'checkFramebufferStatus': { 0:true },
                'framebufferRenderbuffer': { 0:true, 1:true, 2:true },
                'framebufferTexture2D': { 0:true, 1:true, 2:true },
                'getFramebufferAttachmentParameter': { 0:true, 1:true, 2:true },
                'getRenderbufferParameter': { 0:true, 1:true },
                'renderbufferStorage': { 0:true, 1:true },

                // Frame buffer operations (clear, blend, depth test, stencil)

                'clear': { 0:true },
                'depthFunc': { 0:true },
                'blendFunc': { 0:true, 1:true },
                'blendFuncSeparate': { 0:true, 1:true, 2:true, 3:true },
                'blendEquation': { 0:true },
                'blendEquationSeparate': { 0:true, 1:true },
                'stencilFunc': { 0:true },
                'stencilFuncSeparate': { 0:true, 1:true },
                'stencilMaskSeparate': { 0:true },
                'stencilOp': { 0:true, 1:true, 2:true },
                'stencilOpSeparate': { 0:true, 1:true, 2:true, 3:true },

                // Culling

                'cullFace': { 0:true },
                'frontFace': { 0:true }
            };

            /*
             * Map of numbers to names.
             * @type {Object}
             */
            var glEnums = null;

            /*
             * Initializes this module. Safe to call more than once.
             * @param {!WebGLRenderingContext} ctx A WebGL context. If
             *    you have more than one context it doesn't matter which one
             *    you pass in, it is only used to pull out constants.
             */
            function init(ctx) {
                if (glEnums == null) {
                    glEnums = { };
                    for (var propertyName in ctx) {
                        if (typeof ctx[propertyName] == 'number') {
                            glEnums[ctx[propertyName]] = propertyName;
                        }
                    }
                }
            }

            /*
             * Checks the utils have been initialized.
             */
            function checkInit() {
                if (glEnums == null) {
                    throw 'WebGLDebugUtils.init(ctx) not called';
                }
            }

            /*
             * Returns true or false if value matches any WebGL enum
             * @param {*} value Value to check if it might be an enum.
             * @return {boolean} True if value matches one of the WebGL defined enums
             */
            function mightBeEnum(value) {
                checkInit();
                return (glEnums[value] !== undefined);
            }

            /*
             * Gets an string version of an WebGL enum.
             *
             * Example:
             * @example
             *     var str = WebGLDebugUtil.glEnumToString(ctx.getError());
             *
             * @param {number} value Value to return an enum for
             * @return {string} The string version of the enum.
             */
            function glEnumToString(value) {
                checkInit();
                var name = glEnums[value];
                return (name !== undefined) ? name :
                    ("*UNKNOWN WebGL ENUM (0x" + value.toString(16) + ")");
            }

            /*
             * Returns the string version of a WebGL argument.
             * Attempts to convert enum arguments to strings.
             * @param {string} functionName the name of the WebGL function.
             * @param {number} argumentIndx the index of the argument.
             * @param {*} value The value of the argument.
             * @return {string} The value as a string.
             */
            function glFunctionArgToString(functionName, argumentIndex, value) {
                var funcInfo = glValidEnumContexts[functionName];
                if (funcInfo !== undefined) {
                    if (funcInfo[argumentIndex]) {
                        return glEnumToString(value);
                    }
                }
                if (value === null) {
                    return "null";
                } else if (value === undefined) {
                    return "undefined";
                } else {
                    return value.toString();
                }
            }

            /*
             * Converts the arguments of a WebGL function to a string.
             * Attempts to convert enum arguments to strings.
             *
             * @param {string} functionName the name of the WebGL function.
             * @param {number} args The arguments.
             * @return {string} The arguments as a string.
             */
            function glFunctionArgsToString(functionName, args) {
                // apparently we can't do args.join(",");
                var argStr = "";
                for (var ii = 0; ii < args.length; ++ii) {
                    argStr += ((ii == 0) ? '' : ', ') +
                        glFunctionArgToString(functionName, ii, args[ii]);
                }
                return argStr;
            };


            function makePropertyWrapper(wrapper, original, propertyName) {
                //log("wrap prop: " + propertyName);
                wrapper.__defineGetter__(propertyName, function() {
                    return original[propertyName];
                });
                // TODO(gmane): this needs to handle properties that take more than
                // one value?
                wrapper.__defineSetter__(propertyName, function(value) {
                    //log("set: " + propertyName);
                    original[propertyName] = value;
                });
            }

            // Makes a function that calls a function on another object.
            function makeFunctionWrapper(original, functionName) {
                //log("wrap fn: " + functionName);
                var f = original[functionName];
                return function() {
                    //log("call: " + functionName);
                    var result = f.apply(original, arguments);
                    return result;
                };
            }

            /*
             * Given a WebGL context returns a wrapped context that calls
             * gl.getError after every command and calls a function if the
             * result is not gl.NO_ERROR.
             *
             * @param {!WebGLRenderingContext} ctx The webgl context to
             *        wrap.
             * @param {!function(err, funcName, args): void} opt_onErrorFunc
             *        The function to call when gl.getError returns an
             *        error. If not specified the default function calls
             *        console.log with a message.
             * @param {!function(funcName, args): void} opt_onFunc The
             *        function to call when each webgl function is called.
             *        You can use this to log all calls for example.
             */
            function makeDebugContext(ctx, opt_onErrorFunc, opt_onFunc) {
                init(ctx);
                opt_onErrorFunc = opt_onErrorFunc || function(err, functionName, args) {
                    // apparently we can't do args.join(",");
                    var argStr = "";
                    for (var ii = 0; ii < args.length; ++ii) {
                        argStr += ((ii == 0) ? '' : ', ') +
                            glFunctionArgToString(functionName, ii, args[ii]);
                    }
                    error("WebGL error "+ glEnumToString(err) + " in "+ functionName +
                        "(" + argStr + ")");
                };

                // Holds booleans for each GL error so after we get the error ourselves
                // we can still return it to the client app.
                var glErrorShadow = { };

                // Makes a function that calls a WebGL function and then calls getError.
                function makeErrorWrapper(ctx, functionName) {
                    return function() {
                        if (opt_onFunc) {
                            opt_onFunc(functionName, arguments);
                        }
                        var result = ctx[functionName].apply(ctx, arguments);
                        var err = ctx.getError();
                        if (err != 0) {
                            glErrorShadow[err] = true;
                            opt_onErrorFunc(err, functionName, arguments);
                        }
                        return result;
                    };
                }

                // Make a an object that has a copy of every property of the WebGL context
                // but wraps all functions.
                var wrapper = {};
                for (var propertyName in ctx) {
                    if (typeof ctx[propertyName] == 'function') {
                        wrapper[propertyName] = makeErrorWrapper(ctx, propertyName);
                    } else {
                        makePropertyWrapper(wrapper, ctx, propertyName);
                    }
                }

                // Override the getError function with one that returns our saved results.
                wrapper.getError = function() {
                    for (var err in glErrorShadow) {
                        if (glErrorShadow.hasOwnProperty(err)) {
                            if (glErrorShadow[err]) {
                                glErrorShadow[err] = false;
                                return err;
                            }
                        }
                    }
                    return ctx.NO_ERROR;
                };

                return wrapper;
            }

            function resetToInitialState(ctx) {
                var numAttribs = ctx.getParameter(ctx.MAX_VERTEX_ATTRIBS);
                var tmp = ctx.createBuffer();
                ctx.bindBuffer(ctx.ARRAY_BUFFER, tmp);
                for (var ii = 0; ii < numAttribs; ++ii) {
                    ctx.disableVertexAttribArray(ii);
                    ctx.vertexAttribPointer(ii, 4, ctx.FLOAT, false, 0, 0);
                    ctx.vertexAttrib1f(ii, 0);
                }
                ctx.deleteBuffer(tmp);

                var numTextureUnits = ctx.getParameter(ctx.MAX_TEXTURE_IMAGE_UNITS);
                for (var ii = 0; ii < numTextureUnits; ++ii) {
                    ctx.activeTexture(ctx.TEXTURE0 + ii);
                    ctx.bindTexture(ctx.TEXTURE_CUBE_MAP, null);
                    ctx.bindTexture(ctx.TEXTURE_2D, null);
                }

                ctx.activeTexture(ctx.TEXTURE0);
                ctx.useProgram(null);
                ctx.bindBuffer(ctx.ARRAY_BUFFER, null);
                ctx.bindBuffer(ctx.ELEMENT_ARRAY_BUFFER, null);
                ctx.bindFramebuffer(ctx.FRAMEBUFFER, null);
                ctx.bindRenderbuffer(ctx.RENDERBUFFER, null);
                ctx.disable(ctx.BLEND);
                ctx.disable(ctx.CULL_FACE);
                ctx.disable(ctx.DEPTH_TEST);
                ctx.disable(ctx.DITHER);
                ctx.disable(ctx.SCISSOR_TEST);
                ctx.blendColor(0, 0, 0, 0);
                ctx.blendEquation(ctx.FUNC_ADD);
                ctx.blendFunc(ctx.ONE, ctx.ZERO);
                ctx.clearColor(0, 0, 0, 0);
                ctx.clearDepth(1);
                ctx.clearStencil(-1);
                ctx.colorMask(true, true, true, true);
                ctx.cullFace(ctx.BACK);
                ctx.depthFunc(ctx.LESS);
                ctx.depthMask(true);
                ctx.depthRange(0, 1);
                ctx.frontFace(ctx.CCW);
                ctx.hint(ctx.GENERATE_MIPMAP_HINT, ctx.DONT_CARE);
                ctx.lineWidth(1);
                ctx.pixelStorei(ctx.PACK_ALIGNMENT, 4);
                ctx.pixelStorei(ctx.UNPACK_ALIGNMENT, 4);
                ctx.pixelStorei(ctx.UNPACK_FLIP_Y_WEBGL, false);
                ctx.pixelStorei(ctx.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
                // TODO: Delete this IF.
                if (ctx.UNPACK_COLORSPACE_CONVERSION_WEBGL) {
                    ctx.pixelStorei(ctx.UNPACK_COLORSPACE_CONVERSION_WEBGL, ctx.BROWSER_DEFAULT_WEBGL);
                }
                ctx.polygonOffset(0, 0);
                ctx.sampleCoverage(1, false);
                ctx.scissor(0, 0, ctx.canvas.width, ctx.canvas.height);
                ctx.stencilFunc(ctx.ALWAYS, 0, 0xFFFFFFFF);
                ctx.stencilMask(0xFFFFFFFF);
                ctx.stencilOp(ctx.KEEP, ctx.KEEP, ctx.KEEP);
                ctx.viewport(0, 0, ctx.canvas.width, ctx.canvas.height);
                ctx.clear(ctx.COLOR_BUFFER_BIT | ctx.DEPTH_BUFFER_BIT | ctx.STENCIL_BUFFER_BIT);

                // TODO: This should NOT be needed but Firefox fails with 'hint'
                while(ctx.getError());
            }

            function makeLostContextSimulatingCanvas(canvas) {
                var unwrappedContext_;
                var wrappedContext_;
                var onLost_ = [];
                var onRestored_ = [];
                var wrappedContext_ = {};
                var contextId_ = 1;
                var contextLost_ = false;
                var resourceId_ = 0;
                var resourceDb_ = [];
                var numCallsToLoseContext_ = 0;
                var numCalls_ = 0;
                var canRestore_ = false;
                var restoreTimeout_ = 0;

                // Holds booleans for each GL error so can simulate errors.
                var glErrorShadow_ = { };

                canvas.getContext = function(f) {
                    return function() {
                        var ctx = f.apply(canvas, arguments);
                        // Did we get a context and is it a WebGL context?
                        if (ctx instanceof WebGLRenderingContext) {
                            if (ctx != unwrappedContext_) {
                                if (unwrappedContext_) {
                                    throw "got different context"
                                }
                                unwrappedContext_ = ctx;
                                wrappedContext_ = makeLostContextSimulatingContext(unwrappedContext_);
                            }
                            return wrappedContext_;
                        }
                        return ctx;
                    }
                }(canvas.getContext);

                function wrapEvent(listener) {
                    if (typeof(listener) == "function") {
                        return listener;
                    } else {
                        return function(info) {
                            listener.handleEvent(info);
                        }
                    }
                }

                var addOnContextLostListener = function(listener) {
                    onLost_.push(wrapEvent(listener));
                };

                var addOnContextRestoredListener = function(listener) {
                    onRestored_.push(wrapEvent(listener));
                };


                function wrapAddEventListener(canvas) {
                    var f = canvas.addEventListener;
                    canvas.addEventListener = function(type, listener, bubble) {
                        switch (type) {
                        case 'webglcontextlost':
                            addOnContextLostListener(listener);
                            break;
                        case 'webglcontextrestored':
                            addOnContextRestoredListener(listener);
                            break;
                        default:
                            f.apply(canvas, arguments);
                        }
                    };
                }

                wrapAddEventListener(canvas);

                canvas.loseContext = function() {
                    if (!contextLost_) {
                        contextLost_ = true;
                        numCallsToLoseContext_ = 0;
                        ++contextId_;
                        while (unwrappedContext_.getError());
                        clearErrors();
                        glErrorShadow_[unwrappedContext_.CONTEXT_LOST_WEBGL] = true;
                        var event = makeWebGLContextEvent("context lost");
                        var callbacks = onLost_.slice();
                        setTimeout(function() {
                            //log("numCallbacks:" + callbacks.length);
                            for (var ii = 0; ii < callbacks.length; ++ii) {
                                //log("calling callback:" + ii);
                                callbacks[ii](event);
                            }
                            if (restoreTimeout_ >= 0) {
                                setTimeout(function() {
                                    canvas.restoreContext();
                                }, restoreTimeout_);
                            }
                        }, 0);
                    }
                };

                canvas.restoreContext = function() {
                    if (contextLost_) {
                        if (onRestored_.length) {
                            setTimeout(function() {
                                if (!canRestore_) {
                                    throw "can not restore. webglcontestlost listener did not call event.preventDefault";
                                }
                                freeResources();
                                resetToInitialState(unwrappedContext_);
                                contextLost_ = false;
                                numCalls_ = 0;
                                canRestore_ = false;
                                var callbacks = onRestored_.slice();
                                var event = makeWebGLContextEvent("context restored");
                                for (var ii = 0; ii < callbacks.length; ++ii) {
                                    callbacks[ii](event);
                                }
                            }, 0);
                        }
                    }
                };

                canvas.loseContextInNCalls = function(numCalls) {
                    if (contextLost_) {
                        throw "You can not ask a lost context to be lost";
                    }
                    numCallsToLoseContext_ = numCalls_ + numCalls;
                };

                canvas.getNumCalls = function() {
                    return numCalls_;
                };

                canvas.setRestoreTimeout = function(timeout) {
                    restoreTimeout_ = timeout;
                };

                function isWebGLObject(obj) {
                    //return false;
                    return (obj instanceof WebGLBuffer ||
                        obj instanceof WebGLFramebuffer ||
                        obj instanceof WebGLProgram ||
                        obj instanceof WebGLRenderbuffer ||
                        obj instanceof WebGLShader ||
                        obj instanceof WebGLTexture);
                }

                function checkResources(args) {
                    for (var ii = 0; ii < args.length; ++ii) {
                        var arg = args[ii];
                        if (isWebGLObject(arg)) {
                            return arg.__webglDebugContextLostId__ == contextId_;
                        }
                    }
                    return true;
                }

                function clearErrors() {
                    var k = Object.keys(glErrorShadow_);
                    for (var ii = 0; ii < k.length; ++ii) {
                        delete glErrorShadow_[k];
                    }
                }

                function loseContextIfTime() {
                    ++numCalls_;
                    if (!contextLost_) {
                        if (numCallsToLoseContext_ == numCalls_) {
                            canvas.loseContext();
                        }
                    }
                }

                // Makes a function that simulates WebGL when out of context.
                function makeLostContextFunctionWrapper(ctx, functionName) {
                    var f = ctx[functionName];
                    return function() {
                        // log("calling:" + functionName);
                        // Only call the functions if the context is not lost.
                        loseContextIfTime();
                        if (!contextLost_) {
                            //if (!checkResources(arguments)) {
                            //  glErrorShadow_[wrappedContext_.INVALID_OPERATION] = true;
                            //  return;
                            //}
                            try{
                                var result = f.apply(ctx, arguments);
                                return result;
                            }catch (e){
                                debugger;
                                return null;
                            }
                        }
                    };
                }

                function freeResources() {
                    for (var ii = 0; ii < resourceDb_.length; ++ii) {
                        var resource = resourceDb_[ii];
                        if (resource instanceof WebGLBuffer) {
                            unwrappedContext_.deleteBuffer(resource);
                        } else if (resource instanceof WebGLFramebuffer) {
                            unwrappedContext_.deleteFramebuffer(resource);
                        } else if (resource instanceof WebGLProgram) {
                            unwrappedContext_.deleteProgram(resource);
                        } else if (resource instanceof WebGLRenderbuffer) {
                            unwrappedContext_.deleteRenderbuffer(resource);
                        } else if (resource instanceof WebGLShader) {
                            unwrappedContext_.deleteShader(resource);
                        } else if (resource instanceof WebGLTexture) {
                            unwrappedContext_.deleteTexture(resource);
                        }
                    }
                }

                function makeWebGLContextEvent(statusMessage) {
                    return {
                        statusMessage: statusMessage,
                        preventDefault: function() {
                            canRestore_ = true;
                        }
                    };
                }

                return canvas;

                function makeLostContextSimulatingContext(ctx) {
                    // copy all functions and properties to wrapper
                    for (var propertyName in ctx) {
                        if (typeof ctx[propertyName] == 'function') {
                            wrappedContext_[propertyName] = makeLostContextFunctionWrapper(
                                ctx, propertyName);
                        } else {
                            makePropertyWrapper(wrappedContext_, ctx, propertyName);
                        }
                    }

                    // Wrap a few functions specially.
                    wrappedContext_.getError = function() {
                        loseContextIfTime();
                        if (!contextLost_) {
                            var err;
                            while (err = unwrappedContext_.getError()) {
                                glErrorShadow_[err] = true;
                            }
                        }
                        for (var err in glErrorShadow_) {
                            if (glErrorShadow_[err]) {
                                delete glErrorShadow_[err];
                                return err;
                            }
                        }
                        return wrappedContext_.NO_ERROR;
                    };

                    var creationFunctions = [
                        "createBuffer",
                        "createFramebuffer",
                        "createProgram",
                        "createRenderbuffer",
                        "createShader",
                        "createTexture"
                    ];
                    for (var ii = 0; ii < creationFunctions.length; ++ii) {
                        var functionName = creationFunctions[ii];
                        wrappedContext_[functionName] = function(f) {
                            return function() {
                                loseContextIfTime();
                                if (contextLost_) {
                                    return null;
                                }
                                var obj = f.apply(ctx, arguments);
                                obj.__webglDebugContextLostId__ = contextId_;
                                resourceDb_.push(obj);
                                return obj;
                            };
                        }(ctx[functionName]);
                    }

                    var functionsThatShouldReturnNull = [
                        "getActiveAttrib",
                        "getActiveUniform",
                        "getBufferParameter",
                        "getContextAttributes",
                        "getAttachedShaders",
                        "getFramebufferAttachmentParameter",
                        "getParameter",
                        "getProgramParameter",
                        "getProgramInfoLog",
                        "getRenderbufferParameter",
                        "getShaderParameter",
                        "getShaderInfoLog",
                        "getShaderSource",
                        "getTexParameter",
                        "getUniform",
                        "getUniformLocation",
                        "getVertexAttrib"
                    ];
                    for (var ii = 0; ii < functionsThatShouldReturnNull.length; ++ii) {
                        var functionName = functionsThatShouldReturnNull[ii];
                        wrappedContext_[functionName] = function(f) {
                            return function() {
                                loseContextIfTime();
                                if (contextLost_) {
                                    return null;
                                }
                                return f.apply(ctx, arguments);
                            }
                        }(wrappedContext_[functionName]);
                    }

                    var isFunctions = [
                        "isBuffer",
                        "isEnabled",
                        "isFramebuffer",
                        "isProgram",
                        "isRenderbuffer",
                        "isShader",
                        "isTexture"
                    ];
                    for (var ii = 0; ii < isFunctions.length; ++ii) {
                        var functionName = isFunctions[ii];
                        wrappedContext_[functionName] = function(f) {
                            return function() {
                                loseContextIfTime();
                                if (contextLost_) {
                                    return false;
                                }
                                return f.apply(ctx, arguments);
                            }
                        }(wrappedContext_[functionName]);
                    }

                    wrappedContext_.checkFramebufferStatus = function(f) {
                        return function() {
                            loseContextIfTime();
                            if (contextLost_) {
                                return wrappedContext_.FRAMEBUFFER_UNSUPPORTED;
                            }
                            return f.apply(ctx, arguments);
                        };
                    }(wrappedContext_.checkFramebufferStatus);

                    wrappedContext_.getAttribLocation = function(f) {
                        return function() {
                            loseContextIfTime();
                            if (contextLost_) {
                                return -1;
                            }
                            return f.apply(ctx, arguments);
                        };
                    }(wrappedContext_.getAttribLocation);

                    wrappedContext_.getVertexAttribOffset = function(f) {
                        return function() {
                            loseContextIfTime();
                            if (contextLost_) {
                                return 0;
                            }
                            return f.apply(ctx, arguments);
                        };
                    }(wrappedContext_.getVertexAttribOffset);

                    wrappedContext_.isContextLost = function() {
                        return contextLost_;
                    };

                    return wrappedContext_;
                }
            }

            return {
                /**
                 * Initializes this module. Safe to call more than once.
                 *
                 * @method init
                 * @param {!WebGLRenderingContext} ctx A WebGL context. If
                 *    you have more than one context it doesn't matter which one
                 *    you pass in, it is only used to pull out constants.
                 */
                'init': init,

                /**
                 * Returns true or false if value matches any WebGL enum
                 *
                 * @method mightBeEnum
                 * @param {*} value Value to check if it might be an enum.
                 * @return {boolean} True if value matches one of the WebGL defined enums
                 */
                'mightBeEnum': mightBeEnum,

                /**
                 * Gets an string version of an WebGL enum.
                 *
                 * @example
                 *     WebGLDebugUtil.init(ctx);
                 *     var str = WebGLDebugUtil.glEnumToString(ctx.getError());
                 *
                 * @method glFunctionArgToString
                 * @param {number} value Value to return an enum for
                 * @return {string} The string version of the enum.
                 */
                'glEnumToString': glEnumToString,

                /**
                 * Converts the argument of a WebGL function to a string.
                 * Attempts to convert enum arguments to strings.
                 *
                 * @example
                 *     WebGLDebugUtil.init(ctx);
                 *     var str = WebGLDebugUtil.glFunctionArgToString('bindTexture', 0, gl.TEXTURE_2D);
                 *
                 * would return 'TEXTURE_2D'
                 *
                 * @method glFunctionArgToString
                 * @param {string} functionName the name of the WebGL function.
                 * @param {number} argumentIndx the index of the argument.
                 * @param {*} value The value of the argument.
                 * @return {string} The value as a string.
                 */
                'glFunctionArgToString': glFunctionArgToString,

                /**
                 * Converts the arguments of a WebGL function to a string.
                 * Attempts to convert enum arguments to strings.
                 *
                 * @method glFunctionArgsToString
                 * @param {string} functionName the name of the WebGL function.
                 * @param {number} args The arguments.
                 * @return {string} The arguments as a string.
                 */
                'glFunctionArgsToString': glFunctionArgsToString,

                /**
                 * Given a WebGL context returns a wrapped context that calls
                 * gl.getError after every command and calls a function if the
                 * result is not NO_ERROR.
                 *
                 * You can supply your own function if you want. For example, if you'd like
                 * an exception thrown on any GL error you could do this
                 *
                 * @example
                 *      function throwOnGLError(err, funcName, args) {
                 *        throw WebGLDebugUtils.glEnumToString(err) +
                 *              " was caused by call to " + funcName;
                 *      };
                 *      ctx = WebGLDebugUtils.makeDebugContext(
                 *          canvas.getContext("webgl"), throwOnGLError);
                 *
                 * @method makeDebugContext
                 * @param {!WebGLRenderingContext} ctx The webgl context to wrap.
                 * @param {!function(err, funcName, args): void} opt_onErrorFunc The function
                 *     to call when gl.getError returns an error. If not specified the default
                 *     function calls console.log with a message.
                 * @param {!function(funcName, args): void} opt_onFunc The
                 *     function to call when each webgl function is called. You
                 *     can use this to log all calls for example.
                 */
                'makeDebugContext': makeDebugContext,

                /**
                 * Given a canvas element returns a wrapped canvas element that will
                 * simulate lost context. The canvas returned adds the following functions.
                 *
                 * loseContext:
                 *   simulates a lost context event.
                 *
                 * restoreContext:
                 *   simulates the context being restored.
                 *
                 * lostContextInNCalls:
                 *   loses the context after N gl calls.
                 *
                 * getNumCalls:
                 *   tells you how many gl calls there have been so far.
                 *
                 * setRestoreTimeout:
                 *   sets the number of milliseconds until the context is restored
                 *   after it has been lost. Defaults to 0. Pass -1 to prevent
                 *   automatic restoring.
                 *
                 * @method makeLostContextSimulatingCanvas
                 * @param {!Canvas} canvas The canvas element to wrap.
                 */
                'makeLostContextSimulatingCanvas': makeLostContextSimulatingCanvas,

                /**
                 * Resets a context to the initial state.
                 * @method resetToInitialState
                 * @param {!WebGLRenderingContext} ctx The webgl context to
                 *     reset.
                 */
                'resetToInitialState': resetToInitialState
            };

        }();
    }
});

define('kick/core/Shim',[], function () {
    

    /* ////// Removed from documentation /////
     * Adds requestAnimationFrame as window.requestAnimationFrame
     * @class Shim
     * @namespace kick.core
     */
    if (typeof window.requestAnimationFrame === "undefined") {
        window.requestAnimationFrame = (function () {
            return window.requestAnimationFrame   ||
                window.webkitRequestAnimationFrame ||
                window.mozRequestAnimationFrame    ||
                window.oRequestAnimationFrame      ||
                window.msRequestAnimationFrame     ||
                function (/* function */ callback, /* DOMElement */ element) {
                    var fps60 = 16.7;
                    return window.setTimeout(callback, fps60, Date.now());
                };
        })();
    }
    if (typeof window.cancelAnimationFrame === "undefined") {
        window.cancelAnimationFrame = (function () {
            return window.cancelAnimationFrame          ||
                window.cancelRequestAnimFrame               ||
                window.webkitCancelRequestAnimationFrame    ||
                window.mozCancelRequestAnimationFrame       ||
                window.oCancelRequestAnimationFrame     ||
                window.msCancelRequestAnimationFrame        ||
                clearTimeout;
        } )();
    }

    // workaround for undefined consoles
    if (typeof window.console === "undefined") {
        window.console = {};
    }
    if (typeof window.console.log === "undefined") {
        window.console.log = function (v) {
            alert (v);
        };
    }
});


define('kick/core/Engine',["require", "./GLState", "./Project", "./Constants", "./ResourceLoader", "./MouseInput", "./KeyInput", "./Config", "./Util", "./EventQueue", "kick/scene/Scene", "kick/math", "./Time", "./WebGLDebugUtils", "./EngineSingleton", "./Observable", "./Shim"],
    function (require, GLState, Project, Constants, ResourceLoader, MouseInput, KeyInput, Config, Util, EventQueue, Scene, math, Time, WebGLDebugUtils, EngineSingleton, Observable, Shim_NotUsed) {
        

        var ASSERT = true,
            engineInstance = null,
            engine;

        /**
         * @module kick.core
         */

        /**
         * Game engine object
         * @example
         *      <canvas id="3dCanvas" width="50" height="50"></canvas>
         *      <script src="require.js"></script>
         *      <script type="text/javascript">
         *          var req = require.config({
         *                  paths: {
         *                      kick: 'kick-debug' // loads kick-debug.js (must be in same path)
         *                  }
         *              });
         *          req(['kick'],
         *                  function (kick) {
         *                      // init engine (create 3d context)
         *                      var engine = new kick.core.Engine('3dCanvas');
         *                  }
         *          );
         *      </script>
         * @class Engine
         * @namespace kick.core
         * @constructor
         * @param {String|canvas} idOrElement elementid of canvas tag or the canvas element
         * @param {kick.core.Config} config={} Configuration object
         */
        engine = function (idOrElement, config) {
            var glState,
                gl = null,
                canvas = typeof idOrElement === 'string' ? document.getElementById(idOrElement) : idOrElement,
                webGlContextNames = ["experimental-webgl", "webgl"],
                thisObj = this,
                lastTime = Date.now() - 16, // ensures valid delta time in next frame
                deltaTime = 0,
                timeObj = new Time(),
                timeSinceStart = 0,
                frame = 0,
                timeScale = 1,
                eventQueue,
                project = new Project(this),
                mouseInput = null,
                keyInput = null,
                activeScene,
                canvasSize = new Float32Array(2),
                activeSceneNull = {updateAndRender: function () {}},
                animationFrameObj = {},
                wrapperFunctionToMethodOnObject = function (time_) {
                    if (time_ < 1e12) { // if highres timer. see http://updates.html5rocks.com/2012/05/requestAnimationFrame-API-now-with-sub-millisecond-precision
                        time_ = Date.now();
                    }
                    thisObj._gameLoop(time_);
                };

            Observable.call(this, [
                /**
                 * Fired when gl-context is lost
                 * @event contextLost
                 */
                "contextLost",
                /**
                 * Fired when gl-context is restored (after context has been lost).
                 * @event contextRestored
                 * @param {WebGLRenderingContext} glContext
                 */
                "contextRestored",
                /**
                 * Fired before script updates methods has been run invoked
                 * @event preUpdateListener
                 */
                "preUpdateListener",
                /**
                 * Fired after script updates methods has been run invoked
                 * @event postUpdateListener
                 */
                "postUpdateListener",
                /**
                 * Fired when canvas is resized.
                 * @event canvasResized
                 * @param {kick.math.Vec2} newCanvasDimensions
                 */
                "canvasResized"
            ]
            );

            Object.defineProperties(this, {
                /**
                 * The current version of KickJS
                 * @property version
                 * @type String
                 * @final
                 */
                version: {
                    value: "0.5.5"
                },
                /**
                 * Resource manager of the engine. Loads and cache resources.
                 * @property resourceLoader
                 * @type kick.core.ResourceLoader
                 * @final
                 */
                resourceLoader: {
                    value: new ResourceLoader(thisObj)
                },
                /**
                 * Project describes the resources available for a given projects (such as Scenes, Materials, Shader and Meshes)
                 * @property project
                 * @type kick.core.Project
                 * @final
                 */
                project: {
                    value: project
                },
                /**
                 * The WebGL state(readonly). (Only used to keep track on webgl state across different objects)
                 * @property glState
                 * @type kick.core.GLState
                 * @protected
                 * @final
                 */
                glState: {
                    get: function () { return glState; }
                },
                /**
                 * The WebGL context (readonly)
                 * @property gl
                 * @type WebGLRenderingContext
                 * @final
                 */
                gl: {
                    get: function () { return gl; }
                },
                /**
                 * The canvas element (readonly)
                 * @property canvas
                 * @type HTML-Element
                 * @final
                 */
                canvas: {
                    value: canvas
                },
                /**
                 * If null then nothing is rendered
                 * @property activeScene
                 * @type kick.scene.Scene
                 */
                activeScene: {
                    get: function () {
                        if (activeScene === activeSceneNull) {
                            return null;
                        }
                        return activeScene;
                    },
                    set: function (value) {
                        if (value === null || value === undefined) {
                            activeScene = activeSceneNull;
                        } else {
                            activeScene = value;
                        }
                    }
                },
                /**
                 * Returns a mouseInput object. This object is used to detect mouse input.
                 * @property mouseInput
                 * @type kick.core.MouseInput
                 */
                mouseInput: {
                    get: function () {
                        if (!mouseInput) {
                            mouseInput = new MouseInput(thisObj);
                            thisObj.addEventListener('postUpdateListener', mouseInput.frameUpdated);
                        }
                        return mouseInput;
                    }
                },
                /**
                 * Returns a keyInput object. This object is used to detect key input.
                 * @property keyInput
                 * @type kick.core.KeyInput
                 */
                keyInput: {
                    get: function () {
                        if (!keyInput) {
                            keyInput = new KeyInput();
                            thisObj.addEventListener('postUpdateListener', keyInput.frameUpdated);
                        }
                        return keyInput;
                    }
                },
                /**
                 * @property eventQueue
                 * @type kick.core.EventQueue
                 * @final
                 */
                eventQueue: {
                    get: function () {
                        return eventQueue;
                    }
                },
                /**
                 * The width and height of the canvas
                 * @property canvasDimension
                 * @type kick.math.Vec2
                 */
                canvasDimension: {
                    get: function () {
                        return canvasSize;
                    }
                },
                /**
                 * Time object of the engine. Is updated every frame
                 * @property time
                 * @type kick.core.Time
                 */
                time: {
                    value: timeObj
                },
                /**
                 * Configuration of the engine
                 * @property config
                 * @type kick.core.Config
                 */
                config: {
                    value: new Config(config || {})
                },
                /**
                 * Controls is the gameloop is running
                 * @property paused
                 * @type boolean
                 */
                paused: {
                    get: function () {
                        return animationFrameObj === null;
                    },
                    set: function (pause) {
                        var currentValue = thisObj.paused;
                        if (pause !== currentValue) {
                            if (pause) {
                                window.cancelAnimationFrame(animationFrameObj);
                                animationFrameObj = null;
                            } else {
                                lastTime = Date.now() - 16; // ensures valid delta time in next frame
                                animationFrameObj = window.requestAnimationFrame(wrapperFunctionToMethodOnObject, thisObj.canvas);
                            }
                        }
                    }
                }
            });

            /**
             * @method isFullScreenSupported
             * @return Boolean
             */
            this.isFullScreenSupported = function () {
                return canvas.requestFullscreen || canvas.webkitRequestFullScreen || canvas.mozRequestFullScreen;
            };

            /**
             * Query WebGL for a specific extension. If found, the extension object is returned.
             * "WEBKIT\_", "MOZ\_" vendor prefixes are used.
             * @method getGLExtension
             * @param {String} extensionName
             * @return Object|null
             */
            this.getGLExtension = function (extensionName) {
                var vendorPrefixes = ["", "WEBKIT_", "MOZ_"],
                    i,
                    ext;
                for(i = 0;i < vendorPrefixes.length; i++) {
                    ext = gl.getExtension(vendorPrefixes[i] + extensionName);
                    if (ext) {
                        return ext;
                    }
                }
                return null;
            };

            /**
             * Note that fullscreen needs to be invoked directly from a keyboard event or a mouse event from outside the
             * gameLoop. This means it is currently not possible to set fullscreen from a Component's update method.
             * @method setFullscreen
             * @param {Boolean} fullscreen
             */
            this.setFullscreen = function (fullscreen) {
                if (thisObj.isFullScreenSupported()) {
                    if (fullscreen) {
                        if (canvas.requestFullscreen) {
                            canvas.requestFullscreen();
                        } else if (canvas.webkitRequestFullScreen) {
                            canvas.onwebkitfullscreenchange = function () {
                                if (document.webkitIsFullScreen) {
                                    canvas.originalWidth = canvas.width;
                                    canvas.originalHeight = canvas.height;
                                    canvas.width = screen.width;
                                    canvas.height = screen.height;
                                } else {
                                    canvas.width = canvas.originalWidth;
                                    canvas.height = canvas.originalHeight;
                                }
                            };
                            canvas.webkitRequestFullScreen(Element.ALLOW_KEYBOARD_INPUT);
                        } else if (canvas.mozRequestFullScreen) {
                            canvas.mozRequestFullScreen();
                        }
                    } else {
                        if (document.exitFullscreen) {
                            document.exitFullscreen();
                        } else if (document.webkitCancelFullScreen) {
                            document.webkitCancelFullScreen();
                        } else if (document.webkitCancelFullScreen) {
                            document.webkitCancelFullScreen();
                        }
                    }
                }
            };

            /**
             * @method _gameLoop
             * @param {Number} time current time in milliseconds
             * @private
             */
            this._gameLoop = function (time) {
                if (canvas.width !== canvasSize[0] || canvas.height !== canvasSize[1]){
                    canvasSize[0] = canvas.width;
                    canvasSize[1] = canvas.height;
                    thisObj.fireEvent("canvasResized",canvasSize);
                }
                deltaTime = time - lastTime;
                lastTime = time;
                deltaTime *= timeScale;
                timeSinceStart += deltaTime;
                frame += 1;
                eventQueue.run();

                activeScene.updateAndRender();
                thisObj.fireEvent("postUpdateListener");

                if (animationFrameObj !== null) {
                    animationFrameObj = window.requestAnimationFrame(wrapperFunctionToMethodOnObject, thisObj.canvas);
                }
            };

            /**
             * Add a framelistener. Frame listeners are invoked last thing in update loop.<br>
             * Frame listener object must define the method frameUpdated()
             * @method addFrameListener
             * @param {Object} frameListener
             * @deprecated Use addEventListener("postUpdateListener", frameListener) instead
             */
            this.addFrameListener = function (frameListener) {
                Util.fail("Use addEventListener('postUpdateListener', frameListener) instead");
                thisObj.addEventListener("postUpdateListener", frameListener);
            };

            /**
             * @method removeFrameListener
             * @param {Object} frameListener
             * @deprecated
             */
            this.removeFrameListener = function (frameListener) {
                Util.fail("Use removeEventListener('postUpdateListener', frameListener) instead");
                thisObj.removeEventListener("postUpdateListener", frameListener);
            };

            /**
             * @method addContextListener
             * @param {Object} contextLostListener implements contextLost() and contextRestored(gl)
             * @deprecated
             */
            this.addContextListener = function (contextLostListener) {
                Util.fail("Use addEventListener('contextLost', fn) / addEventListener('contextRestored', fn)  instead");
                thisObj.addEventListener("contextLost", contextLostListener.contextLost);
                thisObj.addEventListener("contextRestored", contextLostListener.contextRestored);
            };

            /**
             * @method removeContextListener
             * @param contextLostListener
             * @deprecated
             */
            this.removeContextListener = function (contextLostListener) {
                Util.fail("Use removeEventListener('contextLost', fn) / removeEventListener('contextRestored', fn)  instead");
                thisObj.removeEventListener("contextLost", contextLostListener.contextLost);
                thisObj.removeEventListener("contextRestored", contextLostListener.contextRestored);
            };


            /**
             * Creates a uniq id
             * @method createUID
             * @return {Number} uniq id
             */
            this.createUID = function () {
                return ++project.maxUID;
            };

            /**
             * Get the uid of a component (or creates the uid if not defined)
             * @method getUID
             * @param {Object} object
             * @return {String}
             */
            this.getUID = function (object) {
                if (!object.uid) {
                    object.uid = thisObj.createUID();
                }
                return object.uid;
            };

            /**
             * This method should be invoked when the canvas is resized.<br>
             * This will change the viewport size of the WebGL state.<br>
             * Instead of calling this method explicit, the configuration parameter
             * checkCanvasResizeInterval can also be set to support automatically checks
             * @method canvasResized
             * @deprecated
             */
            /*this.canvasResized = function () {
                Util.warn("kick.core.Engine.canvasResized is deprecated");
                glState.viewportSize = thisObj.canvasDimension;
                if (mouseInput) {
                    mouseInput.updateCanvasElementPosition();
                }
            };*/

            /**
             * @method init
             * @private
             */
            (function init() {
                var c = Constants,
                    i,
                    success,
                    wasPaused,
                    initGL = function () {
                        if (thisObj.config.highDPISupport) {
                            var devicePixelRatio = window.devicePixelRatio || 1;

                            // set the size of the drawingBuffer based on the size it's displayed.
                            canvas.width = canvas.clientWidth * devicePixelRatio;
                            canvas.height = canvas.clientHeight * devicePixelRatio;
                        }
                        for (i = webGlContextNames.length - 1; i >= 0; i--) {
                            try {
                                gl = canvas.getContext(webGlContextNames[i], thisObj.config);
                                if (gl) {
                                    break;
                                }
                            } catch (e) {
                                // ignore
                                alert(e);
                            }
                        }
                        if (!gl) {
                            return false;
                        }
                        if (thisObj.config.enableDebugContext) {
                            if (WebGLDebugUtils && true) {
                                // Checking that none of the WebGL arguments are undefined
                                // http://www.khronos.org/webgl/wiki/Debugging#Checking_that_none_of_your_arguments_are_undefined
                                var validateNoneOfTheArgsAreUndefined = function (functionName, args) {
                                    var ii;
                                    for (ii = 0; ii < args.length; ++ii) {
                                        if (args[ii] === undefined) {
                                            console.error("undefined passed to gl." + functionName + "(" +
                                                WebGLDebugUtils.glFunctionArgsToString(functionName, args) + ")");
                                        }
                                    }
                                };
                                gl = WebGLDebugUtils.makeDebugContext(gl, undefined, validateNoneOfTheArgsAreUndefined);
                            } else {
                                console.log("webgl-debug.js not included - cannot find WebGLDebugUtils");
                            }
                        }
                        glState = new GLState(thisObj);
                        Object.freeze(gl);
                        gl.enable(2929);
                        gl.enable(3089);
                        return true;
                    };
                EngineSingleton.engine = thisObj;
                engineInstance = thisObj;

                success = initGL();
                if (!success) {
                    thisObj.config.webglNotFoundFn(canvas);
                    return;
                }
                if (window.console && window.console.log){
                    console.log("KickJS "+thisObj.version);
                }
                canvas.addEventListener("webglcontextlost", function (event) {
                    wasPaused = thisObj.paused;
                    thisObj.paused = true;
                    thisObj.fireEvent("contextLost");
                    event.preventDefault();
                    gl = null;
                }, false);
                canvas.addEventListener("webglcontextrestored", function (event) {
                    glState.clear();
                    initGL();
                    thisObj.fireEvent("contextRestored", gl);
                    // restart rendering loop
                    if (!wasPaused) {
                        thisObj.paused = false;
                    }
                    event.preventDefault();
                }, false);

                // API documentation of Time is found in kick.core.Time
                Object.defineProperties(timeObj, {
                    time: {
                        get: function () { return timeSinceStart; }
                    },
                    deltaTime: {
                        get: function () { return deltaTime; }
                    },
                    frame: {
                        get: function () { return frame; }
                    },
                    scale: {
                        get: function () {
                            return timeScale;
                        },
                        set: function (newValue) {
                            timeScale = newValue;
                        }
                    }
                });
                Object.freeze(timeObj);

                activeScene = new Scene();
                eventQueue = new EventQueue(thisObj);

                timeSinceStart = 0;
                frame = 0;

                thisObj._gameLoop(lastTime);
            }());
        };
        Object.defineProperties(engine, {
            /**
             * Returns the singleton engine object
             * @property instance
             * @type kick.core.Engine
             * @static
             */
            instance: {
                get: function () {
                    return engineInstance;
                }
            }
        });
        return engine;
    }
    );

define('kick/core/ResourceProvider',[], function () {
    

    /**
     * Responsible for creating or loading a resource using a given url.
     * Abstract class (only defines the interface - inheritance not supported)
     * @class ResourceProvider
     * @namespace kick.core
     * @constructor
     * @param {String} protocol
     */
    /**
     * Protocol of the resource, such as http://, kickjs://<br>
     * The protocol must uniquely identify a resource provider
     * @property protocol
     * @type String
     */

    /**
     * @method getMeshData
     * @param {String} uri
     * @param {kick.mesh.Mesh} meshDestination
     */
    /**
     * @method getImageData
     * @param {String} uri
     * @param {kick.texture.Texture} textureDestination
     */
    /**
     * @method getShaderData
     * @param {String} uri
     * @param {kick.material.Shader} shaderDestination
     */
    return {};
});

define('kick/core/Graphics',["kick/core/Constants", "kick/scene/Camera", "kick/scene/Transform", "kick/scene/EngineUniforms","kick/scene/MeshRenderer", "kick/math/Mat4", "kick/core/EngineSingleton", "kick/texture/RenderTexture", "kick/core/Util", "kick/material/Material"],
    function (constants, Camera, Transform, EngineUniforms, MeshRenderer, Mat4, EngineSingleton, RenderTexture, Util, Material) {
        
        var ASSERT = true,
            fail = Util.fail;
        /**
         * A helper-class used for rendering.
         *
         * @class Graphics
         * @namespace kick.core
         */
        return {
            /**
             * @method drawQuad
             * @param {kick.material.Material} material
             * @param {kick.math.Vec4} [normalizedViewportRect=[0,0,1,1]]
             * @static
             */
            drawQuad: (function(){
                var camera,
                    engine,
                    engineUniforms,
                    meshRenderer;
                return function(material, normalizedViewportRect){
                    normalizedViewportRect  = normalizedViewportRect || [0,0,1,1];
                    if (!camera){
                        engine = EngineSingleton.engine;
                        camera = new Camera({
                            perspective: false,
                            left:-1,
                            right:1,
                            top:1,
                            bottom:-1,
                            near:-1,
                            far:1
                        });
                        camera.gameObject = {
                            transform: new Transform(),
                            scene: {
                                addEventListener: function(){},
                                findComponentsWithMethod: function(){return [];}
                            }
                        };
                        camera.activated();

                        engineUniforms = new EngineUniforms({
                            viewMatrix:  Mat4.identity(Mat4.create()),
                            projectionMatrix: Mat4.identity(Mat4.create()),
                            viewProjectionMatrix: Mat4.identity(Mat4.create()),
                            lightMatrix: Mat4.identity(Mat4.create()),
                            currentCamera: camera,
                            currentCameraTransform: camera.gameObject.transform
                        });
                        engineUniforms.sceneLights = {};
                        meshRenderer = new MeshRenderer({
                            mesh: engine.project.load(engine.project.ENGINE_MESH_PLANE),
                            material: material
                        });
                        meshRenderer.gameObject = {
                            transform: new Transform()
                        };
                        meshRenderer.activated();
                    }
                    camera.normalizedViewportRect = normalizedViewportRect;
                    camera.setupCamera();
                    meshRenderer.material = material;
                    meshRenderer.render(engineUniforms);
                };
            }()),
            /**
             * @method drawTexture
             * @param {kick.texture.Texture} Texture
             * @param {kick.math.Vec4} [normalizedViewportRect=[0,0,1,1]]
             * @static
             */
            drawTexture: (function(){
                var camera,
                    engine,
                    material,
                    engineUniforms,
                    meshRenderer;
                return function(texture, normalizedViewportRect){
                    normalizedViewportRect  = normalizedViewportRect || [0,0,1,1];
                    if (!camera){
                        engine = EngineSingleton.engine;
                        camera = new Camera({
                            perspective: false,
                            left:-1,
                            right:1,
                            top:1,
                            bottom:-1,
                            near:-1,
                            far:1
                        });
                        camera.gameObject = {
                            transform: new Transform(),
                            scene: {
                                addEventListener: function(){},
                                findComponentsWithMethod: function(){return [];}
                            }
                        };
                        camera.activated();

                        var shader = engine.project.load(engine.project.ENGINE_SHADER_UNLIT);
                        material = new Material({
                            shader: shader,
                            name: "Default material"
                        });

                        engineUniforms = new EngineUniforms({
                            viewMatrix:  Mat4.identity(Mat4.create()),
                            projectionMatrix: Mat4.identity(Mat4.create()),
                            viewProjectionMatrix: Mat4.identity(Mat4.create()),
                            lightMatrix: Mat4.identity(Mat4.create()),
                            currentCamera: camera,
                            currentCameraTransform: camera.gameObject.transform
                        });
                        engineUniforms.sceneLights = {};
                        meshRenderer = new MeshRenderer({
                            mesh: engine.project.load(engine.project.ENGINE_MESH_PLANE),
                            material: material
                        });
                        meshRenderer.gameObject = {
                            transform: new Transform()
                        };
                        meshRenderer.activated();
                    }
                    camera.normalizedViewportRect = normalizedViewportRect;
                    camera.setupCamera();
                    material.setUniform("mainTexture", texture);
                    meshRenderer.material = material;
                    meshRenderer.render(engineUniforms);
                };
            }()),
            /**
             *
             * @example
             *      // render a unlit shader (with color of red) into a texture
             *      texture = new kick.texture.Texture();
             *      texture.setImageData(512, 512, 0, 5121, null, "");
             *      var renderTexture = new kick.texture.RenderTexture({dimension:[512,512], colorTexture: texture});
             *      var shader = engine.project.load(engine.project.ENGINE_SHADER_UNLIT);
             *      var renderMaterial = new kick.material.Material( {
             *          shader:shader,
             *          uniformData: {
             *              mainColor: [1,0,0,1]
             *          }
             *      });
             *      kick.core.Graphics.renderToTexture(renderTexture, renderMaterial);
             * @method renderToTexture
             * @param {kick.texture.RenderTexture} renderTexture
             * @param {kick.material.Material} material
             * @param {kick.math.Vec4} [normalizedViewportRect=[0,0,1,1]]
             * @static
             */
            renderToTexture: (function(){
                var camera,
                    engine,
                    engineUniforms,
                    meshRenderer;
                return function(renderTexture, material, normalizedViewportRect){
                    if (ASSERT){
                        if (!(renderTexture instanceof RenderTexture)){
                            fail("Graphics.renderToTexture: renderTexture must be of type RenderTexture");
                        }
                        if (!(material instanceof Material)){
                            fail("Graphics.renderToTexture: material must be of type Material");
                        }
                    }
                    normalizedViewportRect  = normalizedViewportRect || [0,0,1,1];
                    if (!camera){
                        engine = EngineSingleton.engine;
                        camera = new Camera({
                            perspective: false,
                            left:-1,
                            right:1,
                            top:1,
                            bottom:-1,
                            near:-1,
                            far:1
                        });
                        camera.gameObject = {
                            transform: new Transform(),
                            scene: {
                                addEventListener: function(){},
                                findComponentsWithMethod: function(){return [];}
                            }
                        };
                        camera.activated();

                        engineUniforms = new EngineUniforms({
                            viewMatrix:  Mat4.identity(Mat4.create()),
                            projectionMatrix: Mat4.identity(Mat4.create()),
                            viewProjectionMatrix: Mat4.identity(Mat4.create()),
                            lightMatrix: Mat4.identity(Mat4.create()),
                            currentCamera: camera,
                            currentCameraTransform: camera.gameObject.transform
                        });
                        engineUniforms.sceneLights = {};
                        meshRenderer = new MeshRenderer({
                            mesh: engine.project.load(engine.project.ENGINE_MESH_PLANE)
                        });
                        meshRenderer.gameObject = {
                            transform: new Transform()
                        };
                        meshRenderer.activated();
                    }
                    camera.normalizedViewportRect = normalizedViewportRect;
                    camera.renderTarget = renderTexture;
                    renderTexture.bind();
                    camera.setupCamera();
                    meshRenderer.material = material;
                    meshRenderer.render(engineUniforms);
                    renderTexture.unbind();
                }}())
        }
    });

define('kick/core',["./core/BuiltInResourceProvider", "./core/ChunkData", "./core/Config", "./core/Constants", "./core/Engine", "./core/EventQueue", "./core/GLState", "./core/KeyInput", "./core/MouseInput", "./core/Project", "./core/ProjectAsset", "./core/ResourceDescriptor", "./core/ResourceLoader", "./core/ResourceProvider", "./core/Time", "./core/URLResourceProvider", "./core/Util", "./core/EngineSingleton", "./core/Observable", "./core/Graphics"],
    function (BuiltInResourceProvider, ChunkData, Config, Constants, Engine, EventQueue, GLState, KeyInput, MouseInput, Project, ProjectAsset, ResourceDescriptor, ResourceLoader, ResourceProvider, Time, URLResourceProvider, Util, EngineSingleton, Observable, Graphics) {
        

        return {
            BuiltInResourceProvider: BuiltInResourceProvider,
            ChunkData: ChunkData,
            Config: Config,
            Constants: Constants,
            Engine: Engine,
            EngineSingleton: EngineSingleton,
            EventQueue: EventQueue,
            GLState: GLState,
            Graphics: Graphics,
            KeyInput: KeyInput,
            MouseInput: MouseInput,
            Observable: Observable,
            Project: Project,
            ProjectAsset: ProjectAsset,
            ResourceDescriptor: ResourceDescriptor,
            ResourceLoader: ResourceLoader,
            ResourceProvider: ResourceProvider,
            Time: Time,
            URLResourceProvider: URLResourceProvider,
            Util: Util
        };
    });

define('kick/importer/ColladaImporter',["kick/math", "kick/core/Constants", "kick/core/Util", "kick/mesh/MeshData", "kick/mesh/Mesh", "kick/scene/MeshRenderer", "kick/material/Material", "kick/core/EngineSingleton"],
    function (math, Constants, Util, MeshData, Mesh, MeshRenderer, Material, EngineSingleton) {
        

        /**
         * @module kick.importer
         */

        var ASSERT = true,
            quat = math.Quat,
            mat4 = math.Mat4,
            getXMLElementById = function (doc, id) {
                return doc.querySelector("[id=" + id + "]");
            },

            /**
             * Imports a Collada meshes into a scene
             * @class ColladaImporter
             * @namespace kick.importer
             */
                ColladaImporter = {};

        /**
         * @method import
         * @param {XMLDom|String} colladaDOM
         * @param {kick.scene.Scene} [scene=engine.activeScene] If not specified the active scene (from the engine) is used
         * @param {boolean} rotate90x rotate -90 degrees around x axis
         * @return {Object} returns container object with the properties(mesh:[], gameObjects:[], materials:[])
         * @static
         */
        ColladaImporter.import = function (colladaDOM, scene, rotate90x) {
            if (ASSERT){
                if (scene === EngineSingleton.engine){
                    Util.fail("ColladaImporter function changed - engine parameter is removed");
                }
            }
            if (typeof colladaDOM === 'string') {
                var parser = new window.DOMParser();
                colladaDOM = parser.parseFromString(colladaDOM, "text/xml");
            }
            var engine = EngineSingleton.engine,
                dataCache = {},
                allMeshes = [],
                allMaterials = [],
                constants = Constants,
                /**
                 * Converts a string to an array
                 * @method stringToArray
                 * @param {String} numberString
                 * @param {Object} [type=Array] valid types are Array (default), and typed arrays classes
                 * @private
                 */
                    stringToArray = function (numberString, type) {
                    if (!type) {
                        type = Array;
                    }
                    numberString = numberString.replace(/^\s+|\s+$/g, ""); // trim
                    numberString = numberString.replace(/\s{2,}/g, ' '); // remove double white spaces
                    var numberArray = numberString.split(" ").map(Number);
                    if (!type || type === Array) {
                        return numberArray;
                    } else {
                        // typed array
                        return new type(numberArray);
                    }
                },
                /**
                 * Get data element by id<br>
                 * Note that the array is cached by id - this is done
                 * to speed up performance in case of interleaved data
                 * @method getArrayElementById
                 * @param {String} id
                 * @return {Array_Number} data
                 * @private
                 */
                    getArrayElementById = function (id) {
                    if (id.charAt(0) === '#') {
                        id = id.substring(1);
                    }
                    if (dataCache[id]) {
                        return dataCache[id];
                    }
                    var arrayElement = getXMLElementById(colladaDOM, id),
                        type,
                        res;
                    if (arrayElement.tagName === "float_array") {
                        type = Float32Array;
                    } else {
                        type = Int32Array;
                    }
                    res = stringToArray(arrayElement.textContent, type);
                    dataCache[id] = res;
                    return res;
                },
                /**
                 * Create accessor object for data
                 * @method BuildDataAccessor
                 * @param {XML} elementChild
                 * @return function of type function(index,paramOffset)
                 * @private
                 */
                    BuildDataAccessor = function (elementChild) {
                    var semantic = elementChild.getAttribute('semantic'),
                        source = getXMLElementById(colladaDOM, elementChild.getAttribute("source").substring(1)),
                        technique_common,
                        accessor,
                        count,
                        stride,
                        offset,
                        arraySource,
                        rawData;
                    if (source.tagName === "vertices") {
                        source = source.getElementsByTagName("input")[0];
                        source = getXMLElementById(colladaDOM, source.getAttribute("source").substring(1));
                    }
                    technique_common = source.getElementsByTagName("technique_common")[0];
                    accessor = technique_common.getElementsByTagName("accessor")[0];
                    count = Number(accessor.getAttribute("count"));
                    stride = Number(accessor.getAttribute("stride"));
                    offset = Number(accessor.getAttribute("offset"));
                    if (!offset) {
                        offset = 0;
                    }
                    arraySource = accessor.getAttribute("source");
                    rawData = getArrayElementById(arraySource);

                    //
                    // param {Number} index (vertex index)
                    // param {Number} paramOffset (0 means x, 1 means y, etc)
                    // return {Number}
                    return function (index, paramOffset) {
                        var arrayIndex = offset + stride * index + paramOffset;
                        return rawData[arrayIndex];
                    };
                },
                /**
                 * @method buildFromPolyList
                 * @private
                 * @param {XMLDomElement} polylist
                 * @param {kick.mesh.MeshData} destMeshData
                 */
                    buildFromPolyList = function (polylist, destMeshData, vertexAttributeCache) {
                    var polylistChild = polylist.firstChild,
                        tagName,
                        i,
                        j,
                        vertexCount = function () { return 3; },
                        count = Number(polylist.getAttribute("count")),
                        dataAccessor = {names: [], offset: {}, accessors: {}, length: {}},
                        offsetSet = [],
                        contains = Util.contains,
                        numberOfVertices = vertexAttributeCache.numberOfVertices || 0,
                        semantic,
                        offset,
                        vCount,
                        offsetCount,
                        vertexIndices,
                        outVertexAttributes,
                        addVertexAttributes;

                    while (polylistChild !== null) {
                        tagName = polylistChild.tagName;
                        if (tagName === "input") {
                            semantic = polylistChild.getAttribute('semantic');
                            offset = Number(polylistChild.getAttribute('offset'));
                            dataAccessor.accessors[semantic] = new BuildDataAccessor(polylistChild);
                            dataAccessor.names.push(semantic);
                            dataAccessor.offset[semantic] = offset;
                            dataAccessor.length[semantic] = semantic === "TEXCOORD" ? 2 : 3;
                            if (!contains(offsetSet, offset)) {
                                offsetSet.push(offset);
                            }
                        } else if (tagName === "vcount") {
                            vCount = stringToArray(polylistChild.textContent, Int32Array);
                            vertexCount = function (i) {
                                return vCount[i];
                            };
                        } else if (tagName === "p") {
                            offsetCount = offsetSet.length;

                            vertexIndices = stringToArray(polylistChild.textContent, Int32Array);

                            // initialize data container
                            outVertexAttributes = {};
                            for (i = 0; i < dataAccessor.names.length; i++) {
                                outVertexAttributes[dataAccessor.names[i]] = [];
                            }

                            /**
                             * This method adds vertex attributes to the result index and
                             * @method addVertexAttributes
                             * @param {Number} index Source index in vertex array (the p element)
                             * @param {Object} outVertexAttributes Destination vertex index array
                             * @param {Array_Number} outTriangleIndices Destination vertex index array
                             * @private
                             */
                            addVertexAttributes = function (index, outVertexAttributes, outTriangleIndices) {
                                var cacheKey = "",
                                    offset,
                                    vertexIndex,
                                    name,
                                    i,
                                    j,
                                    indexInVertexIndices = index * offsetCount,
                                    cacheLookupRes,
                                    foundInCache,
                                    accessor,
                                    length,
                                    value,
                                    idx;
                                for (i = 0; i < dataAccessor.names.length; i++) {
                                    name = dataAccessor.names[i];
                                    offset = dataAccessor.offset[name];
                                    vertexIndex = vertexIndices[offset + indexInVertexIndices];
                                    cacheKey += index + "#" + vertexIndex + "#";
                                }
                                cacheLookupRes = vertexAttributeCache[cacheKey];
                                foundInCache = typeof cacheLookupRes === 'number';
                                if (foundInCache) {
                                    outTriangleIndices.push(cacheLookupRes);
                                } else {
                                    for (i = 0; i < dataAccessor.names.length; i++) {
                                        name = dataAccessor.names[i];
                                        accessor = dataAccessor.accessors[name];
                                        length = dataAccessor.length[name];
                                        offset = dataAccessor.offset[name];
                                        vertexIndex = vertexIndices[offset + indexInVertexIndices];
                                        for (j = 0; j < length; j++) {
                                            value = accessor(vertexIndex, j);
                                            outVertexAttributes[name].push(value);
                                        }
                                    }
                                    idx = numberOfVertices;
                                    numberOfVertices += 1;
                                    outTriangleIndices.push(idx);
                                    vertexAttributeCache[cacheKey] = idx;
                                }
                            };

                            // triangulate data
                            var index = 0,
                                triangleIndices = [];
                            for (i = 0; i < count; i++) {
                                var vertexCountI = vertexCount(i);
                                for (j = 0; j < 3; j++) {
                                    addVertexAttributes(index + j, outVertexAttributes, triangleIndices);
                                }
                                for (j = 3; j < vertexCountI; j++) {
                                    addVertexAttributes(index, outVertexAttributes, triangleIndices);
                                    addVertexAttributes(index + j - 1, outVertexAttributes, triangleIndices);
                                    addVertexAttributes(index + j, outVertexAttributes, triangleIndices);
                                }
                                index += vertexCountI;
                            }

                            for (i = 0; i < dataAccessor.names.length; i++) {
                                var name = dataAccessor.names[i],
                                    nameMeshData = name.toLowerCase();
                                if (nameMeshData === "texcoord") {
                                    nameMeshData = "uv1";
                                }
                                if (destMeshData[nameMeshData] && destMeshData[nameMeshData].length) {
                                    // array already exist - append data
                                    var toArray = Util.typedArrayToArray,
                                        source = toArray(destMeshData[nameMeshData]),
                                        append = toArray(outVertexAttributes[name]);
                                    source.push.apply(source, append); // short way to append one array to another
                                    destMeshData[nameMeshData] = source;
                                } else {
                                    destMeshData[nameMeshData] = outVertexAttributes[name];
                                }
                            }
                            destMeshData.meshType = 4;
                            var subMeshes = destMeshData.subMeshes;
                            subMeshes.push(triangleIndices);
                            destMeshData.subMeshes = subMeshes;
                        }
                        polylistChild = polylistChild.nextSibling;
                    }

                    vertexAttributeCache.numberOfVertices = numberOfVertices;
                },
                /**
                 * Builds meshdata component (based on a &lt;mesh&gt; node)
                 * @method buildMeshData
                 */
                    buildMeshData = function (colladaDOM, engine, geometry) {
                    var tagName,
                        meshChild,
                        name = geometry.getAttribute('name') || "MeshData",
                        destMeshData,
                        mesh = geometry.getElementsByTagName("mesh");
                    if (mesh.length === 0) {
                        return null;
                    }
                    var vertexAttributeCache = {};
                    mesh = mesh[0];
                    meshChild = mesh.firstChild;
                    while (meshChild !== null) {
                        tagName = meshChild.tagName;
                        if (tagName === "lines") {
                            Util.warn("Collada importer: lines - unsupported");
                        } else if (tagName === "linestrips - unsupported") {
                            Util.warn("Collada importer:linestrips - unsupported");
                        } else if (tagName === "polygons") {
                            Util.warn("Collada importer:polygons  - unsupported");
                        } else if (tagName === "polylist" || tagName === "triangles") {
                            if (!destMeshData) {
                                destMeshData = new MeshData({name: name});
                            }
                            buildFromPolyList(meshChild, destMeshData, vertexAttributeCache);
                        } else if (tagName === "trifans") {
                            Util.warn("Collada importer: Trifans unsupported");
                        } else if (tagName === "tristrips") {
                            Util.warn("Collada importer: Tristrips - unsupported");
                        }
                        meshChild = meshChild.nextSibling;
                    }
                    return destMeshData;
                },
                getMeshesById = function (engine, meshid) {
                    var meshArray = [],
                        k,
                        geometry;
                    if (meshCache[meshid]) {
                        return meshCache[meshid];
                    }
                    if (meshid && meshid.charAt(0) === "#") {
                        meshid = meshid.substring(1);
                    }
                    for (k = 0; k < geometries.length; k++) {
                        geometry = geometries[k];
                        if (geometry.getAttribute("id") === meshid) {
                            var meshData = buildMeshData(colladaDOM, engine, geometry);
                            if (meshData) {
                                var newMesh = new Mesh({meshData: meshData, name: meshData.name + " mesh"});
                                allMeshes.push(newMesh);
                                meshArray.push(newMesh);
                            }
                            break;
                        }
                    }
                    meshCache[meshid] = meshArray;
                    return meshArray;
                },
                updateTransform = function (transform, node) {
                    var tagName = node.tagName,
                        sid = node.getAttribute('sid'),
                        angleAxis,
                        angle,
                        rotationQuat,
                        matrix,
                        decomposedTranslation = math.Vec3.create(),
                        decomposedRotation = math.Quat.create(),
                        decomposedScale = math.Vec3.create(),
                        localMatrix = transform.getLocalMatrix(),
                        newMatrix = mat4.identity(mat4.create());
                    if (tagName === "translate") {
                        mat4.translate(newMatrix, newMatrix, stringToArray(node.textContent));
                    } else if (tagName === "rotate") {
                        angleAxis = stringToArray(node.textContent);
                        angle = angleAxis[3];
                        if (angle) {
                            rotationQuat = quat.setAxisAngle(math.Quat.create(), angleAxis, angle * 0.01745329251994);
                            quat.toMat4(newMatrix, rotationQuat);
                        } else {
                            return;
                        }
                    } else if (tagName === "scale") {
                        mat4.scale(newMatrix, newMatrix, stringToArray(node.textContent));
                    } else if (tagName === "matrix") {
                        mat4.transpose(stringToArray(node.textContent), newMatrix);
                    } else {
                        Util.warn("Collada importer:" + tagName + " - unsupported");
                        return;
                    }
                    mat4.multiply(newMatrix, localMatrix, newMatrix);
                    mat4.decompose(newMatrix, decomposedTranslation, decomposedRotation, decomposedScale);
                    transform.localPosition = decomposedTranslation;
                    transform.localRotation = decomposedRotation;
                    transform.localScale = decomposedScale;
                },
                createMeshRenderer = function (gameObject, node) {
                    var url = node.getAttribute("url"),
                        meshRenderer,
                        meshes,
                        i,
                        newMaterial;
                    if (url) {
                        url = url.substring(1);
                    }

                    meshes = getMeshesById(engine, url);
                    for (i = 0; i < meshes.length; i++) {
                        meshRenderer = new MeshRenderer();
                        meshRenderer.mesh = meshes[i];
                        newMaterial = new Material({
                            name: "Some material",
                            shader: engine.project.load(engine.project.ENGINE_SHADER_DEFAULT)
                        });
                        meshRenderer.material = newMaterial;
                        allMaterials.push(newMaterial);

                        gameObject.addComponent(meshRenderer);
                    }
                },
                addNode = function (node, parent) {
                    var gameObject = scene.createGameObject(),
                        transform = gameObject.transform,
                        childNode,
                        tagName;
                    if (parent) {
                        transform.parent = parent;
                    }
                    gameObject.name = node.getAttribute("id");
                    allGameObjects.push(gameObject);
                    childNode = node.firstElementChild;
                    while (childNode) {
                        tagName = childNode.tagName;
                        if (tagName === "translate" || tagName === "rotate" || tagName === "scale" || tagName === "matrix") {
                            updateTransform(transform, childNode);
                        } else if (tagName === "instance_geometry") {
                            createMeshRenderer(gameObject, childNode);
                        } else if (tagName === "node") {
                            addNode(childNode, transform);
                        } else {
                            Util.warn("Collada importer: ignore collada tagName '" + tagName + "'");
                        }
                        childNode = childNode.nextElementSibling;
                    }
                };

            var libraryGeometries = colladaDOM.firstChild.getElementsByTagName("library_geometries"),
                visualScenes = colladaDOM.firstChild.getElementsByTagName("visual_scene"),
                geometries,
                i;

            if (!scene) {
                scene = engine.activeScene;
            }
            if (libraryGeometries.length === 0) {
                // no geometries found
            }

            libraryGeometries = libraryGeometries[0];
            geometries = libraryGeometries.getElementsByTagName("geometry");
            var allGameObjects = [],
                meshCache = {};

            for (i = 0; i < visualScenes.length; i++) {
                var visualScene = visualScenes[i],
                    node = visualScene.firstElementChild;
                while (node) {
                    addNode(node, null);
                    node = node.nextElementSibling;
                }
            }
            if (rotate90x) {
                // ideally it would be better to transform the geometry
                // instead of introducing a new parent
                var parent = scene.createGameObject({name: "Collada Parent"}),
                    parentTransform = parent.transform;
                parentTransform.localRotationEuler = [-90, 0, 0];
                for (i = 0; i < allGameObjects.length; i++) {
                    var goTransform = allGameObjects[i].transform;
                    if (!goTransform.parent) {
                        goTransform.parent = parentTransform;
                    }
                }
                allGameObjects.push(parent);
            }
            return {mesh: allMeshes, gameObjects: allGameObjects, materials: allMaterials};
        };

        return ColladaImporter;
    });

define('kick/importer/ObjImporter',["kick/math", "kick/mesh/MeshData", "kick/mesh/Mesh", "kick/scene/MeshRenderer", "kick/material/Material", "kick/core/Constants", "kick/core/EngineSingleton"],
    function (math, MeshData, Mesh, MeshRenderer, Material, Constants, EngineSingleton) {
        

        var ASSERT = true,
            quat = math.Quat,
            mat4 = math.Mat4,
            /**
             * Imports a Wavefront .obj mesh into a scene. The importer loading both normals and texture coordinates from the
             * model if available. Note that each import can contains multiple models and each model may have multiple
             * sub-meshes.
             * @class ObjImporter
             * @namespace kick.importer
             */
                ObjImporter = {};

        /**
         * @method import
         * @param {String} objFileContent
         * @param {kick.scene.Scene} [scene=engine.activeScene] Optional. If not specified the active scene (from the engine) is used
         * @param {boolean} [rotate90x] rotate -90 degrees around x axis
         * @return {Object} returns container object with the properties (mesh:[], gameObjects:[], materials:[])
         * @static
         */
        ObjImporter.import = function (objFileContent, scene, rotate90x) {
            if (ASSERT){
                if (scene === EngineSingleton.engine){
                    Util.fail("ObjImporter function changed - engine parameter is removed");
                }
            }
            var engine = EngineSingleton.engine,
                lines = objFileContent.split("\n"),
                linesLength = lines.length,
                vertices = [],
                normals = [],
                textureCoordinates = [],
                triangles = [],
                materialNames = [],
                submeshes = [triangles],
                allGameObjects = [],
                allMaterials = [],
                allMeshes = [],
                objectName = "MeshObject",
                i,
                j,
                trim = function (str) { return str.replace(/^\s+|\s+$/g, ""); },
                strAsArray = function (numberString, type) {
                    if (!type) {
                        type = Array;
                    }
                    numberString = numberString.replace(/^\s+|\s+$/g, ""); // trim
                    numberString = numberString.replace(/\s{2,}/g, ' '); // remove double white spaces
                    var numberArray = numberString.split(" ").map(Number);
                    if (!type || type === Array) {
                        return numberArray;
                    } else {
                        // typed array
                        return new type(numberArray);
                    }
                },
                getIndices = function (strArray) {
                    var array = [],
                        i,
                        str,
                        splittedStr,
                        vertexIndex;
                    for (i = 0; i < strArray.length; i++) {
                        str = strArray[i];
                        splittedStr = str.split("/");
                        vertexIndex = parseInt(splittedStr[0], 10);
                        array.push([vertexIndex,
                            splittedStr.length >= 2 ? parseInt(splittedStr[1], 10) : vertexIndex,
                            splittedStr.length >= 3 ? parseInt(splittedStr[2], 10) : vertexIndex]);
                    }

                    return array;
                },
                addObject = function () {
                    var pushVertexData = function (source, index, dest) {
                        var sourceElement = source[index - 1], // note: obj is 1 indexed - therefor -1
                            i;
                        for (i = 0; i < sourceElement.length; i++) {
                            dest.push(sourceElement[i]);
                        }
                    };
                    if (vertices.length === 0) {
                        return;
                    }
                    var gameObject = scene.createGameObject(),
                        meshData = new MeshData(),
                        mesh = new Mesh(),
                        meshDataVertices = [],
                        meshDataNormals = [],
                        meshDataTextureCoordinates = [],
                        meshDataIndices,
                        meshDataSubmeshes = [],
                        cache = {},
                        count = 0,
                        vertexUvsNormalStrArray,
                        idx,
                        vertexUvsNormalStr,
                        k,
                        i,
                        j;
                    allMeshes.push(mesh);
                    for (k = 0; k < submeshes.length; k++) {
                        triangles = submeshes[k];
                        meshDataIndices = [];
                        meshDataSubmeshes.push(meshDataIndices);
                        for (i = 0; i < triangles.length; i++) {
                            vertexUvsNormalStrArray = triangles[i]; // has the value such as ["1//1", "2//2", "3//3"]
                            idx = getIndices(vertexUvsNormalStrArray);
                            for (j = 0; j < 3; j++) {
                                vertexUvsNormalStr = vertexUvsNormalStrArray[j]; // has the value such as "1//1"
                                if (typeof cache[vertexUvsNormalStr] === 'number') { // if index is in the cache, reuse index
                                    meshDataIndices.push(cache[vertexUvsNormalStr]);
                                } else {
                                    pushVertexData(vertices, idx[j][0], meshDataVertices);
                                    if (textureCoordinates.length) {
                                        pushVertexData(textureCoordinates, idx[j][1], meshDataTextureCoordinates);
                                    }
                                    if (normals.length) {
                                        pushVertexData(normals, idx[j][2], meshDataNormals);
                                    }
                                    meshDataIndices.push(count);
                                    cache[vertexUvsNormalStr] = count;
                                    count++;
                                }
                            }
                        }
                    }

                    meshData.vertex = meshDataVertices;
                    if (meshDataNormals.length) {
                        meshData.normal = meshDataNormals;
                    }
                    if (meshDataTextureCoordinates.length) {
                        meshData.uv1 = meshDataTextureCoordinates;
                    }
                    meshData.subMeshes = meshDataSubmeshes;
                    mesh.meshData = meshData;
                    mesh.name = objectName + " mesh";
                    var meshRenderer = new MeshRenderer();
                    meshRenderer.mesh = mesh;

                    var materials = [];

                    var addDefaultMaterial = function (name) {
                        var newMaterial = new Material({
                            name: name,
                            shader: engine.project.load(engine.project.ENGINE_SHADER_DEFAULT)
                        });
                        materials.push(newMaterial);
                        allMaterials.push(newMaterial);
                    };

                    for (i = 0; i < meshDataSubmeshes.length; i++) {
                        if (i < materialNames.length) {
                            var materialName = materialNames[i];
                            var projectMaterial = engine.project.loadByName(materialName, "kick.material.Material");
                            if (projectMaterial) {
                                materials.push(projectMaterial);
                            } else {
                                addDefaultMaterial(materialName);
                            }
                        } else {
                            addDefaultMaterial("material");
                        }
                    }

                    meshRenderer.materials = materials;
                    gameObject.name = objectName;
                    gameObject.addComponent(meshRenderer);
                    allGameObjects.push(gameObject);
                    triangles = [];
                };

            var transformMatrix = mat4.identity(mat4.create());
            if (rotate90x) {
                mat4.rotateX(transformMatrix, -90 * 0.01745329251994);
            }

            for (i = 0;i < linesLength; i++) {
                var line = trim(lines[i]);
                var tokenIndex = line.indexOf(' ');
                if (tokenIndex < 0) {
                    continue;
                }
                var token = line.substring(0, tokenIndex);
                var value = line.substring(tokenIndex + 1);
                if (token === "o") {
                    addObject();
                    objectName = value;
                    materialNames.length = 0;
                } else if (token === "usemtl") {
                    materialNames.push(value);
                    // create material with name value is not exist
                    if (triangles.length > 0) {
                        triangles = [];
                        submeshes[submeshes.length] = triangles;
                    }
                } else if (token === "v") {
                    var vertex = strAsArray(value);
                    mat4.multiplyVec3(vertex, transformMatrix, vertex);
                    vertices.push(vertex);
                } else if (token === "vn") {
                    var normal = strAsArray(value);
                    mat4.multiplyVec3(normal, transformMatrix, normal);
                    normals.push(normal);
                } else if (token === "vt") {
                    textureCoordinates.push(strAsArray(value));
                } else if (token === "f") {
                    var polygon = value.split(" ");
                    triangles.push(polygon.slice(0, 3));
                    for (j = 3; j < polygon.length; j++) {
                        triangles.push([polygon[j - 1], polygon[j], polygon[0]]);
                    }
                }
            }
            addObject();

            return {mesh: allMeshes, gameObjects: allGameObjects, materials: allMaterials};
        };
        return ObjImporter;
    });

define('kick/importer',["./importer/ColladaImporter", "./importer/ObjImporter"],
    function (ColladaImporter, ObjImporter) {
        

        return {
            ColladaImporter: ColladaImporter,
            ObjImporter: ObjImporter
        };
    });

define('kick/material',["./material/GLSLConstants", "./material/Material", "./material/MaterialUniform", "./material/Shader", "./material/UniformDescriptor"],
    function (GLSLConstants, Material, MaterialUniform, Shader, UniformDescriptor) {
        

        return {
            GLSLConstants: GLSLConstants,
            Material: Material,
            MaterialUniform: MaterialUniform,
            Shader: Shader,
            UniformDescriptor: UniformDescriptor
        };
    });

define('kick/mesh',["./mesh/Mesh", "./mesh/MeshData", "./mesh/MeshDataFactory"], function (Mesh, MeshData, MeshDataFactory) {
    

    return {
        Mesh: Mesh,
        MeshData: MeshData,
        MeshDataFactory: MeshDataFactory
    };
});

define('kick/scene/Component',[], function () {
    

    /**
     * This class only specifies the interface of a component.
     * @namespace kick.scene
     * @class Component
     */

    /**
     * The gameObject owning the component. Initially undefined. The value is set when the Component object is added
     * to a GameObject
     * @property gameObject
     * @type kick.scene.GameObject
     */

    /**
     * Abstract method called when a component is added to scene. May be undefined. <br>
     * This method method works in many cases like a constructor function, where references to other game objects can
     * be looked up (this cannot be done when the actual constructor function is called, since the scene may not be
     * loaded completely).<br>
     * Note that activated are called just after update methods on all components has been called - this makes it easier
     * to get references to other components.
     * @method activated
     */

    /**
     * Abstract method called when a component is removed from scene. May be undefined.
     * @method deactivated
     */


    /**
     * Abstract method called every at every rendering of the object. May be undefined.
     * @method render
     * @param {kick.scene.EngineUniforms} engineUniforms
     * @param {kick.material.Material} [overwriteMaterial]
     */

    /**
     * Components with largest priority are invoked first. (optional - default 0). Cannot be modified after creation.
     * @property scriptPriority
     * @type Number
     */

    /**
     * Defines the axis aligned bounding box used for view frustum culling
     * May be undefined or null.
     * @property aabb
     * @type kick.math.Aabb
     */

    /**
     * Default value is 1000<br>
     * &lt; 1999 default geometry<br>
     * 1999 skybox<br>
     * 2001 - 2999 transparent geometry (sorted back-to-front when rendered)<br>
     * &gt; 3000 overlay geometry rendered on top
     * @property renderOrder
     * @type Number
     */

    /**
     * Optional name of the component type.
     * If specified, the component can be accessed directly from the gameObject.
     * If multiple components with same component type is added to the same gameObject, the access through gameObject is undefined
     * @example
     *      // kick.scene.Transform has the type 'transform'
     *      var transform = gameObject.transform;
     * @property componentType
     * @type String
     * @final
     */


    /**
     * Abstract method called every update. May be undefined.
     * @method update
     */

    /**
     * Fire events when components are updated.
     * May be undefined.
     * Must be defined before adding to gameObject.
     * @event componentUpdated
     * @param {kick.scene.Component} component
     */

    /**
     * Creates a JSON version of the configuration of the class. May be undefined, if so the
     * kick.core.Util.componentToJSON() are used for serializing of the component.<br>
     * Note that references to assets, gameObjects or other components should be wrapped by the kick.core.Util.getJSONReference() method
     * @method toJSON
     * @return {Object}
     */
    return {};
});

define('kick/scene/Skybox',["require", "kick/core/ProjectAsset", "./SceneLights", "kick/core/Constants", "kick/core/Util", "./Camera", "./Light", "./GameObject", "kick/core/EngineSingleton", "kick/core/Observable", "kick/material/Material", "kick/core/Project"],
    function (require, ProjectAsset, SceneLights, Constants, Util, Camera, Light, GameObject, EngineSingleton, Observable, Material, Project) {
        

        var DEBUG = true,
            ASSERT = true;

        /**
         * Create a skybox object. Must be attached to a GameObject with camera component -
         * otherwise nothing will be rendered. The camera must have a near clipping plane less than 1.0 and a far
         * clipping plane greater than 1.0, otherwise the skybox will be clipped.
         *
         * The skybox is rendered with render order 1999, which should be the last rendering of the opaque geometry to
         * avoid overdraw.
         *
         * @example
         *     var skyBox = new kick.scene.Skybox();
         *     skyBox.material = new kick.material.Material( {
         *        shader: engine.project.load(engine.project.ENGINE_SHADER_SKYBOX),
         *        uniformData: {
         *            mainTexture: cubemapTexture
         *        }
         *     });
         *     cameraGameObject.addComponent(skyBox);
         * @class Skybox
         * @extends kick.scene.Component
         * @namespace kick.scene
         * @constructor
         * @param {Object} config
         */
        return function (config) {
            var material,
                cube,
                transform,
                thisObj = this,
                renderOrder = 1999,
                gl,
                contextRestoredListener = function(restoredGL){
                    gl = restoredGL;
                };

            Object.defineProperties(this, {
                /**
                 * The renderOrder for materials[0]
                 * @property renderOrder
                 * @type {Number}
                 */
                renderOrder: {
                    get: function () {
                        return renderOrder;
                    }
                },
                material:{
                    get:function(){
                        return material;
                    },
                    set:function(newValue){
                        if (ASSERT){
                            if (!(newValue instanceof Material)) {
                                Util.fail("Skybox.material must be a kick.material.Material");
                            }
                        }
                        material = newValue;
                        if (material){
                            renderOrder = material.renderOrder;
                        }
                    },
                    enumerable: true
                },
                /**
                 * Name of the component type = "skybox".
                 * @example
                 *      var skybox = gameObject.skybox;
                 * @property componentType
                 * @type String
                 * @final
                 */
                componentType: {value:"skybox"}
            });

            this.activated = function () {
                var engine = EngineSingleton.engine;
                if (!cube){
                    cube = engine.project.load(Project.ENGINE_MESH_CUBE);
                    transform = thisObj.gameObject.transform;
                }
                engine.addEventListener("contextRestored", contextRestoredListener);
                gl = engine.gl;
            };

            this.deactivated = function(){
                var engine = EngineSingleton.engine;
                engine.removeEventListener("contextRestored", contextRestoredListener);
            };

            /**
             * Render skybox
             * @method render
             * @param {kick.scene.EngineUniforms} engineUniforms
             * @param {kick.material.Material} [overwriteMaterial]
             */
            this.render = function(engineUniforms, overwriteMaterial){
                var shader = material.shader;

                if (!overwriteMaterial) {
                    gl.depthRange(1,1);
                    cube.bind(shader);
                    shader.bindUniform(material, engineUniforms, transform);
                    cube.render(0);
                    gl.depthRange(0,1);
                }
            };

            /**
             * @method toJSON
             * @return {JSON}
             */
            this.toJSON = function () {
                return Util.componentToJSON(this, "kick.scene.Skybox");
            };

            Util.applyConfig(this, config);
        };
    });

define('kick/scene',["./scene/Camera", "./scene/Component", "./scene/EngineUniforms", "./scene/GameObject", "./scene/Light", "./scene/MeshRenderer", "./scene/Scene", "./scene/SceneLights", "./scene/Transform", "./scene/Skybox"],
    function (Camera, Component, EngineUniforms, GameObject, Light, MeshRenderer, Scene, SceneLights, Transform, Skybox) {
        

        return {
            Camera: Camera,
            Component: Component,
            EngineUniforms: EngineUniforms,
            GameObject: GameObject,
            Light: Light,
            MeshRenderer: MeshRenderer,
            Scene: Scene,
            SceneLights: SceneLights,
            Transform: Transform,
            Skybox: Skybox
        };
    });

define('kick/texture/MovieTexture',["kick/core/ProjectAsset", "kick/core/Constants", "kick/core/Util", "kick/core/EngineSingleton"],
    function (ProjectAsset, Constants, Util, EngineSingleton) {
        

        /**
         * @module kick.texture
         */

        /**
         * A movie texture associated with a video element (or canvas tag) will update the content every frame (when it is bound).
         * @class MovieTexture
         * @namespace kick.texture
         * @constructor
         * @param {Object} [config]
         * @extends kick.core.ProjectAsset
         */
        return function (config) {
            // extend ProjectAsset
            ProjectAsset(this, config, "kick.texture.MovieTexture");
            if (true){
                if (config === EngineSingleton.engine){
                    Util.fail("MovieTexture constructor changed - engine parameter is removed");
                }
            }
            var engine = EngineSingleton.engine,
                gl = engine.gl,
                glState = engine.glState,
                texture0 = 33984,
                _name = "MovieTexture",
                _videoElement = null,
                _textureId = gl.createTexture(),
                _wrapS = 33071,
                _wrapT = 33071,
                _minFilter = 9728,
                _magFilter = 9728,
                _intFormat = 6408,
                _skipFrames = 0,
                _generateMipmaps = false,
                timer = engine.time,
                thisObj = this,
                lastGrappedFrame = -1,
                setTextureProperties = function(){
                    gl.texParameteri(3553, 10240, _magFilter);
                    gl.texParameteri(3553, 10241, _minFilter);
                    gl.texParameteri(3553, 10242, _wrapS);
                    gl.texParameteri(3553, 10243, _wrapT);
                },
                contextLost = function () {
                    gl = null;
                },
                contextRestored = function (newGl) {
                    gl = newGl;
                    _textureId = gl.createTexture();
                    setTextureProperties();
                };

            /**
             * Bind the current texture
             * And update the texture from the video element (unless it has already been updated in this frame)
             * @method bind
             */
            this.bind = function (textureSlot) {
                gl.activeTexture(texture0 + textureSlot);
                gl.bindTexture(3553, _textureId);

                if (lastGrappedFrame < timer.frame && _videoElement) {
                    lastGrappedFrame = timer.frame + _skipFrames;
                    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
                    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA,
                        gl.UNSIGNED_BYTE, _videoElement);
                    if (_generateMipmaps) {
                        gl.generateMipmap(3553);
                    }
                }
            };

            /**
             * Deallocates the texture from memory
             * @method destroy
             */
            this.destroy = function () {
                if (_textureId !== null) {
                    glState.currentMaterial = null; // for material to rebind
                    gl.deleteTexture(_textureId);
                    _textureId = null;
                    engine.project.removeResourceDescriptor(thisObj.uid);
                    engine.removeEventListener("contextLost", contextLost);
                    engine.removeEventListener("contextRestored", contextRestored);
                }
            };

            /**
             * Creates a 2x2 temporary image (checkerboard)
             * @method setTemporaryTexture
             */
            this.setTemporaryTexture = function () {
                var blackWhiteCheckerboard = new Uint8Array([255, 255, 255, 0, 0, 0, 0, 0, 0, 255, 255, 255]);
                thisObj.bind(0); // bind to texture slot 0
                gl.pixelStorei(3317, 1);
                gl.texImage2D(3553, 0, 6407, 2, 2, 0, 6407, 5121, blackWhiteCheckerboard);
                setTextureProperties();
                glState.currentMaterial = null; // for material to rebind
            };

            Object.defineProperties(this, {
                /**
                 * @property name
                 * @type String
                 */
                name: {
                    get: function () {
                        return _name;
                    },
                    set: function (newValue) {
                        _name = newValue;
                    }
                },
                /**
                 * 0 means update movie texture every frame. 1 skip one frame update, 2 skips two frames etc.
                 * @property skipFrames
                 * @type {Number}
                 * @default 0
                 */
                skipFrames: {
                    get: function () {
                        return _skipFrames;
                    },
                    set: function (newValue) {
                        _skipFrames = newValue;
                    }
                },
                /**
                 * @property videoElement
                 * @type {VideoElement}
                 */
                videoElement: {
                    get: function () {
                        return _videoElement;
                    },
                    set: function (newValue) {
                        _videoElement = newValue;
                    }
                },
                /**
                 * Autogenerate mipmap levels<br>
                 * Note that enabling auto mipmap on movie textures uses a lot of resources.
                 * @property generateMipmaps
                 * @type Boolean
                 * @default false
                 */
                generateMipmaps: {
                    get: function () {
                        return _generateMipmaps;
                    },
                    set: function (value) {
                        if (true) {
                            if (typeof value !== 'boolean') {
                                Util.fail("MovieTexture.generateMipmaps was not a boolean");
                            }
                        }
                        _generateMipmaps = value;
                    }
                },
                /**
                 * @property textureId
                 * @type {Number}
                 * @protected
                 */
                textureId: {
                    value: _textureId
                },
                /**
                 * Texture.wrapS should be either GL\_CLAMP\_TO\_EDGE or GL\_REPEAT<br>
                 * @property wrapS
                 * @type Object
                 * @default GL_REPEAT
                 */
                wrapS: {
                    get: function () {
                        return _wrapS;
                    },
                    set: function (value) {
                        if (true) {
                            if (value !== 33071 && value !== 10497) {
                                Util.fail("Texture.wrapS should be either GL_CLAMP_TO_EDGE or GL_REPEAT");
                            }
                        }
                        _wrapS = value;
                        gl.bindTexture(3553, _textureId);
                        gl.texParameteri(3553, 10242, _wrapS);
                        glState.currentMaterial = null; // for material to rebind
                    }
                },
                /**
                 * Texture.wrapT should be either GL\_CLAMP\_TO\_EDGE or GL\_REPEAT<br>
                 * @property wrapT
                 * @type Object
                 * @default GL_REPEAT
                 */
                wrapT: {
                    get: function () {
                        return _wrapT;
                    },
                    set: function (value) {
                        if (true) {
                            if (value !== 33071 && value !== 10497) {
                                Util.fail("Texture.wrapT should be either GL_CLAMP_TO_EDGE or GL_REPEAT");
                            }
                        }
                        _wrapT = value;
                        gl.bindTexture(3553, _textureId);
                        gl.texParameteri(3553, 10243, _wrapT);
                        glState.currentMaterial = null; // for material to rebind
                    }
                },
                /**
                 * Texture.minFilter should be either GL\_NEAREST, GL\_LINEAR, GL\_NEAREST\_MIPMAP\_NEAREST, <br>
                 * GL\_LINEAR\_MIPMAP\_NEAREST, GL\_NEAREST\_MIPMAP\_LINEAR, GL\_LINEAR\_MIPMAP\_LINEAR<br>
                 * @property minFilter
                 * @type Object
                 * @default GL_LINEAR
                 */
                minFilter: {
                    get: function () {
                        return _minFilter;
                    },
                    set: function (value) {
                        if (true) {
                            if (value !== 9728 &&
                                    value !== 9729 &&
                                    value !== 9984 &&
                                    value !== 9985 &&
                                    value !== 9986 &&
                                    value !== 9987) {
                                Util.fail("Texture.minFilter should be either GL_NEAREST, GL_LINEAR, GL_NEAREST_MIPMAP_NEAREST, GL_LINEAR_MIPMAP_NEAREST, GL_NEAREST_MIPMAP_LINEAR, GL_LINEAR_MIPMAP_LINEAR");
                            }
                        }
                        _minFilter = value;
                        gl.bindTexture(3553, _textureId);
                        gl.texParameteri(3553, 10241, _minFilter);
                        glState.currentMaterial = null; // for material to rebind
                    }
                },
                /**
                 * Texture.magFilter should be either GL\_NEAREST or GL\_LINEAR. <br>
                 * @property magFilter
                 * @type Object
                 * @default GL_LINEAR
                 */
                magFilter: {
                    get: function () {
                        return _magFilter;
                    },
                    set: function (value) {
                        if (true) {
                            if (value !== 9728 && value !== 9729) {
                                Util.fail("Texture.magFilter should be either GL_NEAREST or GL_LINEAR");
                            }
                        }
                        _magFilter = value;
                        gl.bindTexture(3553, _textureId);
                        gl.texParameteri(3553, 10240, _magFilter);
                        glState.currentMaterial = null; // for material to rebind
                    }
                },
                /**
                 * Specifies the internal format of the image (format on GPU)<br>
                 * Must be one of the following:
                 * GL\_ALPHA,
                 * GL\_RGB,
                 * GL\_RGBA,
                 * GL\_LUMINANCE,
                 * GL\_LUMINANCE_ALPHA
                 * @property internalFormat
                 * @type Number
                 * @default GL_RGBA
                 * @deprecated
                 */
                internalFormat: {
                    get: function () {
                        return _intFormat;
                    },
                    set: function (value) {
                        if (value !== 6406 &&
                                value !== 6407  &&
                                value !== 6408 &&
                                value !== 6409 &&
                                value !== 6410) {
                            Util.fail("Texture.internalFormat should be either GL_ALPHA, GL_RGB, GL_RGBA, GL_LUMINANCE, or LUMINANCE_ALPHA");
                        }
                        _intFormat = value;
                    }
                }
            });

            /**
             * Serializes the data into a JSON object (that can be used as a config parameter in the constructor)<br>
             * Note that the texture data is not serialized in the json format. <br>
             * This means that either setImage() or setImageData() must be called before the texture can be bound<br>
             * @method toJSON
             * @return {Object} config element
             */
            this.toJSON = function () {
                return {
                    uid: thisObj.uid,
                    wrapS: _wrapS,
                    wrapT: _wrapT,
                    minFilter: _minFilter,
                    name: _name,
                    magFilter: _magFilter
                };
            };

            // Invoke init in project asset
            this.init(config);
            engine.addEventListener("contextLost", contextLost);
            engine.addEventListener("contextRestored", contextRestored);
        };
    });

define('kick/texture',["./texture/MovieTexture", "./texture/RenderTexture", "./texture/Texture"],
    function (MovieTexture, RenderTexture, Texture) {
        

        return {
            MovieTexture: MovieTexture,
            RenderTexture: RenderTexture,
            Texture: Texture
        };
    });

define('kick/components/FullWindow',["kick/core"], function (core) {
        

        var Util = core.Util;

        /**
         * A simple class that adapts the size of the canvas to the containing window.
         * The canvas need not to be positioned at the top.
         * Note this works best if the body has a margin of 0
         * @class FullWindow
         * @extends kick.scene.Component
         * @constructor
         * @namespace kick.components
         * @param {Object} config
         */
        return function () {
            var engine = core.Engine.instance,
                canvas = engine.canvas,
                resizeTimeout,
                documentResized = function () {
                    canvas.width = window.innerWidth;
                    canvas.height = window.innerHeight - canvas.offsetTop;
                },
            // https://developer.mozilla.org/en-US/docs/DOM/Mozilla_event_reference/resize
                resizeThrottler = function () {
                    // ignore resize events as long as an actualResizeHandler execution is in the queue
                    if ( !resizeTimeout ) {
                        resizeTimeout = setTimeout(function() {
                            resizeTimeout = null;
                            documentResized();

                            // The actualResizeHandler will execute at a rate of 15fps
                        }, 66);
                    }
                };
            documentResized();

            /**
             * Registers the object on activation
             * @method activated
             */
            this.activated = function(){
                window.addEventListener("resize", resizeThrottler);
            };

            /**
             * @method deactivated
             */
            this.deactivated = function(){
                window.removeEventListener("resize", resizeThrottler);
            };

            Object.defineProperties(this, {
                /**
                 * Name of the component componentType = "fullWindow".
                 * @example
                 *      var fullWindow = gameObject.fullWindow;
                 * @property componentType
                 * @type String
                 * @final
                 */
                componentType: {value:"fullWindow"}
            });

            /**
             * @method toJSON
             * @return {JSON}
             */
            this.toJSON = function () {
                return Util.componentToJSON(this, "kick.components.FullWindow");
            };

        };
    }
);

define('kick/components/FPSWalker',["kick/core", "kick/math", "kick/scene"], function (core, math, scene) {
        
        var DEGREE_TO_RADIAN = 0.01745329251994,
            Util = core.Util;
        /**
         * A simple walker class which can be added to a camera to navigate in a scene.
         * @class FPSWalker
         * @constructor
         * @extends kick.scene.Component
         * @namespace kick.components
         * @param {Object} config
         */
        return function(config){
            var engine,
                transform,
                keyInput,
                mouseInput,
                rotateY = 0,
                rotateX = 0,
                time,
                position,
                rotationEuler = math.Vec3.create(),
                forward = "W".charCodeAt(0),
                backward = "S".charCodeAt(0),
                strideLeft = "A".charCodeAt(0),
                strideRight = "D".charCodeAt(0),
                thisObj = this,
                camera,
                updateCameraObject = function () {
                    camera = thisObj.gameObject.getComponentOfType(scene.Camera);
                };

            /**
             * Default behavior is to rotate view whenever mouse in being pressed. The rotation around X axis is clamped
             * to +/- 179 degrees.
             * @method rotateObject
             */
            this.rotateObject = function(){
                if (mouseInput.isButton(0)){
                    var deltaMovement = mouseInput.deltaMovement,
                        rotationSpeed = 1/ (camera.viewportRect[3])*camera.fieldOfView;
                    if (deltaMovement[0] !== 0 || deltaMovement[1] !== 0){
                        // note horizontal movement rotates around Y axis
                        rotateY += deltaMovement[0] * thisObj.rotateSpeedY * rotationSpeed;
                        rotateX += deltaMovement[1] * thisObj.rotateSpeedX * rotationSpeed;
                        rotateX = Math.max(-179, Math.min(179, rotateX));
                        rotationEuler[0] = rotateX;
                        rotationEuler[1] = rotateY;
                        transform.localRotationEuler = rotationEuler;
                    }
                }
            };

            /**
             * Move object based on movement keys (AWSD as default)
             * @method moveObject
             */
            this.moveObject = function(){
                var moveDistance = thisObj.movementSpeed * time.deltaTime,
                    deltaZ = 0,
                    deltaX = 0,
                    rotateYRadian,
                    cosY,
                    sinY;
                if (keyInput.isKey(forward)){
                    deltaZ = -moveDistance;
                } else if (keyInput.isKey(backward)){
                    deltaZ = moveDistance;
                }

                if (keyInput.isKey(strideLeft)){
                    deltaX = -moveDistance;
                } else if (keyInput.isKey(strideRight)){
                    deltaX = moveDistance;
                }

                // move in XZ plane
                if (deltaX !== 0 || deltaZ !== 0){
                    rotateYRadian = -rotateY*DEGREE_TO_RADIAN;
                    cosY = Math.cos(rotateYRadian);
                    sinY = Math.sin(rotateYRadian);
                    // rotate around y
                    position[0] += deltaX * cosY - deltaZ * sinY;
                    position[2] += deltaX * sinY + deltaZ * cosY;

                    // adjust height
                    position[1] = thisObj.getGroundHeight(position[0], position[2]);

                    // update position
                    transform.position = position;
                }
            };

            /**
             * @method setMovementKeys
             * @param {Number} forward_
             * @param {Number} backward_
             * @param {Number} strideLeft_
             * @param {Number} strideRight_
             */
            this.setMovementKeys = function(forward_, backward_, strideLeft_, strideRight_){
                forward = forward_;
                backward = backward_;
                strideLeft = strideLeft_;
                strideRight = strideRight_;
            };

            /**
             * @property movementSpeed
             * @type {number}
             * @default 0.1
             */
            this.movementSpeed = 0.10;
            /**
             * @property rotateSpeedX
             * @type {number}
             * @default 1.0
             */
            this.rotateSpeedX = 1.00;
            /**
             * @property rotateSpeedY
             * @type {number}
             * @default 1.0
             */
            this.rotateSpeedY = 1.00;

            Object.defineProperties(this, {
                /**
                 * Name of the component componentType = "fpsWalker".
                 * @example
                 *      var fpsWalker = gameObject.fpsWalker;
                 * @property componentType
                 * @type String
                 * @final
                 */
                componentType: {value:"fpsWalker"}
            });

            /**
             * Registers the object on activation
             * @method activated
             */
            this.activated = function(){
                engine = core.Engine.instance;
                transform = thisObj.gameObject.transform;
                keyInput = engine.keyInput;
                mouseInput = engine.mouseInput;
                time = engine.time;
                position = transform.position;
                updateCameraObject();
                thisObj.gameObject.addEventListener("componentAdded", updateCameraObject);
                thisObj.gameObject.addEventListener("componentRemoved", updateCameraObject);
            };

            /**
             * @method deactivated
             */
            this.deactivated = function(){
                thisObj.gameObject.removeEventListener("componentAdded", updateCameraObject);
                thisObj.gameObject.removeEventListener("componentRemoved", updateCameraObject);
            };

            /**
             * @method update
             */
            this.update = function(){
                if (camera){
                    this.rotateObject();
                    this.moveObject();
                }
            };

            /**
             * Return the height of the ground at position x,z
             * @method getGroundHeight
             * @param {Number} x
             * @param {Number} z
             * @return {number}
             */
            this.getGroundHeight = function(x,z){
                return 0;
            };

            /**
             * @method toJSON
             * @return {JSON}
             */
            this.toJSON = function () {
                return Util.componentToJSON(this, "kick.components.FPSWalker");
            };

            Util.applyConfig(this, config);
        };
    }
);

define('kick/components',["./components/FullWindow", "./components/FPSWalker"], function (FullWindow, FPSWalker) {
    

    return {
        FullWindow: FullWindow,
        FPSWalker: FPSWalker
    };
});

define('kick/animation/ControlPoint',["kick/core/Util", "kick/core/Constants", "kick/core/Observable"],
    function (Util, Constants, Observable) {
        

        /**
         *
         * @class ControlPoint
         * @namespace kick.animation
         * @constructor
         * @param {Config} config defines one or more properties
         */
        return function (config) {
            var time,
                value,
                inSlope,
                outSlope,
                thisObj = this;

            /**
             * Fired when a control point has been updated
             * @event changed
             * @param {kick.animation.ControlPoint} controlPoint
             */
            Observable.call(this,["changed"]);

            Object.defineProperties(this, {
                /**
                 * @property time
                 * @type Number
                 */
                time: {
                    get: function(){
                        return time;
                    },
                    set:function(newValue){
                        time = newValue;
                        thisObj.fireEvent("changed", thisObj);
                    },
                    enumerable: true
                },
                /**
                 * @property value
                 * @type Number|kick.math.Vec2|kick.math.Vec3|kick.math.Vec4
                 */
                value: {
                    get: function(){
                        return value;
                    },
                    set:function(newValue){
                        value = newValue;
                        thisObj.fireEvent("changed", thisObj);
                    },
                    enumerable: true
                },
                /**
                 * @property inSlope
                 * @type Number|kick.math.Vec2|kick.math.Vec3|kick.math.Vec4
                 */
                inSlope: {
                    get: function(){
                        return inSlope;
                    },
                    set:function(newValue){
                        inSlope = newValue;
                        thisObj.fireEvent("changed", thisObj);
                    },
                                        enumerable: true
                },
                /**
                 * @property outSlope
                 * @type Number|kick.math.Vec2|kick.math.Vec3|kick.math.Vec4
                 */
                outSlope: {
                    get: function(){
                        return outSlope;
                    },
                    set:function(newValue){
                        outSlope = newValue;
                        thisObj.fireEvent("changed", thisObj);
                    },
                                        enumerable: true
                }
            });

            /**
             * @method toJSON
             * @return {Object} data object
             */
            this.toJSON = function () {
                return {time:time,
                    value:value instanceof Float32Array ? Util.typedArrayToArray(value) : value ,
                    inSlope: inSlope instanceof Float32Array ? Util.typedArrayToArray(inSlope) : inSlope,
                    outSlope:outSlope instanceof Float32Array ? Util.typedArrayToArray(outSlope) : outSlope
                };
            };

            Util.applyConfig(this, config);
        };
    }
);

define('kick/animation/Curve',["kick/core/Util", "kick/core/Constants"],
    function (Util, Constants) {
        

        var Curve,
            ASSERT = true,
            repeat = function(t, length){
                return t - Math.floor(t / length) * length;
            },
            lerpAngle = function(a, b, t){
                var num = repeat(b - a, 360);
                if (num > 180){
                    num -= 360;
                }
                t = Math.max(0,Math.min(1,t));
                return a * num * t;
            };

        /**
         *
         * @class Curve
         * @namespace kick.animation
         * @constructor
         * @param {Config} config defines one or more properties
         */
        Curve = function (config) {
            var controlPoints = [],
                curveType = Curve.NUMBER,
                resArray,
                evaluateTangent = [
                    // number
                    function(value, slope, weight){
                        return value + slope * weight;
                    },
                    // vec2
                    function(value, slope, weight){
                        return [
                            value[0] + slope[0] * weight,
                            value[1] + slope[1] * weight
                        ];
                    },
                    // vec3
                    function(value, slope, weight){
                        return [
                            value[0] + slope[0] * weight,
                            value[1] + slope[1] * weight,
                            value[2] + slope[2] * weight
                        ];
                    },
                    // vec4
                    function(value, slope, weight){
                        return [
                            value[0] + slope[0] * weight,
                            value[1] + slope[1] * weight,
                            value[2] + slope[2] * weight,
                            value[3] + slope[3] * weight
                        ];
                    }/*,
                    // euler
                    function(value, slope, weight){
                        return [
                            value[0] + slope[0] * weight,
                            value[1] + slope[1] * weight,
                            value[2] + slope[2] * weight
                        ];
                    }*/
                ],
                evaluateCurves = [
                    // number
                    function(w1,w2,w3,w4,p1,p2,p3,p4){
                        return w1 * p1 + w2 * p2 + w3 * p3 + w4 * p4;
                    },
                    // vec2
                    function(w1,w2,w3,w4,p1,p2,p3,p4){
                        resArray[0] = w1 * p1[0] + w2 * p2[0] + w3 * p3[0] + w4 * p4[0];
                        resArray[1] = w1 * p1[1] + w2 * p2[1] + w3 * p3[1] + w4 * p4[1];
                        return resArray;
                    },
                    // vec3
                    function(w1,w2,w3,w4,p1,p2,p3,p4){
                        resArray[0] = w1 * p1[0] + w2 * p2[0] + w3 * p3[0] + w4 * p4[0];
                        resArray[1] = w1 * p1[1] + w2 * p2[1] + w3 * p3[1] + w4 * p4[1];
                        resArray[2] = w1 * p1[2] + w2 * p2[2] + w3 * p3[2] + w4 * p4[2];
                        return resArray;
                    },
                    // vec4
                    function(w1,w2,w3,w4,p1,p2,p3,p4){
                        resArray[0] = w1 * p1[0] + w2 * p2[0] + w3 * p3[0] + w4 * p4[0];
                        resArray[1] = w1 * p1[1] + w2 * p2[1] + w3 * p3[1] + w4 * p4[1];
                        resArray[2] = w1 * p1[2] + w2 * p2[2] + w3 * p3[2] + w4 * p4[2];
                        resArray[3] = w1 * p1[3] + w2 * p2[3] + w3 * p3[3] + w4 * p4[3];
                        return resArray;
                    }//,
                    // eulers angels
                    /*function(t,p1,p2,p3,p4){
                        var tmp1,tmp2,tmp3,tmp4,tmp5;

                        tmp1 = [lerpAngle(p1[0], p2[0], t), lerpAngle(p1[1], p2[1], t), lerpAngle(p1[2], p2[2], t)];
                        tmp2 = [lerpAngle(p2[0], p3[0], t), lerpAngle(p2[1], p3[1], t), lerpAngle(p2[2], p3[2], t)];
                        tmp3 = [lerpAngle(p3[0], p4[0], t), lerpAngle(p3[1], p4[1], t), lerpAngle(p3[2], p4[2], t)];

                        tmp4 = [lerpAngle(tmp1[0], tmp2[0], t), lerpAngle(tmp1[1], tmp2[1], t), lerpAngle(tmp1[2], tmp2[2], t)];
                        tmp5 = [lerpAngle(tmp2[0], tmp3[0], t), lerpAngle(tmp2[1], tmp3[1], t), lerpAngle(tmp2[2], tmp3[2], t)];

                        resArray[0] = lerpAngle(tmp4[0], tmp5[0], t);
                        resArray[1] = lerpAngle(tmp4[1], tmp5[1], t);
                        resArray[2] = lerpAngle(tmp4[2], tmp5[2], t);
                        return resArray;
                    }*/
                ],
                currentCurveEvaluation = evaluateCurves[curveType],
                currentEvaluateTangent = evaluateTangent[curveType];

            Object.defineProperties(this, {
                /**
                 * Must be Curve.NUMBER, Curve.VEC2, Curve.VEC3, Curve.EULERS_ANGELS, Curve.VEC4
                 * @property curveType
                 * @type Number
                 */
                curveType: {
                    set: function(newValue){
                        if (curveType === newValue){
                            return;
                        }
                        curveType = newValue;
                        if (curveType === Curve.VEC2){
                            resArray = new Float32Array(2);
                        }
                        if (curveType === Curve.VEC3 || curveType === Curve.EULERS_ANGELS){
                            resArray = new Float32Array(3);
                        }
                        if (curveType === Curve.VEC4){
                            resArray = new Float32Array(4);
                        }

                        if (ASSERT){
                            if (controlPoints.length > 0){
                                Util.warn("Cannot change curvetype when curve is not empty");
                            }
                        }
                        currentCurveEvaluation = evaluateCurves[curveType];
                        currentEvaluateTangent = evaluateTangent[curveType];
                    },
                    get: function(){
                        return curveType;
                    }
                },
                /**
                 * @property startTime
                 * @type Number
                 * @readOnly
                 */
                startTime: {
                    get: function(){
                        return controlPoints[0].time;
                    }
                },
                /**
                 * @property endTime
                 * @type Number
                 * @readOnly
                 */
                endTime: {
                    get: function(){
                        return controlPoints[controlPoints.length-1].time;
                    }
                }
            });

            /**
             * Removes all control points within the curve
             * @method clear
             */
            this.clear = function(){
                controlPoints.length = 0;
            };

            /**
             * @method addControlPoint
             * @param {kick.animation.ControlPoint} controlPoint
             */
            this.addControlPoint = function(controlPoint){
                var i;
                for (i = 0; i < controlPoints.length; i++) {
                    if (controlPoint.time < controlPoints[i]){
                        break;
                    }
                }
                controlPoints.splice(i, 0, controlPoint);
            };

            /**
             * @method evaluate
             * @param time
             * @returns {*}
             */
            this.evaluate = function(time){
                var i,
                    from,
                    to,
                    timeDelta,
                    u,
                    uMinusOne,
                    w1,
                    w2,
                    w3,
                    w4,
                    p0,
                    p1,
                    p2,
                    p3;
                if (time < controlPoints[0].time){
                    return controlPoints[0].time;
                }
                // find two end points
                for (i=1;i < controlPoints.length && controlPoints[i].time<time;i++){
                    // do nothing
                }
                if (i === controlPoints.length) {
                    return controlPoints[i-1].value;
                }
                from = controlPoints[i-1];
                to = controlPoints[i];
                timeDelta = to.time - from.time;
                u = (time - from.time) / timeDelta;
                p0 = from.value;
                p1 = currentEvaluateTangent(from.value,from.outSlope, timeDelta/3);
                p2 = currentEvaluateTangent(to.value,to.inSlope, -timeDelta/3);
                p3 = to.value;
                uMinusOne = 1-u;
                w1 = uMinusOne * uMinusOne * uMinusOne;
                w2 = 3 * u * uMinusOne * uMinusOne;
                w3 = 3 * u * u * uMinusOne;
                w4 = u * u * u;

                return currentCurveEvaluation(w1, w2, w3, w4, p0, p1, p2, p3);
            };
            Util.copyStaticPropertiesToObject(this, Curve);
        };

        /**
         * @property NUMBER
         * @type Number
         * @readOnly
         * @static
         */
        Curve.NUMBER = 0;
        /**
         * @property VEC2
         * @type Number
         * @readOnly
         * @static
         */
        Curve.VEC2 = 1;
        /**
         * @property VEC3
         * @type Number
         * @readOnly
         * @static
         */
        Curve.VEC3 = 2;
        /**
         * @property VEC4
         * @type Number
         * @readOnly
         * @static
         */
        Curve.VEC4 = 3;
//        Curve.EULERS_ANGELS = 4;

        return Curve;
    }
);

define('kick/animation/AnimationComponent',["kick/core/Util", "kick/core/Constants", "kick/core/Observable", "kick/core/EngineSingleton"],
    function (Util, Constants, Observable, EngineSingleton) {
        

        var ASSERT = true;

        /**
         *
         * @class AnimationComponent
         * @namespace kick.animation
         * @constructor
         * @param {Config} config defines one or more properties
         */
        return function (config) {
            var thisObj = this,
                animations = [],
                runningAnimations = [],
                time = EngineSingleton.engine.time,
                animationStarted = function(animation){
                    runningAnimations.push(animation);
                },
                animationStopped = function(animation){
                    Util.removeElementFromArray(runningAnimations, animation);
                },
                animationUpdateRequested = function(animation){
                    animation._update(0, thisObj.gameObject);
                };

            /**
             * @method addAnimation
             * @param {kick.animation.Animation} animation
             */
            this.addAnimation = function(animation){
                animations.push(animation);
                animation.addEventListener("started", animationStarted);
                animation.addEventListener("stopped", animationStopped);
                animation.addEventListener("updateRequested", animationUpdateRequested);
            };

            /**
             * @method removeAnimation
             * @param {kick.animation.Animation} animation
             */
            this.removeAnimation = function(animation){
                var i;
                for (i = animations.length - 1; i >= 0; i--) {
                    if (animations[i] === animation){
                        animations.splice(i, 1);
                        animation.addEventListener("started", animationStarted);
                        animation.addEventListener("stopped", animationStopped);
                        animation.addEventListener("updateRequested", animationUpdateRequested);
                    }
                }
            };

            /**
             * @method getAnimation
             * @param {Number} index
             * @return {kick.animation.Animation}
             */
            this.getAnimation = function(index){
                if (ASSERT){
                    if (animations.length <= index){
                        Util.warn("AnimationComponent.getAnimation index out of bounds");
                        return null;
                    }
                }
                return animations[index];
            };

            Object.defineProperties(this, {
                /**
                 * @property count
                 * @type Number
                 */
                count: {
                    get:function(){
                        return animations.length;
                    }
                }
            });

            this.update = function(){
                var i,
                    gameObject = thisObj.gameObject,
                    tSeconds = time.deltaTime / 1000;
                for (i = 0; i < runningAnimations.length; i++){
                    runningAnimations[i]._update(tSeconds, gameObject);
                }
            };

            /**
             * Set the scriptPriority to 1 (invoked before other scripts)
             * @property scriptPriority
             * @type {number}
             * @default 1
             */
            this.scriptPriority = 1;

            /**
             * @method toJSON
             * @return {Object} data object
             */
            this.toJSON = function () {
                return {};
            };

            Util.applyConfig(this, config);
        };
    }
);

define('kick/animation/Animation',["kick/core/Util", "kick/core/Constants", "kick/core/Observable"],
    function (Util, Constants, Observable) {
        

        var ASSERT = true,
            Animation;

        /**
         *
         * @class Animation
         * @namespace kick.animation
         * @constructor
         * @param {Config} config defines one or more properties
         */
        Animation = function (config) {
            var thisObj = this,
                playing = false,
                localTime = 0,
                componentNames = [],
                propertyNames = [],
                curves = [],
                wrapMode = Animation.LOOP,
                direction = 1,
                speed = 1;

            /**
             * Fired when a animation is started
             * @event started
             * @param {kick.animation.Animation} animation
             */
            /**
             * Fired when a animation is stopped
             * @event stopped
             * @param {kick.animation.Animation} animation
             */
            /**
             * Fired when
             * @event updateRequested
             * @param {kick.animation.Animation} animation
             */
            /**
             * Fired when animation is looped or changed direction (in ping pong)
             * @event animationLoop
             * @param {kick.animation.Animation} animation
             */
            Observable.call(this,["started", "stopped","updateRequested", "animationLoop"]);


            Object.defineProperties(this, {
                /**
                 * Used for starting and pausing the animation
                 * @property playing
                 * @type Boolean
                 * @default false
                 */
                playing:{
                    get:function(){
                        return playing;
                    },
                    set:function(newValue){
                        if (playing === newValue){
                            return;
                        }
                        if (ASSERT){
                            if (typeof newValue !== "boolean"){
                                Util.warn("Animation.playing should be boolean");
                            }
                        }
                        playing = newValue;
                        thisObj.fireEvent(playing?"started":"stopped", thisObj);
                    }
                },
                /**
                 * Must be Animation.LOOP, Animation.PINGPONG or Animation.ONCE
                 * @property wrapMode
                 * @type Number
                 * @default Animation.LOOP
                 */
                wrapMode: {
                    set: function(newValue){
                        if (ASSERT){
                            if (newValue !== Animation.LOOP && newValue !== Animation.PINGPONG && newValue !== Animation.ONCE){
                                Util.warn("Animation.wrapMode must be Animation.LOOP, Animation.PINGPONG or Animation.ONCE");
                            }
                        }
                        wrapMode = newValue;
                    },
                    get: function(){
                        return wrapMode;
                    }
                },
                /**
                 * Animation speed
                 * @property speed
                 * @type Number
                 * @default 1
                 */
                speed: {
                    set: function(newValue){
                        speed = newValue;
                    },
                    get: function(){
                        return speed;
                    }
                },
                /**
                 * Animation time
                 * @property time
                 * @type Number
                 * @readonly
                 */
                time:{
                    get: function(){
                        return localTime;
                    }
                }
            });

            /**
             * Set animationTime
             * @method setTime
             * @param {Number} newTime
             * @param {Boolean} forceUpdate will instantly update animation
             */
            this.setTime = function(newTime, forceUpdate){
                localTime = newTime;
                if (forceUpdate){
                    thisObj.fireEvent("updateRequested", thisObj);
                }
            };

            /**
             * @method addCurve
             * @param {kick.animation.Curve} curve
             * @param {String} target componentname.property
             */
            this.addCurve = function(curve, target){
                if (ASSERT){
                    if (target.indexOf('.') === -1){
                        Util.warn("Animation.addCurve target is invalid");
                    }
                }
                var dotIndex = target.indexOf('.'),
                    componentName = target.substring(0,dotIndex),
                    propertyName = target.substring(dotIndex+1);
                curves.push(curve);
                componentNames.push(componentName);
                propertyNames.push(propertyName);
            };

            /**
             * @method removeCurve
             * @param {kick.animation.Curve|string} object removes curve by Object or name
             * @return {Boolean}
             */
            this.removeCurve = function(object){
                var deleted = false,
                    i;
                for (i  = componentNames.length - 1; i >= 0; i--) {
                    if (curves[i] === object || (componentNames[i] + '.' + propertyNames[i]) === object){
                        // remove object
                        curves.splice(i, 1);
                        componentNames.splice(i, 1);
                        propertyNames.splice(i, 1);
                        deleted = true;
                    }
                }
                return deleted;
            };

            /**
             * @method _update
             * @param {Number} timeSeconds
             * @param {kick.scene.GameObject} gameObject
             */
            this._update = function(timeSeconds, gameObject){
                var i,
                    maxTime = 0;

                for (i = 0; i < componentNames.length; i++) {
                    maxTime = Math.max(maxTime, curves[i].endTime);
                }
                localTime += timeSeconds*speed*direction;
                if (wrapMode === Animation.PINGPONG){
                    if (localTime < 0){
                        localTime *= -1;
                        direction = 1;
                        thisObj.fireEvent("animationLoop", thisObj);
                    } else if (localTime > maxTime){
                        localTime = maxTime - (localTime % maxTime);
                        direction = -1;
                        thisObj.fireEvent("animationLoop", thisObj);
                    }
                }
                if (wrapMode === Animation.LOOP){
                    if (localTime > maxTime){
                        localTime = localTime % maxTime;
                        thisObj.fireEvent("animationLoop", thisObj);
                    }
                }
                if (wrapMode === Animation.ONCE){
                    if (localTime > maxTime){
                        localTime = maxTime;
                        this.playing = false;
                    }
                }
                for (i = 0; i < componentNames.length; i++) {
                    gameObject[componentNames[i]][propertyNames[i]] = curves[i].evaluate(localTime);
                }
            };

            /**
             * @method toJSON
             * @return {Object} data object
             */
            this.toJSON = function () {
                return {};
            };

            Util.applyConfig(this, config);
            Util.copyStaticPropertiesToObject(this, Animation);
        };

        Animation.LOOP = 0;
        Animation.PINGPONG = 1;
        Animation.ONCE = 2;

        return Animation;
    }
);

define('kick/animation',["./animation/ControlPoint", "./animation/Curve", "./animation/AnimationComponent", "./animation/Animation"],
    function (ControlPoint, Curve, AnimationComponent, Animation) {

        

        return {
            AnimationComponent: AnimationComponent,
            Animation: Animation,
            ControlPoint: ControlPoint,
            Curve: Curve
        };
    });

define('kick/postfx/CameraRenderToTexture',["kick/core/Constants", "kick/core/Observable", "kick/texture/Texture", "kick/texture/RenderTexture", "kick/core/Graphics"],
    function (Constants, Observable, Texture, RenderTexture, Graphics) {
        

        /**
         * @class CameraRenderToTexture
         * @namespace kick.postfx
         * @extends kick.scene.Component
         * @constructor
         * @param {Config}
         */
        return function CameraRenderToTexture(){
            var camera,
                engine,
                thisObj = this,
                texture = new Texture(),
                renderTexture,
                width,
                height,
                scale = 1.0,
                postProcessingEffects = [],
                postRender = function(){
                    var t = texture,
                        i;
                    for (i=0;i<postProcessingEffects.length;i++){
                        t = postProcessingEffects[i].renderPostEffect();
                    }
                    Graphics.drawTexture(t);
                };

            Object.defineProperties(this, {
                scale: {
                    get:function(){
                        return scale;
                    },
                    set:function(newValue){
                        scale = newValue;
                    }
                },
                texture: {
                    get:function(){
                        return texture;
                    }
                }
            });

            Observable.call(this, [
                /**
                 * @event screenSizeChanged
                 * @param {kick.math.Vec2} size
                 */
                "screenSizeChanged"
            ]
            );

            /**
             * @method addEffect
             * @param {kick.postfx.PostProcessingEffect} effect
             */
            this.addEffect = function(effect){
                postProcessingEffects.push(effect);
            };

            /**
             * Clear the effects queue
             * @method clearEffects
             */
            this.clearEffects = function(){
                postProcessingEffects.length = 0;
            };

            this.activated = function(){
                var i;
                engine = thisObj.gameObject.scene.engine;
                texture.generateMipmaps = false;
                texture.minFilter = 9728;
                texture.magFilter = 9728;
                texture.wrapS = 33071;
                texture.wrapT = 33071;
                width = engine.canvasDimension[0];
                height = engine.canvasDimension[1];
                texture.setImageData(width, height, 0, 5126, null, "");
                renderTexture = new RenderTexture({colorTexture: texture});
                camera = thisObj.gameObject.camera;
                camera.renderTarget = renderTexture;
                camera.addEventListener("postRender", postRender);
                for (i=0;i<postProcessingEffects.length;i++){
                    postProcessingEffects[i].activated(engine);
                }
                thisObj.fireEvent("screenSizeChanged", [width, height]);
            };

            this.deactivated = function(){
                camera.removeEventListener("postRender", postRender);
            };

            this.update = function(){
                var i;
                if (width !== engine.canvasDimension[0]*scale || height !== engine.canvasDimension[1]*scale){
                    width = engine.canvasDimension[0]*scale;
                    height = engine.canvasDimension[1]*scale;
                    texture.setImageData(width, height, 0, 5126, null, "");
                    renderTexture.colorTexture = texture;
                    for (i=0;i<postProcessingEffects.length;i++){
            //            postProcessingEffects[i].update();
                    }
                    thisObj.fireEvent("screenSizeChanged", [width, height]);
                }
            };
        };
    });

define('kick/postfx/PostProcessingEffect',["kick/core/Constants", "kick/texture/RenderTexture", "kick/texture/Texture", "kick/core/Graphics", "kick/core/EngineSingleton"],
    function (Constants, RenderTexture, Texture, Graphics, EngineSingleton) {
        

        /**
         * @class PostProcessingEffect
         * @namespace kick.postfx
         * @extends kick.scene.Component
         * @constructor
         * @param {Config}
         */
        return function PostProcessingEffect(){
            var engine,
                texture = new Texture(),
                material,
                renderTexture,
                width,
                height;

            this.scale = 1.0;

            this.activated = function(){
                engine = EngineSingleton.engine;
                texture.generateMipmaps = false;
                texture.minFilter = 9728;
                texture.magFilter = 9728;
                texture.wrapS = 33071;
                texture.wrapT = 33071;
                width = engine.canvasDimension[0];
                height = engine.canvasDimension[1];
                texture.setImageData(width, height, 0, 5126, null, "");
                renderTexture = new RenderTexture({colorTexture: texture});
            };

            this.deactivated = function(){
                renderTexture.destroy();
                texture.destroy();
            };

            Object.defineProperties(this, {
                texture: {
                    get:function(){
                        return texture;
                    }
                },
                material:{
                    get:function(){
                        return material;
                    },
                    set:function(newMaterial){
                        material = newMaterial;
                    }
                }
            });

            this.renderPostEffect = function(){
                if (material){
                    if (width !== engine.canvasDimension[0]*this.scale || height !== engine.canvasDimension[1]*this.scale){
                        width = engine.canvasDimension[0]*this.scale;
                        height = engine.canvasDimension[1]*this.scale;
                        console.log("Resize to "+width+","+height);
                        texture.setImageData(width, height, 0, 5126, null, "");
                        renderTexture.colorTexture = texture;
                    }


                    Graphics.renderToTexture(renderTexture, material);
                }
                return texture;
            };
        };
    });

define('kick/postfx/BloomPostFX',["kick/core/Constants", "kick/core/Observable", "kick/texture/Texture", "kick/texture/RenderTexture", "kick/core/Graphics"],
    function (Constants, Observable, Texture, RenderTexture, Graphics) {
        

        /**
         * @class BloomPostFX
         * @namespace kick.postfx
         * @extends kick.scene.Component
         * @constructor
         * @param {Config}
         */
        return function BloomPostFX(){

        };
    }
);

define('kick/postfx',["./postfx/CameraRenderToTexture", "./postfx/PostProcessingEffect", "./postfx/BloomPostFX"],
    function (CameraRenderToTexture, PostProcessingEffect, BloomPostFX) {
    

    return {
        CameraRenderToTexture: CameraRenderToTexture,
        PostProcessingEffect: PostProcessingEffect,
        BloomPostFX: BloomPostFX
    };
});

define('kick',["kick/core", "kick/importer", "kick/material", "kick/math", "kick/mesh", "kick/scene", "kick/texture", "kick/components", "kick/animation", "kick/postfx"],
    function (core, importer, material, math, mesh, scene, texture, components, animation, postfx) {
        
        return {
            core: core,
            components: components,
            importer: importer,
            material: material,
            math: math,
            mesh: mesh,
            scene: scene,
            texture: texture,
            animation: animation,
            postfx: postfx
        };
    });
